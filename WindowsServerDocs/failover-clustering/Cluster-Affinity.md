---
title: Сходство кластеров
ms.prod: windows-server
ms.manager: eldenc
ms.technology: failover-clustering
ms.topic: article
author: johnmarlin-msft
ms.date: 03/07/2019
description: В этой статье описывается сходство отказоустойчивого кластера и уровни противосходства
ms.openlocfilehash: 9a269d2b14e953daee849008a473c750dfbfe84b
ms.sourcegitcommit: 6aff3d88ff22ea141a6ea6572a5ad8dd6321f199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71361465"
---
# <a name="cluster-affinity"></a>Сходство кластеров

> Относится к: Windows Server 2019, Windows Server 2016

Отказоустойчивый кластер может содержать множество ролей, которые могут перемещаться между узлами и запускаться.  Бывают случаи, когда некоторые роли (например, виртуальные машины, группы ресурсов и т. д.) не должны выполняться на одном узле.  Это может быть вызвано потреблением ресурсов, использованием памяти и т. д.  Например, существует две виртуальные машины, которые используют память и ЦП, и если две виртуальные машины работают на одном узле, то на одной или обеих виртуальных машинах могут возникнуть проблемы с производительностью.  В этой статье рассматриваются уровни антисходства кластеров и их использование.

## <a name="what-is-affinity-and-antiaffinity"></a>Что такое сходство и антисходство?

Сходство — это правило, которое вы настроили, которое устанавливает связь между двумя или несколькими ролями (i, e, виртуальные машины, группы ресурсов и т. д.) для их совместного сохранения.  Антисходство одинаково, но используется для попыток и сохранения указанных ролей друг от друга.  Отказоустойчивые кластеры используют для своих ролей антисходство.  В частности, параметр [AntiAffinityClassNames](https://docs.microsoft.com/previous-versions/windows/desktop/mscs/groups-antiaffinityclassnames) , определенный для ролей, не выполняется на одном узле.  

## <a name="antiaffinityclassnames"></a>AntiAffinityClassnames

При просмотре свойств группы существует параметр AntiAffinityClassNames, который по умолчанию пуст.  В приведенных ниже примерах group1 и группа2 должны быть отделены от выполнения на одном узле.  Для просмотра свойства команда PowerShell и результат будут выглядеть следующим образом:

    PS> Get-ClusterGroup Group1 | fl AntiAffinityClassNames
    AntiAffinityClassNames : {}

    PS> Get-ClusterGroup Group2 | fl AntiAffinityClassNames
    AntiAffinityClassNames : {}

Так как AntiAffinityClassNames не определены как значения по умолчанию, эти роли могут выполняться одновременно или отдельно.  Задача заключается в том, чтобы они были разделены.  Значение для AntiAffinityClassNames может быть любым, что вы хотите, они должны быть одинаковыми.  Предположим, что group1 и группа2 являются контроллерами домена, работающими на виртуальных машинах, и их лучше обслуживать на разных узлах.  Так как это контроллеры домена, я буду использовать DC для имени класса.  Чтобы задать значение, команда PowerShell и результаты будут выглядеть следующим образом:

    PS> $AntiAffinity = New-Object System.Collections.Specialized.StringCollection
    PS> $AntiAffinity.Add("DC")
    PS> (Get-ClusterGroup -Name "Group1").AntiAffinityClassNames = $AntiAffinity
    PS> (Get-ClusterGroup -Name "Group2").AntiAffinityClassNames = $AntiAffinity

    PS> Get-ClusterGroup "Group1" | fl AntiAffinityClassNames
    AntiAffinityClassNames : {DC}

    PS> Get-ClusterGroup "Group2" | fl AntiAffinityClassNames
    AntiAffinityClassNames : {DC}

Теперь, когда они заданы, отказоустойчивая кластеризация будет пытаться отследить их.  

Параметр Антиаффинитикласснаме является "мягким" блоком.  Это означает, что он будет пытаться отследить их, но если это невозможно, он по-прежнему будет разрешать их запуск на одном узле.  Например, группы выполняются в отказоустойчивом кластере с двумя узлами.  Если один узел должен перейти на обслуживание, это означает, что обе группы будут работать на одном узле.  В этом случае это было бы допустимо.  Он может быть не самым идеальным, но оба виртиал машины будут работать в пределах допустимых диапазонов производительности.

## <a name="i-need-more"></a>Мне нужно больше

Как уже упоминалось, AntiAffinityClassNames является мягким блоком.  Но что делать, если требуется жесткая блокировка?  Виртуальные машины не могут быть запущены на том же узле; в противном случае возникнет влияние на производительность и привести к невозможности перехода некоторых служб в недоступное место.

В таких случаях имеется дополнительное свойство кластера Клустеренфорцедантиаффинити.  Этот уровень сходства предотвращает все затраты на то, что любые из одних и тех же значений AntiAffinityClassNames будут выполняться на одном узле.

Чтобы просмотреть свойство и значение, команда PowerShell (и результат) будет выглядеть следующим образом:

    PS> Get-Cluster | fl ClusterEnforcedAntiAffinity
    ClusterEnforcedAntiAffinity : 0

Значение "0" означает, что оно отключено и не должно применяться.  Значение "1" включает его и является жестким блоком.  Чтобы включить этот жесткий блок, команда (и результат) будет:

    PS> (Get-Cluster).ClusterEnforcedAntiAffinity = 1
    ClusterEnforcedAntiAffinity : 1

Если заданы оба параметра, группа будет заблокирована в сети вместе.  Если они находятся на одном узле, это будет показано в диспетчер отказоустойчивости кластеров.

![Сходство кластеров](media/Cluster-Affinity/Cluster-Affinity-1.png)

В списке групп PowerShell вы увидите следующее:

    PS> Get-ClusterGroup

    Name       State
    ----       -----
    Group1     Offline(Anti-Affinity Conflict)
    Group2     Online

## <a name="additional-comments"></a>Дополнительные комментарии

- Убедитесь, что в зависимости от потребностей используется правильный параметр для обеспечения сходства.
- Помните, что в сценарии с двумя узлами и Клустеренфорцедантиаффинити, если один из узлов не работает, обе группы не будут работать.  

- Использование предпочтительных владельцев в группах может сочетаться с антисходством в кластере из трех или более узлов.
- Параметры AntiAffinityClassNames и Клустеренфорцедантиаффинити будут выполняться только после повторного использования ресурсов. ТАКОГО. их можно задать, но если обе группы находятся в сети на одном узле, они будут оставаться в сети.




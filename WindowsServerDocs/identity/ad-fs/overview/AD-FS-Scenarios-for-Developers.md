---
ms.assetid: 8a64545b-16bd-4c13-a664-cdf4c6ff6ea0
title: Сценарии AD FS для разработчиков
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adfs
ms.openlocfilehash: fb1bc5776ea4d24f274c79563d9e346b104de6d9
ms.sourcegitcommit: eaf071249b6eb6b1a758b38579a2d87710abfb54
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/31/2019
ms.locfileid: "66444222"
---
# <a name="ad-fs-scenarios-for-developers"></a>Сценарии AD FS для разработчиков


AD FS в Windows Server 2016 [AD FS 2016] позволяет добавить отраслевой стандартный OpenID Connect и OAuth 2.0 на основе проверки подлинности и авторизации для приложений, которые вы разрабатываете и эти приложения проверки подлинности пользователей непосредственно в AD FS.    
  
AD FS 2016 также поддерживает WS-Federation, WS-Trust и SAML, протоколы и профили мы установлена поддерживаемая в предыдущих версиях.  Если вы заинтересованы в руководстве разработчика для этих протоколов, ознакомьтесь со статьей ниже.  В этой статье основное внимание уделяется способы использования и преимуществами новой поддержки протокола.  
  
## <a name="why-modern-authentication"></a>Почему современные средства проверки подлинности  
Вы можете продолжать использовать AD FS для входа на с WS-Federation, WS-Trust и SAML протоколы так же, как у есть прежде, чем с более новые протоколы, вы получаете следующие преимущества:  
  
* **Простоты и согласованности**  
    * Используйте тот же набор API-интерфейсы и шаблоны для разрешения входа для:   
        *   несколько типов приложений (сервера, настольных компьютеров, мобильных, обозреватель)  
        *   несколько платформ (android, iOS, Windows)  
        *   приложения в корпоративной сети или в облаке  
    * Используйте тот же набор библиотек, которые позволяют использовать для проверки подлинности пользователей в Azure AD  
* **Гибкость**  
    * Помимо авторизацию обычного пользователя такие как поддерживают более сложные сценарии:      
        * ? 3-ступенчатой вход, потоки, в которых пользователь разрешает одного веб-приложения или службы для доступа к ресурсам, которые находятся в другой веб-приложение или служба.    
        * ? Потоки между серверами, в которых служба среднего уровня, обращается к серверной части API  
        * ? На основе JavaScript одностраничных приложениях (SPA)  
* **Поддержка**  
    * OAuth 2.0 и OpenID Connect наслаждайтесь широкого использования в отрасли, поэтому знание этих шаблонов поможет вам реализовать поддержку проверки подлинности и авторизации за пределами среде Active Directory  
  
## <a name="how-it-works-the-basics"></a>Принцип работы. Основные сведения  
Современная проверка подлинности AD FS можно добавить в приложение, используя тот же набор инструментов и библиотек, которые уже можно использовать для проверки подлинности пользователей в Azure AD.   
  
В сценарии AD FS само собой, это AD FS, а не Azure AD, который служит в качестве поставщика удостоверений и авторизации сервера.  В противном случае основные понятия, совпадают: пользователям вводить свои учетные данные и получать маркеры, напрямую или через посредника, для доступа к ресурсам.  
  
Самый простой сценарий состоит из пользователя или «владелец ресурса», взаимодействие с браузером для доступа к веб-приложения.  
  
![AD FS для разработчиков](media/ADFS_DEV_1.png)  
  
Веб-приложение называется «Клиент», так как он инициирует запрос на сервер авторизации (AD FS) для маркера доступа к ресурсу.  Ресурс может размещаться само веб-приложение или могут быть доступны, чем веб-API, где-нибудь в сети или Интернете.   Пользователь или «владелец ресурса» дает возможность веб-приложения клиента, чтобы получить этот токен доступа, указав учетные данные серверу авторизации.    
  
## <a name="how-it-works-components"></a>Как это работает: компоненты  
OAuth 2.0 и OpenID Connect сценарии в AD FS убедитесь использовать тот же набор инструментов и библиотек, использовании Azure AD — это поставщик удостоверений.  Ниже перечислены эти компоненты.  
* Библиотеки аутентификации Active Directory (ADAL): клиентские библиотеки, упрощают сбор учетных данных пользователя, создание и отправка запросов маркеров и извлечение полученных маркеров.    
* По промежуточного слоя OWIN (Open Web Interface for .NET): Несмотря на то проект сообщества на базе OWIN, корпорация Майкрософт создала набор библиотек на стороне сервера, для защиты веб-приложений и веб-API с помощью OpenID Connect и OAuth 2.0  
  
Роли эти компоненты, показаны на схеме ниже.  
  
![AD FS для разработчиков](media/ADFS_DEV_2.png)  
  
## <a name="modeling-these-scenarios-in-ad-fs-2016"></a>Моделирование таких сценариев в AD FS 2016  
  
### <a name="application-groups"></a>Группы пользователей приложений  
Для представления этих сценариев в политике AD FS, установленной введена новая концепция — группы приложений.  Группы приложений может содержать любое количество и сочетание следующие базовые типы приложения:  
  
  
  
Группы приложений / тип приложения  |Описание  |Роль    
---------|---------|---------  
Собственное приложение     |  Иногда называют общедоступным клиентом, это должен быть клиентское приложение, которое выполняется на компьютере или устройстве, и с которыми взаимодействует пользователь.       | Запросы маркеров из сервера авторизации (AD FS) для доступа пользователей к ресурсам.  Отправляет HTTP-запросы к защищенным ресурсам, с помощью маркеров в виде заголовков HTTP.        
Серверное приложение     |   Веб-приложения, которая выполняется на сервере и доступен пользователям через браузер.  Так как он способен поддерживать собственный секрет клиента или учетных данных, иногда он называется конфиденциального клиента.      | Запросы маркеров из сервера авторизации (AD FS) для доступа пользователей к ресурсам.  Отправляет HTTP-запросы к защищенным ресурсам, с помощью маркеров в виде заголовков HTTP.               
Веб-API     |  Обращается к ресурсов конечный пользователь. Следует воспринимать как новое представление «проверяющих сторон».| Применяет маркеры, полученных от клиентов  
  
### <a name="differences-from-ad-fs-2012-r2"></a>Отличия от AD FS 2012 R2  
Группы приложений объединить элементы управления безопасностью и авторизации, которые AD FS 2012 R2 в виде отдельно, проверяющие стороны, клиенты и разрешения приложения.  
  
В следующих таблицах сравниваются методов, по которым соответствующие объекты доверия приложения создаются в AD FS 2012 R2 AD FS 2016 vs:  
  
AD FS в Windows Server 2012 R2|В PowerShell|Управление AD FS  
---------|---------|---------  
Добавьте собственный клиент|Добавить AdfsClient|Н/Д  
Добавьте серверное приложение в качестве клиента|Добавить AdfsClient|Н/Д  
Добавление веб-API и ресурсов|Add-AdfsRelyingPartyTrust|Создание отношения доверия проверяющей стороны  
  
AD FS 2016|В PowerShell|Управление AD FS  
---------|---------|---------  
Добавьте собственный клиент|Добавить AdfsNativeClientApplication|Добавление собственного приложения группы  
Добавьте серверное приложение в качестве клиента|Добавить AdfsServerApplication|Добавление группы серверов в других приложениях  
Добавление веб-API и ресурсов|Добавить AdfsWebApiApplication|Добавить группу приложения Web API  
  
### <a name="application-permissions-and-consent"></a>Разрешения приложения и согласия  
По умолчанию клиенты в группу приложений могут получить доступ к ресурсам в той же группе.  Администратор имеет настройки разрешений для конкретного приложения.  Группы приложений также позволяют администратору указать области, может, например openid или user_impersonation.  В описаниях сценариев укажите ровно области, которые необходимы для какой сценарий.  
  
Так как AD FS использует модель согласия администратора, пользователи не получают запрос на согласие при доступе к ресурсам.  Настроив группы приложений, администратор фактически предоставляет согласие от лица всех пользователей приложения.  
  
## <a name="supported-scenarios"></a>Поддерживаемые сценарии  
Следующий раздел описывает сценарии, которые мы поддерживаем более подробно.  
  
### <a name="tokens-used"></a>Маркеры, используемые  
Сделать эти сценарии использовать три типа маркера:  
  
* **id_token:** Токен JWT, используемый для представления идентификатора пользователя. Утверждение «aud» или аудитория маркера "id_token", соответствует Идентификатору клиента машинный код или серверное приложение.  
* **access_token:** Маркер JWT, используемый в Oauth и OpenID connect, сценарии и предназначенный для использования ресурса.  Утверждение «aud» или аудитория маркера должен совпадать с идентификатором ресурса или веб-API.  
* **refresh_token:** Этот маркер отправляется вместо собирать пользовательские учетные данные для предоставления единого входа на работу.  Этот маркер выдан и потребляемых AD FS и недоступен для чтения по клиентам или ресурсов.    
  
### <a name="native-client-to-web-api"></a>Собственный клиент веб-API  
Этот сценарий позволяет пользователю из собственного клиентского приложения для вызова AD FS 2016 защищенные веб-API.  
* Собственное клиентское приложение использует ADAL для отправки авторизации и токен запросы к AD FS, запроса учетных данных от пользователя при необходимости, а затем отправляет полученный маркер в HTTP-заголовке запроса на веб-API  
* [Эта часть является только для демонстрационных целей] Веб-API считывает утверждения из объекта ClaimsPrincipal, полученный в результате маркер доступа, отправленные клиентом и отправляет их обратно клиенту.  
  
![Описание потока протокола](media/ADFS_DEV_3.png)  
  
1.  Собственное клиентское приложение запускает поток с помощью вызова с библиотекой ADAL.  При этом запускается браузер на основе HTTP GET к AD FS конечной точки авторизации:  
  
**Запрос авторизации:**  
ПОЛУЧИТЬ <https://fs.contoso.com/adfs/oauth2/authorize?>  
  
Параметр|Значение  
---------|---------  
response_type|«код»  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента собственного приложения в группе приложений  
redirect_uri|Redirect URI собственного приложения в группе приложений  
  
**Запрос-ответ авторизации:**  
Если пользователь не вошел в ранее, пользователю предлагается ввести учетные данные.    
AD FS отвечает путем возвращения кода авторизации «код» в качестве параметра компонента query URI перенаправления.  Пример: HTTP/1.1 302 найти расположение:  **<http://redirect_uri:80/?code=&lt;code&gt>;.**  
  
2. Собственный клиент отправит код, а также следующие параметры, в конечную точку маркера AD FS:  
  
**Запрос маркера:**  
ПОМЕСТИТЬ https://fs.contoso.com/adfs/oauth2/token  
  
Параметр|Значение  
---------|---------  
grant_type|«authorization_code» 
code|Код авторизации из 1  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента собственного приложения в группе приложений  
redirect_uri|Redirect URI собственного приложения в группе приложений  
  
**Ответ на запрос маркера:**  
AD FS в ответ HTTP 200 с маркер доступа и маркер обновления, а также маркера "id_token" в тексте.  
  
3. Затем нативное приложение отправляет части маркер доступа в ответе выше в качестве заголовка авторизации в запросе HTTP веб-API.  
  
### <a name="single-sign-on-behavior"></a>Поведение единого входа  
Последующих клиентских запросов в час (по умолчанию) по-прежнему будет допустимым access_token в кэше, и новый запрос не сможет запустить весь трафик к AD FS.  Маркер доступа автоматически извлекается из кэша по ADAL.  
  
После истечения срока действия маркера доступа, ADAL автоматически отправит запрос на основе маркера обновления в AD FS конечную точку маркера (автоматически, пропуская запрос на авторизацию).  
**Обновите запрос маркера:**  
ПОМЕСТИТЬ https://fs.contoso.com/adfs/oauth2/token
   

Параметр|Значение|
---------|---------
grant_type|"refresh_token"|
resource|Идентификатор RP (идентификатор) веб-API в группе приложений|
client_id|Идентификатор клиента собственного приложения в группе приложений
refresh_token|токен обновления, выданное AD FS в ответ на исходный запрос маркера

  
  
**Обновите ответ на запрос маркера:**  
Если токен обновления находится внутри < SSO_period >, запрос приведет к новый маркер доступа. Пользователю не предлагается ввести учетные данные.  Дополнительные сведения о см. параметры единого входа [AD FS параметры единого входа](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)  
  
Если маркер обновления истек, запрос приводит к отображению HTTP 401 ошибка «invalid_grant» и «error_description» «MSIS9615: Токен обновления, полученные в параметре маркер обновления истек». В этом случае ADAL автоматически отправляет новый запрос авторизации, который выглядит так же, как #1 выше.    
  
### <a name="web-browser-to-web-app"></a>Веб-браузера в веб-приложения   
В этом случае пользователя с помощью браузера требуется доступ к ресурсам, расположенным в веб-приложении.    
Существует два сценария, для выполнения этой задачи.  
  
#### <a name="oauth-confidential-client"></a>Конфиденциальный клиент OAuth  
Этот сценарий аналогичен выше в наличии запрос на авторизацию, Далее следует код для обмена маркерами.  Веб-приложению (смоделированному как серверного приложения в AD FS) инициирует запрос на авторизацию с помощью браузера и обменивается кодом для токена (путем непосредственного подключения к AD FS)  
  
![Описание потока протокола](media/ADFS_DEV_4.png)  
  
1. Инициирует веб-приложения, запрос авторизации с помощью браузера, который отправляет инструкцию HTTP GET к AD FS конечной точки авторизации  
   **Запрос на авторизацию**:  
   ПОЛУЧИТЬ <https://fs.contoso.com/adfs/oauth2/authorize?>  
  
Параметр|Значение  
---------|---------  
response_type|«код»  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|клиента с идентификатором собственного приложения в группе приложений  
redirect_uri|Redirect URI веб-приложения (приложение сервера) в группы приложений  
  
Запрос-ответ авторизации:  
Если пользователь не вошел в ранее, пользователю предлагается ввести учетные данные.  
AD FS отвечает путем возвращения кода авторизации «код» в качестве параметра компонента query URI перенаправления, например: HTTP/1.1 302 найти расположение: <https://webapp.contoso.com/?code=&lt;code&gt>;.  
  
2. В результате выше 302 браузер инициирует HTTP GET в веб-приложение, например: ПОЛУЧИТЬ <http://redirect_uri:80/?code=&lt;code&gt>;.   
  
3. На этом этапе веб-приложение, получение кода, инициирует запрос в AD FS конечную точку маркера, отправка ниже  
   **Запрос маркера:**  
   ПОМЕСТИТЬ https://fs.contoso.com/adfs/oauth2/token  
  
Параметр|Значение  
---------|---------  
grant_type|«authorization_code»  
code|Код авторизации из 2 выше  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента для веб-приложения (приложение сервера) в группе приложений  
redirect_uri|Redirect URI веб-приложения (приложение сервера) в группы приложений  
client_secret|Секрет веб-приложения (приложение сервера) в группе приложений. **Примечание. Учетные данные клиента не требуется быть client_secret.  AD FS поддерживает возможность использовать сертификаты или встроенную проверку подлинности Windows, а также.**  
  
**Ответ на запрос маркера:**  
AD FS в ответ HTTP 200 с маркер доступа и маркер обновления, а также маркера "id_token" в тексте.  
утверждения  
4. Веб-приложения, а затем либо использует маркер доступа частью выше ответа (в случае, в котором само веб-приложение, где размещен ресурс), и в противном случае отправляет как заголовок авторизации в запросе HTTP для веб-API.  
  
#### <a name="single-sign-on-behavior"></a>Поведение единого входа  
Хотя маркер доступа будет по-прежнему действительна в течение часа (по умолчанию) в кэше клиента, вы считаете, что второй запрос будет работать как в собственном клиенте сценарии выше - новый запрос не сможет запустить весь трафик к AD FS как маркер доступа будет автоматически выбрать из кэша с ADAL.  Тем не менее существует возможность, что веб-приложение может отправлять distinct авторизации и в запросе маркера, первое из них с помощью уникальных URL-адрес, как в нашем примере.  
  
В этом случае это файл cookie единого входа AD FS браузера, который позволяет выдавать новый код авторизации без запроса учетных данных пользователя AD FS. Веб-приложение, затем вызывается для AD FS для обмена новый код авторизации для нового маркера доступа.  Пользователю не предлагается ввести учетные данные.  
  
В противном случае если веб-приложение смарт-достаточно знать, если пользователь уже прошел проверку подлинности, можно пропустить запрос авторизации и либо:  
* кэшированного токена доступа, если не истек, получаются и используются, или   
* запрос маркера на основе запроса могут отправляться в AD FS конечную точку маркера, как описано ниже  
  
**Обновите запрос маркера:**  
ПОМЕСТИТЬ https://fs.contoso.com/adfs/oauth2/token
   
Параметр|Значение  
---------|---------  
grant_type|"refresh_token"  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента для веб-приложения (приложение сервера) в группе приложений  
refresh_token|Токен, выданный AD FS в ответ на исходный запрос токена обновления  
client_secret|Секрет веб-приложения (приложение сервера) в группе приложений  
  
**Обновите ответ на запрос маркера:**  
Если токен обновления находится внутри < SSO_period >, запрос приведет к новый маркер доступа. Пользователю не предлагается ввести учетные данные. Дополнительные сведения о см. параметры единого входа [AD FS параметры единого входа](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)   
  
Если маркер обновления истек, запрос приводит к отображению HTTP 401 ошибка «invalid_grant» и «error_description» «MSIS9615: Токен обновления, полученные в параметре маркер обновления истек». В этом случае ADAL автоматически отправляет новый запрос авторизации, который выглядит так же, как #1 выше.    
  
#### <a name="openid-connect-hybrid-flow"></a>OpenID Connect: Гибридный поток  
Этот сценарий аналогичен выше, существует инициируется запрос на авторизацию путем веб-приложения через перенаправление браузера и код для обмена маркерами из веб-приложения AD FS.  В этом сценарии разница, что AD FS выдает маркер "id_token" в качестве части ответа первоначальной авторизации запроса.  
  
![Описание потока протокола](media/ADFS_DEV_5.png)  
  
1.  Инициирует веб-приложения, запрос авторизации с помощью браузера, который отправляет инструкцию HTTP GET к AD FS конечной точки авторизации  
  
**Запрос авторизации:**  
ПОЛУЧИТЬ <https://fs.contoso.com/adfs/oauth2/authorize?>  
  
Параметр|Значение  
---------|---------  
response_type|«код + "id_token"»  
response_mode|«form_post»  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента для веб-приложения (приложение сервера) в группе приложений  
redirect_uri|URI веб-приложения (приложение сервера) в группе приложений перенаправления  
  
**Запрос-ответ авторизации:**  
Если пользователь не вошел в ранее, пользователю предлагается ввести учетные данные.  
AD FS в ответ HTTP 200 и форму, содержащую ниже как скрытые элементы:  
* кода: код авторизации  
* "id_token": маркер JWT, содержащий заявки, описывающие проверки подлинности пользователя  
* URI перенаправления веб-приложения, отправка в коде и "id_token" в веб-приложение автоматически учитывает формы.  
  
3. На этом этапе веб-приложение, получение кода, инициирует запрос в AD FS конечную точку маркера, отправка ниже  
  
**Запрос маркера:**  
ПОМЕСТИТЬ https://fs.contoso.com/adfs/oauth2/token
  
  
  
Параметр|Значение  
---------|---------  
grant_type|«authorization_code»  
code|Код авторизации из выше  
resource|Идентификатор RP (идентификатор) веб-API в группе приложений  
client_id|Идентификатор клиента для веб-приложения (приложение сервера) в группе приложений  
redirect_uri|Redirect URI веб-приложения (приложение сервера) в группы приложений  
client_secret|Секрет веб-приложения (приложение сервера) в группе приложений  
  
**Ответ на запрос маркера:**  
AD FS в ответ HTTP 200 с маркер доступа и маркер обновления, а также маркера "id_token" в тексте.  
  
4. Веб-приложения, а затем либо использует маркер доступа частью выше ответа (в случае, в котором само веб-приложение, где размещен ресурс), и в противном случае отправляет как заголовок авторизации в запросе HTTP для веб-API.  
  
#### <a name="single-sign-on-behavior"></a>Поведение единого входа  
Единый вход на поведение такое же, как описанный выше процесс конфиденциального клиента Oauth 2.0.  
  
### <a name="on-behalf-of"></a>От имени  
В этом случае веб-приложение использует исходный маркер доступа пользователя для запроса и получения другого маркера доступа для другого веб-API, который затем будет получить веб-приложения в виде конечного пользователя.  Это называется поток «от».  
  
![Описание потока протокола](media/ADFS_DEV_6.png)  
  
Шаги 1 и 2 работает так же, как шаги 3 и 4 в предыдущем потоке.  
На шаге 3 основным требованием является, что параметр "client_id", идентификатор клиента, 2, веб-приложения должно соответствовать RP идентификатор из веб-API, а.  Другими словами аудитория маркера доступа выполняется обмен для нового токена должен соответствовать Идентификатору клиента сущности, запрашивающей новый маркер.  

## <a name="related-content"></a>Связанное содержимое  
См. в разделе [разработки AD FS](../AD-FS-Development.md) полный список руководств, которые предоставляют пошаговые инструкции об использовании связанных потоках. 

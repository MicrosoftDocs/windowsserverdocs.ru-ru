---
ms.assetid: 8a64545b-16bd-4c13-a664-cdf4c6ff6ea0
title: Потоки OpenID Connect или OAuth в AD FS и сценарии использования приложений
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server
ms.technology: identity-adfs
ms.openlocfilehash: d65701010620127c4d98bdc176be1e7ce401e0a7
ms.sourcegitcommit: d5e27c1f2f168a71ae272bebf8f50e1b3ccbcca3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2020
ms.locfileid: "86965996"
---
# <a name="ad-fs-openid-connectoauth-flows-and-application-scenarios"></a>Потоки OpenID Connect или OAuth в AD FS и сценарии использования приложений
Применимо к AD FS 2016 и более поздних версий


|Сценарий|Пошаговое руководство по использованию сценария с примерами|Поток и предоставление OAuth 2.0|Тип клиента|
|-----|-----|-----|-----|
|Одностраничное приложение</br> | &bull; [Пример на основе ADAL](../development/Single-Page-Application-with-AD-FS.md)|[Неявно](#implicit-grant-flow)|Общие| 
|Веб-приложение, которое обрабатывает вход пользователей в систему</br> | &bull; [Пример на основе OWIN](../development/enabling-openid-connect-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Общедоступный, конфиденциальный|  
|Вызов веб-API в нативном приложении</br>|&bull; [Пример на основе MSAL](../development/msal/adfs-msal-native-app-web-api.md)</br>&bull; [Пример на основе ADAL](../development/native-client-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Общие|   
|Вызов веб-API в веб-приложении</br>|&bull; [Пример на основе MSAL](../development/msal/adfs-msal-web-app-web-api.md)</br>&bull; [Пример на основе ADAL](../development/enabling-oauth-confidential-clients-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Конфиденциальный| 
|Вызов веб-API в другом веб-API от имени пользователя</br>|&bull; [Пример на основе MSAL](../development/msal/adfs-msal-web-api-web-api.md)</br>&bull; [Пример на основе ADAL](../development/ad-fs-on-behalf-of-authentication-in-windows-server.md)|[Вызов от имени](#on-behalf-of-flow)|Веб-приложение в режиме "конфиденциально"| 
|Вызов веб-API в управляющей программе||[Учетные данные клиента](#client-credentials-grant-flow)|Конфиденциальный| 
|Вызов веб-API в веб-приложении с учетными данными пользователя||[Учетные данные владельца ресурса с паролем](#resource-owner-password-credentials-grant-flow-not-recommended)|Общедоступный, конфиденциальный| 
|Вызов веб-API в приложении без использования браузера||[Код устройства](#device-code-flow)|Общедоступный, конфиденциальный| 

## <a name="implicit-grant-flow"></a>Поток неявного предоставления 
 
Для одностраничных приложений (AngularJS, Ember.js, React.js и т. п.), AD FS поддерживает поток неявного предоставления OAuth 2.0. Этот поток неявного представления описан в  [спецификации OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-4.2). Основное его преимущество заключается в том, что приложения могут получать маркеры от AD FS без обмена учетными данными с внутренним сервером. Это позволяет приложениям выполнять вход пользователя, поддерживать сеансы и получать маркеры для доступа к другим веб-API прямо из кода JavaScript в клиенте. При использовании неявного потока необходимо учитывать ряд важных вопросов безопасности, особенно в отношении  [клиента](https://tools.ietf.org/html/rfc6749#section-10.3).  
 
Если вы хотите добавить в приложение JavaScript проверку подлинности на основе неявного потока и AD FS, выполните представленные ниже общие шаги.  
  
### <a name="protocol-diagram"></a>Схема протокола

На следующей схеме представлен весь неявный поток входа, а каждый его шаг подробно описан в следующих разделах.  

![Неявный вход](media/adfs-scenarios-for-developers/implicit.png)

### <a name="request-id-token-and-access-token"></a>Маркер идентификатора запроса и маркер доступа 
 
Чтобы выполнить первый вход пользователя в приложение, можно отправить запрос на проверку подлинности в OpenID Connect и получить маркеры идентификатора и доступа из конечной точки AD FS.  
 
```
// Line breaks for legibility only 
 
https://adfs.contoso.com/adfs/oauth2/authorize? 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&response_type=id_token+token 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&scope=openid 
&response_mode=fragment 
&state=12345 
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.| 
|response_type|обязательные|Должен содержать `id_token` для входа через OpenID Connect. Он также может включать response_type `token`. Использование маркера в этой ситуации позволяет приложению немедленно получить маркер доступа от конечной точки авторизации, не выполняя второй запрос к конечной точке маркера.| 
|redirect_uri|обязательные|URI перенаправления для приложения, по которому оно может отправлять и получать ответы на запросы проверки подлинности. Он должен точно соответствовать одному из URI перенаправления, настроенных в AD FS.| 
|nonce|обязательные|Значение, включаемое в создаваемый приложением запрос, которое будет использоваться как утверждение в получаемом значении id_token. Приложение может проверять это значение, чтобы устранить атаки с воспроизведением маркеров. Значение обычно представляет собой случайным образом полученную уникальную строку, которую можно использовать для идентификации источника запроса. Требуется только при запросе id_token.|
|scope|необязательно|Список областей с разделителями-пробелами. Для входа через OpenID Connect этот параметр должен содержать область `openid`.|
|resource|необязательно|URL-адрес веб-API.</br>Обратите внимание, что при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого отправляется URL-адрес ресурса в составе параметра scope: `scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается ни в этом параметре, ни в scope, ADFS будет использовать ресурс по умолчанию — urn:microsoft:userinfo. Политики ресурсов userinfo, например MFA, выдачи сертификатов или авторизации, нельзя настроить.| 
|response_mode|необязательно| Определяет метод, который следует использовать для отправки созданного маркера запрашивающему приложению. По умолчанию имеет значение `fragment`.| 
|state|необязательно|Значение, включаемое в запрос, которое также будет возвращено в ответе с маркером. Это может быть строка с любым содержимым на ваше усмотрение. Для предотвращения атак с подделкой межсайтовых запросов обычно используется случайно созданное уникальное значение. Состояние также используется для кодирования сведений о состоянии пользователя в приложении перед выполнением запроса проверки подлинности, например о просматриваемой странице или представлении.| 
|prompt|необязательно|Указывает требуемый тип взаимодействия с пользователем. В настоящее время допускаются только значения login и none.</br>- `prompt=login` требует от пользователя ввести учетные данные по этому запросу, то есть запрещает использовать единый вход. </br>- `prompt=none` означает обратное, то есть запрещает предлагать пользователю любые интерактивные запросы. Если этот запрос не может быть выполнен автоматически через механизмы единого входа, AD FS выдаст ошибку interaction_required.| 
|login_hint|необязательно|Может использоваться для предварительного заполнения полей имени пользователя или адреса электронной почты на отображаемой пользователю странице входа, если имя пользователя уже известно. Часто этот параметр применяется в приложениях при повторной проверке подлинности, когда имя пользователя из предыдущего входа уже получено через утверждение `upn` от `id_token`.| 
|domain_hint|необязательно|Этот параметр позволяет пропустить процесс обнаружения на основе домена, который пользователь проходит на странице входа, что немного упрощает взаимодействие с пользователем.| 

В этом сценарии пользователю будет предложено ввести учетные данные и выполнить проверку подлинности. Когда завершится проверка подлинности для пользователя, конечная точка авторизации AD FS вернет приложению ответ по указанному URI перенаправления (redirect_uri), используя метод из параметра response_mode.  
 
### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ при использовании `response_mode=fragment and response_type=id_token+token` выглядит примерно так:  
 
```
// Line breaks for legibility only 
 
GET https://localhost/myapp/# 
access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZEstZnl0aEV... 
&token_type=Bearer 
&expires_in=3599 
&scope=openid  
&id_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZstZnl0aEV1Q... 
&state=12345 
```


|Параметр|Описание| 
|-----|-----|
|access_token|Добавляется, если в response_type содержится `token`.|
|token_type|Добавляется, если в response_type содержится `token`. Всегда имеет значение Bearer (носитель).| 
|expires_in| Добавляется, если в response_type содержится `token`. Обозначает количество секунд, в течение которых маркер является допустимым. Используется для кэширования.| 
|scope| Позволяет указать одну или несколько областей, для которых access_token будет допустимым.|  
|id_token|Добавляется, если в response_type содержится `id_token`. Подписанный JSON Web Token (JWT) Приложение может расшифровать сегменты этого маркера, чтобы запросить сведения о выполнившем вход пользователе. Эти значения можно кэшировать и (или) отображать в приложении, но их не следует использовать в любых процессах авторизации или обеспечения безопасности.| 
|state|Если в запрос включен этот параметр состояния, идентичное значение должно содержаться и в ответе на этот запрос. Приложение должно проверять идентичность значений состояния в запросе и ответе.|

### <a name="refresh-tokens"></a>Маркеры обновления 
Неявное предоставление не использует маркеры обновления. Срок действия `id_tokens` и `access_tokens` истекает достаточно быстро, поэтому приложение должно быть готово регулярно обновлять эти маркеры. Чтобы обновить маркер любого типа, можно выполнить такой же запрос из скрытого IFRAME, как показано выше, используя параметр `prompt=none` для управления поведением платформы удостоверений. Если вы хотите получить `new id_token`, обязательно используйте `response_type=id_token`. 

## <a name="authorization-code-grant-flow"></a>Поток предоставления кода авторизации 
 
Предоставление кода авторизации в OAuth 2.0 можно использовать в веб-приложениях для получения доступа к защищенным ресурсам, таким как веб-API. Поток кода авторизации OAuth 2.0 описан в  [разделе 4.1 спецификации по OAuth 2.0](https://tools.ietf.org/html/rfc6749). Он используется для проверки подлинности и авторизации в большинстве типов приложений, в том числе в веб-приложениях и нативных устанавливаемых приложениях. Этот поток позволяет приложениям безопасно получать access_token, чтобы использовать его для доступа к ресурсам с доверием в отношении AD FS.  
 
### <a name="protocol-diagram"></a>Схема протокола 
 
На обобщенном уровне поток проверки подлинности для нативного приложения выглядит примерно так:

![Поток предоставления кода авторизации](media/adfs-scenarios-for-developers/authorization.png)

### <a name="request-an-authorization-code"></a>Запрос кода авторизации 
 
Поток кода авторизации начинается с того, что клиент направляет пользователя в конечную точку /authorize. В этом запросе клиент указывает разрешения, которые нужно получить от пользователя. 
 
```
// Line breaks for legibility only 
 
https://adfs.contoso.com/adfs/oauth2/authorize? 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&response_type=code 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&response_mode=query 
&resource=https://webapi.com/ 
&scope=openid 
&state=12345 
```

|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.|  
|response_type|обязательные| Должен содержать код для потока запроса авторизации.| 
|redirect_uri|обязательные|`redirect_uri` для приложения, по которому оно может отправлять и получать ответы на запросы проверки подлинности. Он должен точно соответствовать одному из URI перенаправления, зарегистрированных для соответствующего клиента в AD FS.|  
|resource|необязательно|URL-адрес веб-API.</br>Обратите внимание, что при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого отправляется URL-адрес ресурса в составе параметра scope: `scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается ни в этом параметре, ни в scope, ADFS будет использовать ресурс по умолчанию — urn:microsoft:userinfo. Политики ресурсов userinfo, например MFA, выдачи сертификатов или авторизации, нельзя настроить.| 
|scope|необязательно|Список областей с разделителями-пробелами.|
|response_mode|необязательно|Определяет метод, который следует использовать для отправки созданного маркера запрашивающему приложению. Может принимать следующие значения: </br>– query; </br>– fragment; </br>– form_post.</br>`query` предоставляет код в виде параметра строки запроса, включенного в URI перенаправления. Если вы запрашиваете этот код, можно использовать значения query, fragment или form_post. `form_post` выполняет запрос POST, который содержит этот код, к URI перенаправления.|
|state|необязательно|Значение, включаемое в запрос, которое также будет возвращено в ответе с маркером. Это может быть строка с любым содержимым на ваше усмотрение. Для предотвращения атак с подделкой межсайтовых запросов обычно используется случайно созданное уникальное значение. Это значение также используется для кодирования сведений о состоянии пользователя в приложении перед выполнением запроса проверки подлинности, например о просматриваемой странице или представлении.|
|prompt|необязательно|Указывает требуемый тип взаимодействия с пользователем. В настоящее время допускаются только значения login и none.</br>- `prompt=login` требует от пользователя ввести учетные данные по этому запросу, то есть запрещает использовать единый вход. </br>- `prompt=none` означает обратное, то есть запрещает предлагать пользователю любые интерактивные запросы. Если этот запрос не может быть выполнен автоматически через механизмы единого входа, AD FS выдаст ошибку interaction_required.|
|login_hint|необязательно|Может использоваться для предварительного заполнения полей имени пользователя или адреса электронной почты на отображаемой пользователю странице входа, если имя пользователя уже известно. Часто этот параметр применяется в приложениях при повторной проверке подлинности, когда имя пользователя из предыдущего входа уже получено через утверждение `upn`от `id_token`.|
|domain_hint|необязательно|Этот параметр позволяет пропустить процесс обнаружения на основе домена, который пользователь проходит на странице входа, что немного упрощает взаимодействие с пользователем.|
|code_challenge_method|необязательно|Метод, используемый для кодирования code_verifier в параметре code_challenge. Может иметь одно из следующих значений: </br>– plain; </br>– S256. </br>Если этот параметр не указан, для code_challenge подразумевается формат обычного текста, если включено `code_challenge` . AD FS поддерживает форматы обычного текста и S256. Дополнительные сведения см. в документе  [PKCE RFC](https://tools.ietf.org/html/rfc7636).|
|code_challenge|необязательно| Используется для защиты предоставлений кода авторизации через PKCE (ключ подтверждения для обмена кодами) из нативного клиента. Требуется, если включен `code_challenge_method` . Дополнительные сведения см. в документе  [PKCE RFC](https://tools.ietf.org/html/rfc7636).|

В этом сценарии пользователю будет предложено ввести учетные данные и выполнить проверку подлинности. Когда завершится проверка подлинности для пользователя, AD FS вернет приложению ответ по указанному `redirect_uri`, используя метод из параметра `response_mode` .  
 
### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ при использовании response_mode=query выглядит примерно так: 
 
```
GET https://adfs.contoso.com/common/oauth2/nativeclient? 
code=AwABAAAAvPM1KaPlrEqdFSBzjqfTGBCmLdgfSTLEMPGYuNHSUYBrq... 
&state=12345  
```


|Параметр|Описание|
|-----|-----|
|code|Значение `authorization_code`, запрошенное приложением. Приложение может использовать этот код авторизации для запроса маркера доступа к целевому ресурсу. Authorization_codes имеет короткий срок действия, обычно около десяти минут.|
|state|Если в запрос включен параметр `state`, идентичное значение должно содержаться и в ответе на этот запрос. Приложение должно проверять идентичность значений состояния в запросе и ответе.|

### <a name="request-an-access-token"></a>Запрос маркера доступа 
 
Теперь, когда вы получили `authorization_code` и запросили разрешение у пользователя, вы можете использовать этот код для получения `access_token` к требуемому ресурсу. Для этого отправьте запрос POST к конечной точке /token, как показано ниже.  
 
```
// Line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com/ 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&code=OAAABAAAAiL9Kn2Z27UubvWFPbm0gLWQJVzCTE9UkP3pSx1aXxUjq3n8b2JRLk4OxVXr... 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&grant_type=authorization_code 
&client_secret=JqQX2PNo9bpM0uEihUPzyrh    // NOTE: Only required for confidential clients (web apps)  
```

|Параметр|Обязательный или необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.| 
|grant_type|обязательные|Должен содержать `authorization_code` для потока кода авторизации.| 
|code|обязательные|Значение `authorization_code`, полученное в первой части потока.| 
|redirect_uri|обязательные|То же значение `redirect_uri`, которое использовалось для получения `authorization_code`.| 
|client_secret|Требуется для веб-приложений.|Секрет приложения, который вы создали во время регистрации приложения в AD FS. Не следует использовать секрет приложения в нативном приложении, так как на устройствах нет возможности надежно хранить client_secrets. Он требуется для веб-приложений и веб-API, которые могут безопасно хранить client_secret на стороне сервера. Секрет клиента должен быть закодирован в формат URL-адреса перед отправкой. Эти приложения также могут использовать проверку подлинности на основе ключей, подписывая JWT и добавляя его в виде параметра client_assertion.| 
|code_verifier|необязательно|Тот же `code_verifier`, который использовался для получения authorization_code. Требуется, если в запросе на предоставление кода авторизации использовался ключ PKCE. Дополнительные сведения см. в документе  [PKCE RFC](https://tools.ietf.org/html/rfc7636).</br>Примечание. Это применимо к AD FS 2019 и более поздних версий.| 

### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ на запрос маркера будет выглядеть следующим образом: 
 
```
{ 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...", 
    "token_type": "Bearer", 
    "expires_in": 3599, 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDRkMTFhMi1mODE0LTQ2YTctOD...", 
} 
```


|Параметр|Описание| 
|-----|-----|
|access_token|Запрошенный маркер доступа. Приложение может использовать этот маркер для проверки подлинности при обращении к защищенному ресурсу (веб-API).| 
|token_type|Обозначает значение типа маркера. В AD FS поддерживается только один тип — Bearer (носитель).
|expires_in|Срок действия маркера доступа (в секундах).
|refresh_token|Маркер обновления OAuth 2.0. Приложение может с помощью этого маркера получить дополнительные маркеры доступа после истечения срока действия текущего маркера доступа. Refresh_token имеет длительный срок действия и может использоваться для сохранения доступа к ресурсам в течение продолжительного периода времени.| 
|refresh_token_expires_in|Срок действия маркера обновления (в секундах).| 
|id_token|JSON Web Token (JWT). Приложение может расшифровать сегменты этого маркера, чтобы запросить сведения о выполнившем вход пользователе. Эти значения можно кэшировать и (или) отображать в приложении, но их не следует использовать в любых процессах авторизации или организации безопасности.|

### <a name="use-the-access-token"></a>Использование маркера доступа 
 
```
GET /v1.0/me/messages 
Host: https://webapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q... 
 ```

### <a name="refresh-token-grant-flow"></a>Поток предоставления токена обновления
 
Access_token имеет короткий срок действия, и после истечения этого срока маркер нужно обновить, чтобы сохранить доступ к ресурсам. Это можно сделать, отправив новый запрос POST на конечную точку `/token` , теперь указав refresh_token вместо кода. Маркеры обновления действуют для всех разрешений, для которых клиент уже получил маркер доступа. 
 
Маркеры обновления не имеют определенного времени существования. Обычно этот период является относительно долгим. Но может случиться так, что у маркера обновления истекает срок действия, он отзывается или не имеет достаточных привилегий для требуемого действия. В приложении нужно предусмотреть решение для таких ситуаций и правильную обработку ошибок, возвращаемых конечной точкой выдачи маркеров.  
 
Хотя маркеры обновления не отзываются при использовании для получения новых маркеров доступа, обычно предполагается, что старый маркер обновления после этого удаляется. В спецификации OAuth 2.0 указано следующее: "Сервер авторизации МОЖЕТ выдать новый маркер обновления, и в этом случае клиент ДОЛЖЕН удалить старый маркер обновления и заменить его новым маркером обновления. Сервер авторизации МОЖЕТ отозвать старый маркер обновления после выдачи нового маркера обновления для клиента." AD FS выдает токен обновления, когда время существования нового маркера обновления превышает время существования предыдущего.  См. сведения о времени существования маркера обновления AD FS в статье [Параметры единого входа AD FS](../operations/ad-fs-single-sign-on-settings.md).
 
```
// Line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&refresh_token=OAAABAAAAiL9Kn2Z27UubvWFPbm0gLWQJVzCTE9UkP3pSx1aXxUjq... 
&grant_type=refresh_token 
&client_secret=JqQX2PNo9bpM0uEihUPzyrh      // NOTE: Only required for confidential clients (web apps)  
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.| 
|grant_type|обязательные|Должен содержать `refresh_token` для этой части потока кода авторизации.| 
|resource|необязательно|URL-адрес веб-API.</br>Обратите внимание, что при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого отправляется URL-адрес ресурса в составе параметра scope: `scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается ни в этом параметре, ни в scope, ADFS будет использовать ресурс по умолчанию — urn:microsoft:userinfo. Политики ресурсов userinfo, например MFA, выдачи сертификатов или авторизации, нельзя настроить.|
|scope|необязательно|Список областей с разделителями-пробелами.| 
|refresh_token|обязательные|Содержит маркер обновления, полученный во второй части потока.| 
|client_secret|Требуется для веб-приложений.| Секрет приложения, который вы создали на портале регистрации приложения. Не следует использовать его в нативном приложении, так как на устройствах нет возможности надежно хранить client_secrets. Он требуется для веб-приложений и веб-API, которые могут безопасно хранить client_secret на стороне сервера. Эти приложения также могут использовать проверку подлинности на основе ключей, подписывая JWT и добавляя его в виде параметра client_assertion.|

### <a name="successful-response"></a>Успешный ответ 
Успешный ответ на запрос маркера будет выглядеть следующим образом: 
 
```
{ 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...", 
    "token_type": "Bearer", 
    "expires_in": 3599, 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDRkMTFhMi1mODE0LTQ2YTctOD...", 
}  
```
|Параметр|Описание| 
|-----|-----|
|access_token|Запрошенный маркер доступа. Приложение может использовать этот маркер для проверки подлинности защищаемого источника, например веб-API.| 
|token_type|Обозначает значение типа маркера. В AD FS поддерживается только один тип — Bearer (носитель).|
|expires_in|Срок действия маркера доступа (в секундах).|
|scope|Области, для которых действует access_token.| 
|refresh_token|Маркер обновления OAuth 2.0. Приложение может с помощью этого маркера получить дополнительные маркеры доступа после истечения срока действия текущего маркера доступа. Refresh_token имеет длительный срок действия и может использоваться для сохранения доступа к ресурсам в течение продолжительного периода времени.| 
|refresh_token_expires_in|Срок действия маркера обновления (в секундах).| 
|id_token|JSON Web Token (JWT). Приложение может расшифровать сегменты этого маркера, чтобы запросить сведения о выполнившем вход пользователе. Эти значения можно кэшировать и (или) отображать в приложении, но их не следует использовать в любых процессах авторизации или организации безопасности.|

## <a name="on-behalf-of-flow"></a>Поток On-Behalf-Of 
 
поток On-Behalf-Of в OAuth 2.0 предназначен для случаев, когда приложение вызывает службу или веб-API, которые, в свою очередь, должны обращаться к другой службе или веб-API. Идея состоит в том, чтобы передать по цепочке запросов делегированное удостоверение пользователя и соответствующие разрешения. Чтобы служба среднего уровня выполняла запросы к подчиненной службе с проверкой подлинности, ей необходимо обеспечить защиту маркеру доступа в AD FS от имени пользователя.  
 
### <a name="protocol-diagram"></a>Схема протокола 
Предположим, что пользователь прошел проверку подлинности в приложении, используя описанный выше поток предоставления кода авторизации OAuth 2.0. На этом этапе приложение имеет маркер доступа для API А (маркер А) с утверждениями пользователя и согласием на доступ к веб-API среднего уровня (API А). Убедитесь, что клиент запрашивает в маркере область user_impersonation. Теперь API A должен выполнить запрос с проверкой подлинности к следующему веб-API в цепочке (API Б). 

Ниже перечислены действия в потоке вызова от имени, и они же иллюстрируются на следующей схеме. 

![Поток On-Behalf-Of](media/adfs-scenarios-for-developers/obo.png)

  1. Клиентское приложение выполняет запрос к API А с маркером А.  
  Примечание. Настраивая в AD FS поток On-Behalf-Of, убедитесь, что выбрана область `user_impersonation` и в запросе от клиента указана именно область `user_impersonation`. 
  2. API А выполняет проверку подлинности через конечную точку выдачи маркера AD FS и запрашивает маркер для доступа к API А. Примечание. При настройке такого потока в AD FS зарегистрируйте API А в качестве серверного приложения с тем же значением clientID, что и идентификатор ресурса в API А.
  3. Конечная точка выдачи маркера AD FS проверяет учетные данные API А с использованием маркера А и выдает маркер доступа для API Б (маркер Б). 
  4. Маркер Б передается в заголовке проверки подлинности при запросе к API Б. 
  5. API Б возвращает данные из защищенного ресурса. 

### <a name="service-to-service-access-token-request"></a>Запрос маркера доступа для взаимодействия между службами 
 
Чтобы запросить маркер доступа, выполните HTTP-запрос POST к конечной точке маркеров AD FS со следующими параметрами.  


### <a name="first-case-access-token-request-with-a-shared-secret"></a>Первый пример. Запрос маркера доступа по общему секрету 
 
Если используется общий секрет, запрос маркера доступа для взаимодействия между службами содержит следующие параметры. 


|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Тип запроса маркера. Для запроса с использованием JWT должно быть указано значение urn:ietf:params:oauth:grant-type:jwt-bearer.|  
|client_id|обязательные|Идентификатор клиента, который вы настроили при регистрации первого веб-API для серверного приложения (приложение среднего уровня). Он должен совпадать с идентификатором ресурса, который использовался на первом этапе, то есть URL-адресом первого веб-API.| 
|client_secret|обязательные|Секрет приложения, который вы создали во время регистрации серверного приложения в AD FS.| 
|assertion|обязательные|Значение маркера, которое используется в запросе.|  
|requested_token_use|обязательные|Позволяет указать, как должен обрабатываться запрос. В потоке On-Behalf-Of должно быть указано значение on_behalf_of.| 
|resource|обязательные|Идентификатор ресурса, предоставленный при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Идентификатор ресурса должен быть URL-адресом второго приложения веб-API среднего уровня, которое нужно вызывать от имени клиента.|
|scope|необязательно|Список областей для запроса маркера с разделителями-пробелами.| 

#### <a name="example"></a>Пример 
 
В приведенном ниже примере `HTTP POST` запрашивается маркер доступа и маркер обновления. 
 
```
//line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: adfs.contoso.com  
Content-Type: application/x-www-form-urlencoded 
 
grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer 
&client_id=https://webapi.com/ 
&client_secret=BYyVnAt56JpLwUcyo47XODd 
&assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIm… 
&resource=https://secondwebapi.com/
&requested_token_use=on_behalf_of
&scope=openid    
```

### <a name="second-case-access-token-request-with-a-certificate"></a>Второй пример. Запрос маркера доступа по сертификату 
 
Запрос маркера доступа по сертификату для взаимодействия между службами содержит следующие параметры. 


|Параметр|Обязательный или необязательный|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Тип запроса маркера. Для запроса с использованием JWT должно быть указано значение urn:ietf:params:oauth:grant-type:jwt-bearer. |
|client_id|обязательные|Идентификатор клиента, который вы настроили при регистрации первого веб-API для серверного приложения (приложение среднего уровня). Он должен совпадать с идентификатором ресурса, который использовался на первом этапе, то есть URL-адресом первого веб-API.|  
|client_assertion_type|обязательные|Должно быть указано значение urn:ietf:params:oauth:client-assertion-type:jwt-bearer.| 
|client_assertion|обязательные|Утверждение (JSON Web Token), которое необходимо создать и подписать с помощью сертификата, зарегистрированного вами в качестве учетных данных для приложения.|  
|assertion|обязательные|Значение маркера, которое используется в запросе.| 
|requested_token_use|обязательные|Позволяет указать, как должен обрабатываться запрос. В потоке On-Behalf-Of должно быть указано значение on_behalf_of.| 
|resource|обязательные|Идентификатор ресурса, предоставленный при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Идентификатор ресурса должен быть URL-адресом второго приложения веб-API среднего уровня, которое нужно вызывать от имени клиента.|
|scope|необязательно|Список областей для запроса маркера с разделителями-пробелами.|


Обратите внимание, что здесь используются такие параметры, как и в примере с запросом по общему секрету. Отличается только параметр client_secret, который заменен двумя параметрами: client_assertion_type и client_assertion. 

#### <a name="example"></a>Пример 
В следующем примере HTTP-запроса POST запрашивается маркер доступа для веб-API с использованием сертификата.

``` 
// line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer 
&client_id= https://webapi.com/ 
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer 
&client_assertion=eyJhbGciOiJSUzI1NiIsIng1dCI6Imd4OHRHeXN5amNS… 
&resource=https://secondwebapi.com/
&requested_token_use=on_behalf_of
&scope= openid 
```    

### <a name="service-to-service-access-token-response"></a>Ответ на запрос маркера доступа для взаимодействия между службами 
 
Ответ об успешном выполнении представляет собой ответ OAuth 2.0 в формате JSON со следующими параметрами. 


|Параметр|Описание|
|-----|-----| 
|token_type|Обозначает значение типа маркера. В AD FS поддерживается только один тип — Bearer (носитель). | 
|scope|Область доступа, предоставленная в маркере.| 
|expires_in|Срок действия маркера доступа (в секундах).| 
|access_token|Запрошенный маркер доступа. Вызывающая служба может использовать этот маркер для проверки подлинности в вызываемой службе.| 
|id_token|JSON Web Token (JWT). Приложение может расшифровать сегменты этого маркера, чтобы запросить сведения о выполнившем вход пользователе. Эти значения можно кэшировать и (или) отображать в приложении, но их не следует использовать в любых процессах авторизации или организации безопасности.| 
|refresh_token|Маркер обновления для запрошенного маркера доступа. Вызывающая служба может с помощью этого маркера запросить другой маркер доступа после истечения срока действия текущего маркера доступа.|
|Refresh_token_expires_in|Срок действия маркера обновления (в секундах). 

### <a name="success-response-example"></a>Пример ответа об успешном выполнении 
 
Ниже представлен пример с ответом об успешном выполнении запроса маркера доступа к веб-API. 

``` 
{ 
  "token_type": "Bearer", 
  "scope": openid, 
  "expires_in": 3269, 
  "access_token": "eyJ0eXAiOiJKV1QiLCJub25jZSI6IkFRQUJBQUFBQUFCbmZpRy1t" 
  "id_token": "aWRfdG9rZW49ZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKU1V6STFOa" 
  "refresh_token": "OAQABAAAAAABnfiG…" 
  "refresh_token_expires_in": 28800, 
} 
```  
 
 
Этот маркер доступа используется для доступа к защищенному ресурсу. Теперь служба среднего уровня может использовать полученный ранее маркер для создания запросов с проверкой подлинности к нижестоящему веб-API, указывая этот маркер в заголовке Authorization.  

#### <a name="example"></a>Пример 
``` 
GET /v1.0/me HTTP/1.1 
Host: https://secondwebapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJub25jZSI6IkFRQUJBQUFBQUFCbmZpRy1tQ… 
``` 

## <a name="client-credentials-grant-flow"></a>Поток предоставления учетных данных клиента 
 
Вы можете использовать учетные данные клиента OAuth 2.0, описанные в [RFC 6749](https://tools.ietf.org/html/rfc6749#section-4.4), для доступа к размещенным в Интернете ресурсам с применением удостоверения приложения. Этот тип предоставления обычно используется для взаимодействий между серверами, которые должны выполняться в фоновом режиме без активного взаимодействия с пользователем. Эти типы приложений часто называют управляющими программами или учетными записями служб. 

Поток предоставления учетных данных клиента OAuth 2.0 позволяет веб-службе (конфиденциальному клиенту) при вызове другой веб-службы проходить проверку подлинности с собственными учетными данными, а не олицетворять пользователя. В этом сценарии клиентом обычно является веб-служба среднего уровня, служба управляющей программы или веб-сайт. Для повышения надежности AD FS позволяет вызывающей службе использовать сертификат (вместо общего секрета) в качестве учетных данных. 

### <a name="protocol-diagram"></a>Схема протокола 

На следующей схеме показан поток предоставления учетных данных клиента. 

![Учетные данные клиента](media/adfs-scenarios-for-developers/credentials.png)

### <a name="request-a-token"></a>Запрос маркера 
 
Чтобы получить маркер через предоставление учетных данных клиента, отправьте запрос `POST` к конечной точке AD FS /token:  
 
### <a name="first-case-access-token-request-with-a-shared-secret"></a>Первый пример. Запрос маркера доступа по общему секрету 
 
```
POST /adfs/oauth2/token HTTP/1.1            
//Line breaks for clarity 
 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
client_id=535fb089-9ff3-47b6-9bfb-4f1264799865 
&client_secret=qWgdYAmab0YSkuL1qKv5bPX 
&grant_type=client_credentials 
```

|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.| 
|scope|необязательно|Разделенный пробелами список областей, на которые пользователь должен предоставить согласие.| 
|client_secret|обязательные|Секрет клиента, который вы создали для приложения на портале регистрации приложений. Секрет клиента должен быть закодирован в формат URL-адреса перед отправкой.| 
|grant_type|обязательные|Должен иметь значение `client_credentials`.|

### <a name="second-case-access-token-request-with-a-certificate"></a>Второй пример. Запрос маркера доступа по сертификату 

``` 
POST /adfs/oauth2/token HTTP/1.1                
 
// Line breaks for clarity 
 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
&client_id=97e0a5b7-d745-40b6-94fe-5f77d35c6e05 
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer 
&client_assertion=eyJhbGciOiJSUzI1NiIsIng1dCI6Imd4OHRHeXN5amNScUtqRlBuZDdSRnd2d1pJMCJ9.eyJ{a lot of characters here}M8U3bSUKKJDEg 
&grant_type=client_credentials  
```

|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_assertion_type|обязательные|Должно быть указано значение urn:ietf:params:oauth:client-assertion-type:jwt-bearer.| 
|client_assertion|обязательные|Утверждение (JSON Web Token), которое необходимо создать и подписать с помощью сертификата, зарегистрированного вами в качестве учетных данных для приложения.|  
|grant_type|обязательные|Должен иметь значение `client_credentials`.|
|client_id|необязательно|Идентификатор приложения (клиента), который AD FS назначает приложению. Входит в client_assertion, поэтому его не нужно передавать здесь.| 
|scope|необязательно|Разделенный пробелами список областей, на которые пользователь должен предоставить согласие.| 

### <a name="use-a-token"></a>Использование маркера 
 
Теперь, когда вы получили маркер, примените его для выполнения запросов к ресурсу. Когда завершится срок действия маркера, повторите запрос к конечной точке /token, чтобы получить новый маркер доступа.  
 
```
GET /v1.0/me/messages 
Host: https://webapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...  
```

## <a name="resource-owner-password-credentials-grant-flow-not-recommended"></a>Поток предоставления учетных данных владельца ресурса с паролем (не рекомендуется) 
 
Предоставление учетных данных владельца ресурса с паролем (ROPC) позволяет приложению выполнять вход пользователя путем непосредственной обработки пароля. Поток ROPC требует высокого уровня доверия и создает уязвимость для пользователей, поэтому его следует использовать только в том случае, когда более безопасный поток полностью невозможен.  
 
### <a name="protocol-diagram"></a>Схема протокола 
 
На следующей схеме представлен поток ROPC.

![Поток ROPC](media/adfs-scenarios-for-developers/resource.png)

### <a name="authorization-request"></a>Запрос авторизации 
Поток ROPC состоит из одного запроса, в котором отправляется идентификатор клиента и учетные данные пользователя поставщику удостоверений, а в ответе возвращаются маркеры. Перед этим клиент должен получить адрес электронной почты и пароль пользователя. Сразу после успешного выполнения запроса клиент должен безопасным образом удалить эти учетные данные пользователя из памяти. Ни в коем случае не сохраняйте эти данные.  

```
// Line breaks and spaces are for legibility only. 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com  
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&scope= openid  
&username=myusername@contoso.com 
&password=SuperS3cret 
&grant_type=password 
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|ИД клиента| 
|grant_type|обязательные|Должен содержать пароль.| 
|username|обязательные|Адрес электронной почты пользователя.| 
|пароль|обязательные|Пароль пользователя.| 
|scope|необязательно|Список областей с разделителями-пробелами.|

### <a name="successful-authentication-response"></a>Ответ об успешном прохождении проверки подлинности 
В следующем примере показан ответ с успешным получением маркера. 

```
{ 
    "token_type": "Bearer", 
    "scope": "openid", 
    "expires_in": 3599, 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIn...", 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDR..." 
}  
```


|Параметр|Описание| 
|-----|-----|
|token_type|Всегда имеет значение Bearer.| 
|scope|Если маркер успешно возвращается, этот параметр будет содержать список областей, для которых этот маркер доступа является допустимым.| 
|expires_in|Срок действия прилагаемого маркера доступа (в секундах).| 
|access_token|Выдается для запрошенных областей.| 
|id_token|JSON Web Token (JWT). Приложение может расшифровать сегменты этого маркера, чтобы запросить сведения о выполнившем вход пользователе. Эти значения можно кэшировать и (или) отображать в приложении, но их не следует использовать в любых процессах авторизации или организации безопасности.| 
|refresh_token_expires_in|Срок действия прилагаемого маркера обновления (в секундах).| 
|refresh_token|Выдается, если исходный параметр области включает значение offline_access.|

Маркер обновления можно использовать для получения новых маркеров доступа и обновления через тот же поток, описанный выше в разделе о потоке предоставления кода проверки подлинности.   

## <a name="device-code-flow"></a>Поток кода устройства 
 
С помощью предоставления кода устройства пользователи могут входить на устройства с ограниченными возможностями для ввода данных, например на интеллектуальный телевизор, устройство IoT или принтер. Чтобы реализовать этот поток, на устройстве пользователю предлагается открыть определенную веб-страницу в браузере на другом устройстве и выполнить вход. После входа пользователя устройство получает маркеры доступа и маркеры обновления, если они нужны. 
 
### <a name="protocol-diagram"></a>Схема протокола 
 
Весь поток кода устройства выглядит примерно так, как на следующей схеме. Каждый из этих шагов мы опишем далее в этой статье. 
 
![Поток кода устройства](media/adfs-scenarios-for-developers/device.png)

### <a name="device-authorization-request"></a>Запрос авторизации устройства 
Клиент должен сначала обратиться к серверу проверки подлинности и получить код для устройства и пользователя, который используется для запуска проверки подлинности. Клиент получает этот запрос от конечной точки /devicecode. В этом запросе клиент должен также указать разрешения, которые нужно получить от пользователя. С момента отправки этого запроса у пользователя будет всего 15 минут на выполнение входа (типичное значение параметра expires_in), поэтому запрос лучше отправлять только после того, как пользователь подтвердил готовность выполнить вход. 

```
// Line breaks are for legibility only. 
 
POST https://adfs.contoso.com/adfs/oauth2/devicecode 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
scope=openid 
```


|Параметр|Условие|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), который AD FS назначает приложению.| 
|scope|необязательно|Список областей с разделителями-пробелами.|

### <a name="device-authorization-response"></a>Ответ на запрос авторизации устройства 
Успешный ответ содержит объект JSON с информацией, требуемой пользователю для выполнения входа. 


|Параметр|Описание|
|-----|-----| 
|device_code|Длинная строка, которая используется для подтверждения сеанса между клиентом и сервером авторизации. Клиент использует этот параметр для запроса маркера доступа от сервера авторизации.| 
|user_code|Короткая строка, которая отображается пользователю, для идентификации того же сеанса на другом устройстве.| 
|verification_uri|Универсальный код ресурса (URI), через который пользователь должен ввести предоставленный user_code, чтобы войти в систему.| 
|verification_uri_complete|Универсальный код ресурса (URI), через который пользователь должен ввести предоставленный user_code, чтобы войти в систему. Здесь автоматически подставляется значение user_code, чтобы пользователю не пришлось вводить его вручную.| 
|expires_in|Число секунд до истечения срока действия device_code и user_code.| 
|interval|Период между опросами (в секундах), которые выполняются клиентом.| 
|сообщение|Понятная человеку строка с инструкциями для пользователя. Этот параметр можно локализовать, добавив в запрос параметр вида ?mkt=xx-XX с соответствующим кодом языка и региональных параметров.  

### <a name="authenticating-the-user"></a>Проверка подлинности пользователя 
Получив значения user_code и verification_uri, клиент отображает их пользователю вместе с инструкциями по входу через браузер на мобильном телефоне или компьютере. Кроме того, клиент может предоставить QR-код или другой аналогичный механизм для отображения verfication_uri_complete с одновременным вводом user_code. Пока пользователь выполняет проверку подлинности по verification_uri, клиент должен регулярно запрашивать маркер через конечную точку /token с указанием кода устройства (device_code). 

```
POST https://adfs.contoso.com /adfs/oauth2/token 
Content-Type: application/x-www-form-urlencoded 
 
grant_type: urn:ietf:params:oauth:grant-type:device_code 
client_id: 6731de76-14a6-49ae-97bc-6eba6914391e 
device_code: GMMhmHCXhWEzkobqIHGG_EnNYYsAkukHspeYUk9E8 
```


|Параметр|обязательные|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Должен иметь значение urn:ietf:params:oauth:grant-type:device_code.| 
|client_id|обязательные|Должен совпадать с client_id, указанным в первом запросе.| 
|code|обязательные|Значение device_code, возвращенное по запросу авторизации устройства.|

### <a name="successful-authentication-response"></a>Ответ об успешном прохождении проверки подлинности 
Успешный ответ на запрос маркера будет выглядеть следующим образом:  


|Параметр|Описание|
|-----|-----| 
|token_type|Всегда имеет значение Bearer.| 
|scope|Если маркер успешно возвращается, здесь будет содержаться список областей, для которых этот маркер доступа является допустимым.| 
|expires_in|Срок действия прилагаемого маркера доступа (в секундах).| 
|access_token|Выдается для запрошенных областей.| 
|id_token|Выдается, если исходный параметр области включал значение области openid.| 
|refresh_token|Выдается, если исходный параметр области включает значение offline_access.| 
|refresh_token_expires_in|Срок действия прилагаемого маркера обновления (в секундах).| 


## <a name="related-content"></a>Связанное содержимое  
Полный список пошаговых руководств по использованию соответствующих потоков вы найдете на странице [о разработке для AD FS](../AD-FS-Development.md). 

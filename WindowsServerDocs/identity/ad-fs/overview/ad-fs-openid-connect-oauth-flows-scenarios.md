---
ms.assetid: 8a64545b-16bd-4c13-a664-cdf4c6ff6ea0
title: AD FS OpenID Connect подключения/OAuth потоки и сценарии приложений
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adfs
ms.openlocfilehash: d7ed8f7976116ab245fa730a5a050e7ec46cebea
ms.sourcegitcommit: f6490192d686f0a1e0c2ebe471f98e30105c0844
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2019
ms.locfileid: "70869488"
---
# <a name="ad-fs-openid-connectoauth-flows-and-application-scenarios"></a>AD FS OpenID Connect подключения/OAuth потоки и сценарии приложений
Применимо к AD FS 2016 и более поздних версий


|Сценарий|Пример сценария с использованием примеров|Поток/предоставление OAuth 2,0|Тип клиента|
|-----|-----|-----|-----|
|Одностраничное приложение</br> | &bull;[Пример с использованием ADAL](../development/Single-Page-Application-with-AD-FS.md)|[Полностью](#implicit-grant-flow)|Public (Общее)| 
|Веб-приложение, которое входит в систему пользователей</br> | &bull;[Пример с использованием OWIN](../development/enabling-openid-connect-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Общедоступная, конфиденциальная|  
|Собственное приложение вызывает веб-API</br>|&bull;[Пример с использованием MSAL](../development/msal/adfs-msal-native-app-web-api.md)</br>&bull;[Пример с использованием ADAL](../development/native-client-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Public (Общее)|   
|Веб-приложение вызывает веб-API</br>|&bull;[Пример с использованием MSAL](../development/msal/adfs-msal-web-app-web-api.md)</br>&bull;[Пример с использованием ADAL](../development/enabling-oauth-confidential-clients-with-ad-fs.md)|[Код авторизации](#authorization-code-grant-flow)|Конфиденциальность| 
|Веб-API вызывает другой веб-API от имени пользователя (OBO).</br>|&bull;[Пример с использованием MSAL](../development/msal/adfs-msal-web-api-web-api.md)</br>&bull;[Пример с использованием ADAL](../development/ad-fs-on-behalf-of-authentication-in-windows-server.md)|[От имени](#on-behalf-of-flow)|Веб-приложение действует как конфиденциальное| 
|Приложение управляющей программы вызывает веб-API||[Учетные данные клиента](#client-credentials-grant-flow)|Конфиденциальность| 
|Веб-приложение вызывает веб-API с использованием учетных записей пользователя||[Учетные данные пароля владельца ресурса](#resource-owner-password-credentials-grant-flow-not-recommended)|Общедоступная, конфиденциальная| 
|Веб-API вызывается бесбраузерным приложением||[Код устройства](#device-code-flow)|Общедоступная, конфиденциальная| 

## <a name="implicit-grant-flow"></a>Неявный поток предоставления 
 
Для одностраничных приложений (AngularJS, Ember. js, реагируют. js и т. д.) AD FS поддерживает неявный поток предоставления OAuth 2,0. Неявный поток описан в [спецификации OAuth 2,0](https://tools.ietf.org/html/rfc6749#section-4.2). Его основное преимущество заключается в том, что оно позволяет приложению получать маркеры от AD FS без выполнения обмена учетными данными внутреннего сервера. Это позволяет приложению входить в систему пользователя, поддерживать сеанс и получать маркеры для других веб-API в коде JavaScript клиента. При использовании неявного потока, предназначенного для [клиента](https://tools.ietf.org/html/rfc6749#section-10.3), необходимо учитывать ряд важных соображений безопасности.  
 
Если вы хотите использовать неявный поток и AD FS для добавления проверки подлинности в приложение JavaScript, выполните общие действия ниже.  
  
### <a name="protocol-diagram"></a>Схема протокола

На следующей схеме показано, как выглядит весь неявный поток входа, и в последующих разделах подробно описывается каждый шаг.  

![Неявный вход](media/adfs-scenarios-for-developers/implicit.png)

### <a name="request-id-token-and-access-token"></a>Токен идентификатора запроса и маркер доступа 
 
Чтобы изначально подписать пользователя в приложении, можно отправить запрос на проверку подлинности OpenID Connect Connect и получить id_token и маркер доступа из конечной точки AD FS.  
 
```
// Line breaks for legibility only 
 
https://adfs.contoso.com/adfs/oauth2/authorize? 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&response_type=id_token+token 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&scope=openid 
&response_mode=fragment 
&state=12345 
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.| 
|response_type|обязательные|Необходимо включить `id_token` для входа OpenID Connect Connect. Он также может включать response_type `token`. Использование токена позволяет приложению получать маркер доступа непосредственно от конечной точки авторизации, не требуя выполнения второго запроса к конечной точке маркера.| 
|redirect_uri|обязательные|Значение redirect_uri приложения, в котором можно отправить и получить ответы на проверку подлинности в приложении. Он должен точно соответствовать одному из URI перенаправления, настроенному в AD FS.| 
|требуем|обязательные|Значение, включаемое в запрос, созданное приложением, которое будет включаться в результирующий id_token в качестве утверждения. Затем приложение может проверить это значение, чтобы устранить атаки, направленные на воспроизведение маркеров. Значение обычно является случайной уникальной строкой, которую можно использовать для задания источника запроса. Требуется только при запросе id_token.|
|scope|необязательно|Список областей с разделителями-пробелами. Для OpenID Connect Connect она должна включать область `openid`.|
|resource|необязательно|URL веб-интерфейса API.</br>Примечание. при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого URL-адрес ресурса отправляется в составе параметра scope:`scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается здесь или в области ADFS будет использовать ресурс по умолчанию urn: Microsoft: UserInfo. политики ресурсов userInfo, такие как MFA, выдача или политика авторизации, не могут быть настроены.| 
|response_mode|необязательно| Указывает метод, который должен использоваться для отправки результирующего маркера обратно в приложение. По умолчанию — `fragment`.| 
|state|необязательно|Значение, включаемое в запрос, которое также будет возвращено в ответе маркера. Это может быть строка любого нужного содержимого. Для предотвращения атак с подделкой межсайтовых запросов обычно используется случайное уникальное значение. Состояние также используется для кодирования сведений о состоянии пользователя в приложении перед выполнением запроса проверки подлинности, например страницы или представления, на которых они находились.| 
|prompt|необязательно|Указывает необходимый тип взаимодействия с пользователем. В настоящее время единственными допустимыми значениями являются login и None.</br>- `prompt=login` вынуждает пользователя вводить свои учетные данные для запроса, отменяя единый вход. </br>- `prompt=none` обратное — это гарантирует, что пользователь не будет представлен ни в каких интерактивных запросах. Если запрос не может быть выполнен автоматически с помощью единого входа, AD FS выдаст ошибку interaction_required.| 
|login_hint|необязательно|Можно использовать для предварительной заполнения поля имя пользователя или адрес электронной почты на странице входа пользователя, если вы уже знакомы с их именем пользователя заранее. Часто приложения будут использовать этот параметр во время повторной проверки подлинности, уже извлекли имя пользователя из предыдущего входа, `upn`используя утверждение `id_token`из.| 
|domain_hint|необязательно|Если этот параметр включен, процесс обнаружения на основе домена, проходящего пользователем на странице входа, будет пропущен, что приведет к немного более быстрому взаимодействиям с пользователем.| 

На этом этапе пользователю будет предложено ввести свои учетные данные и выполнить проверку подлинности. После того как пользователь пройдет проверку подлинности, AD FS авторизации Endpoint вернет ответ в приложение на указанном redirect_uri, используя метод, указанный в параметре response_mode.  
 
### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ с `response_mode=fragment and response_type=id_token+token`помощью выглядит следующим образом:  
 
```
// Line breaks for legibility only 
 
GET https://localhost/myapp/# 
access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZEstZnl0aEV... 
&token_type=Bearer 
&expires_in=3599 
&scope=openid  
&id_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZstZnl0aEV1Q... 
&state=12345 
```


|Параметр|Описание| 
|-----|-----|
|access_token|Включается, если `token`response_type включает.|
|token_type|Включается, если `token`response_type включает. Всегда будет носителя.| 
|expires_in| Включается, если `token`response_type включает. Указывает количество секунд, в течение которых маркер является допустимым, для кэширования.| 
|scope| Указывает области, для которых ACCESS_TOKEN будет допустимым.|  
|id_token|Включается, если `id_token`response_type включает. Подписанный JSON Web Token (JWT). Приложение может декодировать сегменты этого маркера, чтобы запросить сведения о пользователе, выполнившего вход. Приложение может кэшировать значения и отображать их, но не зависит от ограничений авторизации или безопасности.| 
|state|Если в запрос включен параметр состояния, то в ответе должно появиться то же значение. Приложение должно проверить, совпадают ли значения состояния в запросе и ответе.|

### <a name="refresh-tokens"></a>Обновить маркеры 
Неявное предоставление не предоставляет маркеры обновления. Срок действия `access_tokens` и истекает через короткий период времени, поэтому приложение должно быть готово к регулярному обновлению маркеров. `id_tokens` Чтобы обновить токен любого типа, можно выполнить тот же скрытый запрос IFRAME, приведенный выше, с `prompt=none`помощью параметра, чтобы управлять поведением платформы удостоверений. Если вы хотите получить `new id_token`, обязательно используйте. `response_type=id_token` 

## <a name="authorization-code-grant-flow"></a>Поток предоставления кода авторизации 
 
Код авторизации OAuth 2,0 можно использовать в веб-приложениях для получения доступа к защищенным ресурсам, таким как веб-API. Поток кода авторизации OAuth 2,0 описан в [разделе 4,1 спецификации OAuth 2,0](https://tools.ietf.org/html/rfc6749). Он используется для проверки подлинности и авторизации в большинстве типов приложений, включая веб-приложения и изначально установленные приложения. Поток позволяет приложениям безопасно получать маркеры доступа, которые можно использовать для доступа к ресурсам, которым доверяет AD FS.  
 
### <a name="protocol-diagram"></a>Схема протокола 
 
На высоком уровне поток проверки подлинности для собственного приложения выглядит немного следующим образом:

![Поток предоставления кода авторизации](media/adfs-scenarios-for-developers/authorization.png)

### <a name="request-an-authorization-code"></a>Запрос кода авторизации 
 
Поток кода авторизации начинается с клиента, направляющего пользователя в конечную точку/Authorize. В этом запросе клиент указывает разрешения, которые он должен получить от пользователя: 
 
```
// Line breaks for legibility only 
 
https://adfs.contoso.com/adfs/oauth2/authorize? 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&response_type=code 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&response_mode=query 
&resource=https://webapi.com/ 
&scope=openid 
&state=12345 
```

|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.|  
|response_type|обязательные| Должен быть включен код для потока кода авторизации.| 
|redirect_uri|обязательные|В `redirect_uri` приложении, где ответы на проверку подлинности могут быть отправлены и получены приложением. Он должен точно соответствовать одному из URI перенаправления, зарегистрированному в AD FS для клиента.|  
|resource|необязательно|URL веб-интерфейса API.</br>Примечание. при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого URL-адрес ресурса отправляется в составе параметра scope:`scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается здесь или в области ADFS будет использовать ресурс по умолчанию urn: Microsoft: UserInfo. политики ресурсов userInfo, такие как MFA, выдача или политика авторизации, не могут быть настроены.| 
|scope|необязательно|Список областей с разделителями-пробелами.|
|response_mode|необязательно|Указывает метод, который должен использоваться для отправки результирующего маркера обратно в приложение. Ниже указаны доступные значения. </br>запрос </br>-Fragment </br>- form_post</br>`query` предоставляет код в виде параметра строки запроса в URI перенаправления. Если вы запрашиваете код, можно использовать запросы, фрагменты или form_post.  `form_post` выполняетзапись,содержащуюкод, в URI перенаправления.|
|state|необязательно|Значение, включаемое в запрос, которое также будет возвращено в ответе маркера. Это может быть строка любого нужного содержимого. Для предотвращения атак с подделкой межсайтовых запросов обычно используется случайное уникальное значение. Значение также может закодировать сведения о состоянии пользователя в приложении до того, как был выполнен запрос проверки подлинности, например страницу или представление, на котором они находились.|
|prompt|необязательно|Указывает необходимый тип взаимодействия с пользователем. В настоящее время единственными допустимыми значениями являются login и None.</br>- `prompt=login` вынуждает пользователя вводить свои учетные данные для запроса, отменяя единый вход. </br>- `prompt=none` обратное — это гарантирует, что пользователь не будет представлен ни в каких интерактивных запросах. Если запрос не может быть выполнен автоматически с помощью единого входа, AD FS выдаст ошибку interaction_required.|
|login_hint|необязательно|Можно использовать для предварительной заполнения поля имя пользователя или адрес электронной почты на странице входа пользователя, если вы уже знакомы с их именем пользователя заранее. Часто приложения будут использовать этот параметр во время повторной проверки подлинности, уже извлекли имя пользователя из предыдущего входа, `upn`используя утверждение `id_token`из.|
|domain_hint|необязательно|Если этот параметр включен, процесс обнаружения на основе домена, проходящего пользователем на странице входа, будет пропущен, что приведет к немного более быстрому взаимодействиям с пользователем.|
|code_challenge_method|необязательно|Метод, используемый для кодирования code_verifier для параметра code_challenge. Может принимать одно из следующих значений: </br>-Plain </br>- S256 </br>Если аргумент исключен, code_challenge считается открытым текстом, если `code_challenge` включен. AD FS поддерживает как простые, так и S256. Дополнительные сведения см. в [документе RFC PKCE](https://tools.ietf.org/html/rfc7636).|
|code_challenge|необязательно| Используется для защиты предоставления кода авторизации с помощью ключа подтверждения для обмена кодом (PKCE) от собственного клиента. Требуется, `code_challenge_method`если включен. Дополнительные сведения см. в [документе RFC PKCE](https://tools.ietf.org/html/rfc7636)|

На этом этапе пользователю будет предложено ввести свои учетные данные и выполнить проверку подлинности. После того как пользователь проходит проверку подлинности, AD FS будет возвращать ответ на ваше приложение `redirect_uri`в указанном виде с помощью метода `response_mode`, указанного в параметре.  
 
### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ с использованием response_mode = Query выглядит следующим образом: 
 
```
GET https://adfs.contoso.com/common/oauth2/nativeclient? 
code=AwABAAAAvPM1KaPlrEqdFSBzjqfTGBCmLdgfSTLEMPGYuNHSUYBrq... 
&state=12345  
```


|Параметр|Описание|
|-----|-----|
|code|Объект `authorization_code` , запрошенный приложением. Приложение может использовать код авторизации для запроса маркера доступа к целевому ресурсу. Authorization_codes кратковременно, обычно срок их действия истекает через 10 минут.|
|state|`state` Если параметр включен в запрос, то в ответе должно появиться то же значение. Приложение должно проверить, совпадают ли значения состояния в запросе и ответе.|

### <a name="request-an-access-token"></a>Запрос маркера доступа 
 
Теперь, когда вы приобрели `authorization_code` и получили разрешение у пользователя, вы можете активировать код `access_token` для для требуемого ресурса. Для этого отправьте запрос POST в конечную точку/Token:  
 
```
// Line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com/ 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&code=OAAABAAAAiL9Kn2Z27UubvWFPbm0gLWQJVzCTE9UkP3pSx1aXxUjq3n8b2JRLk4OxVXr... 
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F 
&grant_type=authorization_code 
&client_secret=JqQX2PNo9bpM0uEihUPzyrh    // NOTE: Only required for confidential clients (web apps)  
```

|Параметр|Обязательный или необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.| 
|grant_type|обязательные|Должен быть `authorization_code` для потока кода авторизации.| 
|code|обязательные|Объект `authorization_code` , полученный в первой части последовательности.| 
|redirect_uri|обязательные|То же `redirect_uri` значение, которое использовалось для `authorization_code`получения.| 
|client_secret|требуется для веб-приложений|Секрет приложения, созданный во время регистрации приложения в AD FS. Не следует использовать секрет приложения в собственном приложении, так как client_secrets не может быть надежно сохранен на устройствах. Он необходим для веб-приложений и веб-API, которые могут безопасно хранить client_secret на стороне сервера. Секрет клиента должен быть закодирован в формате URL-адреса перед отправкой. Эти приложения также могут использовать проверку подлинности на основе ключей, подписывая JWT и добавляя его в качестве параметра client_assertion.| 
|code_verifier|необязательно|То же `code_verifier` , что использовалось для получения код авторизации. Требуется, если PKCE использовался в запросе на предоставление кода авторизации. Дополнительные сведения см. в [документе RFC PKCE](https://tools.ietf.org/html/rfc7636).</br>Примечание. применяется к AD FS 2019 и более поздних версий.| 

### <a name="successful-response"></a>Успешный ответ 
 
Успешный ответ маркера будет выглядеть следующим образом: 
 
```
{ 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...", 
    "token_type": "Bearer", 
    "expires_in": 3599, 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDRkMTFhMi1mODE0LTQ2YTctOD...", 
} 
```


|Параметр|Описание| 
|-----|-----|
|access_token|Запрашиваемый маркер доступа. Приложение может использовать этот токен для проверки подлинности в защищенном ресурсе (веб-API).| 
|token_type|Указывает значение типа токена. Единственный тип, поддерживаемый AD FS, — Bearer.
|expires_in|Срок действия маркера доступа (в секундах).
|refresh_token|Токен обновления OAuth 2,0. Приложение может использовать этот маркер для получения дополнительных маркеров доступа после истечения срока действия текущего маркера доступа. Маркеры обновления долгое время существования и могут использоваться для хранения доступа к ресурсам в течение продолжительного периода времени.| 
|refresh_token_expires_in|Срок действия маркера обновления (в секундах).| 
|id_token|JSON Web Token (JWT). Приложение может декодировать сегменты этого маркера, чтобы запросить сведения о пользователе, выполнившего вход. Приложение может кэшировать значения и отображать их, но не должно полагаться на них для авторизации или разграничения безопасности.|

### <a name="use-the-access-token"></a>Использование маркера доступа 
 
```
GET /v1.0/me/messages 
Host: https://webapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q... 
 ```

### <a name="refresh-the-access-token"></a>Обновление маркера доступа 
 
Маркеры доступа кратковременно, и их необходимо обновить после истечения срока действия, чтобы продолжить доступ к ресурсам. Это можно сделать, отправив другой запрос POST в `/token` конечную точку, на этот раз указав параметр refresh_token вместо кода. Маркеры обновления допустимы для всех разрешений, для которых ваш клиент уже получил маркер доступа. 
 
Маркеры обновления не имеют указанного времени существования. Как правило, время существования маркеров обновления является относительно длинным. Однако в некоторых случаях срок действия маркеров обновления истекает, отзываются или недостаточно привилегий для требуемого действия. Приложение должно правильно рассчитывать и справляться с ошибками, возвращаемыми конечной точкой выдачи маркера.  
 
Хотя маркеры обновления не отменяются при использовании для получения новых маркеров доступа, ожидается удаление старого маркера обновления. В спецификации OAuth 2,0 указано следующее: "Сервер авторизации может выдать новый маркер обновления. в этом случае клиент должен удалить старый маркер обновления и заменить его новым маркером обновления. Сервер авторизации может отозвать старый маркер обновления после выпуска нового маркера обновления для клиента ". 
 
```
// Line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&refresh_token=OAAABAAAAiL9Kn2Z27UubvWFPbm0gLWQJVzCTE9UkP3pSx1aXxUjq... 
&grant_type=refresh_token 
&client_secret=JqQX2PNo9bpM0uEihUPzyrh      // NOTE: Only required for confidential clients (web apps)  
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.| 
|grant_type|обязательные|Должен быть `refresh_token` для этого участка потока кода авторизации.| 
|resource|необязательно|URL веб-интерфейса API.</br>Примечание. при использовании клиентской библиотеки MSAL параметр resource не отправляется. Вместо этого URL-адрес ресурса отправляется в составе параметра scope:`scope = [resource url]//[scope values e.g., openid]`</br>Если ресурс не передается здесь или в области ADFS будет использовать ресурс по умолчанию urn: Microsoft: UserInfo. политики ресурсов userInfo, такие как MFA, выдача или политика авторизации, не могут быть настроены.|
|scope|необязательно|Список областей с разделителями-пробелами.| 
|refresh_token|обязательные|Параметр refresh_token, полученный во второй части последовательности.| 
|client_secret|требуется для веб-приложений| Секрет приложения, созданный на портале регистрации приложений для вашего приложения. Его не следует использовать в собственном приложении, так как client_secrets не может быть надежно сохранен на устройствах. Он необходим для веб-приложений и веб-API, которые могут безопасно хранить client_secret на стороне сервера. Эти приложения также могут использовать проверку подлинности на основе ключей, подписывая JWT и добавляя его в качестве параметра client_assertion.|

### <a name="successful-response"></a>Успешный ответ 
Успешный ответ маркера будет выглядеть следующим образом: 
 
```
{ 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...", 
    "token_type": "Bearer", 
    "expires_in": 3599, 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDRkMTFhMi1mODE0LTQ2YTctOD...", 
}  
```
|Параметр|Описание| 
|-----|-----|
|access_token|Запрашиваемый маркер доступа. Приложение может использовать этот маркер для проверки подлинности защищенного ресурса, например веб-API.| 
|token_type|Указывает значение типа токена. Единственный тип, поддерживаемый AD FS, — Bearer|
|expires_in|Срок действия маркера доступа (в секундах).|
|scope|Области, для которых ACCESS_TOKEN является допустимым.| 
|refresh_token|Токен обновления OAuth 2,0. Приложение может использовать этот маркер для получения дополнительных маркеров доступа после истечения срока действия текущего маркера доступа. Маркеры обновления долгое время существования и могут использоваться для хранения доступа к ресурсам в течение продолжительного периода времени.| 
|refresh_token_expires_in|Срок действия маркера обновления (в секундах).| 
|id_token|JSON Web Token (JWT). Приложение может декодировать сегменты этого маркера, чтобы запросить сведения о пользователе, выполнившего вход. Приложение может кэшировать значения и отображать их, но не должно полагаться на них для авторизации или разграничения безопасности.|

## <a name="on-behalf-of-flow"></a>Поток "от имени" 
 
Протокол OAuth 2,0 on-"Flow" (OBO) служит вариантом использования, при котором приложение вызывает API службы или веб-интерфейса, который, в свою очередь, должен вызывать другую службу или веб-API. Идея состоит в том, чтобы распространить делегированное удостоверение пользователя и разрешения через цепочку запросов. Чтобы служба среднего уровня выполняла запросы с проверкой подлинности к подчиненной службе, ей необходимо защитить маркер доступа от AD FS от имени пользователя.  
 
### <a name="protocol-diagram"></a>Схема протокола 
Предположим, что пользователь прошел проверку подлинности в приложении с помощью потока авторизации OAuth 2,0, описанного выше. На этом этапе приложение имеет маркер доступа для API A (токен а) с утверждениями пользователя и согласиеми на доступ к веб-API среднего уровня (API а). Убедитесь, что клиент запрашивает область user_impersonation в токене. Теперь API A должен выполнить запрос, прошедший проверку подлинности, в подчиненный веб-API (API B). 

Приведенные ниже действия составляют поток OBO и объясняются с помощью следующей схемы. 

![Поток "от имени"](media/adfs-scenarios-for-developers/obo.png)

  1. Клиентское приложение выполняет запрос к API A с токеном а.  
  Примечание. При настройке потока OBO в AD FS убедитесь, что `user_impersonation` выбрана область и в запросе `user_impersonation` задана область запроса клиента. 
  2. API A проверяет подлинность конечной точки выдачи маркера AD FS и запрашивает маркер для доступа к API B. Примечание. При настройке этого потока в AD FS убедитесь, что API A также зарегистрирован в качестве серверного приложения с clientID, имеющим то же значение, что и идентификатор ресурса в API а. Дополнительные сведения см. в статье Добавление ссылки от имени образца.  
  3. Конечная точка выдачи маркера AD FS проверяет учетные данные API а с токеном а и выдает маркер доступа для API B (маркер B). 
  4. Токен B задается в заголовке авторизации запроса к API B. 
  5. Данные из защищенного ресурса возвращаются API B. 

### <a name="service-to-service-access-token-request"></a>Запрос маркера доступа между службами 
 
Чтобы запросить маркер доступа, выполните HTTP-запрос POST к конечной точке токена AD FS со следующими параметрами.  


### <a name="first-case-access-token-request-with-a-shared-secret"></a>Первый случай: Запрос маркера доступа с общим секретом 
 
При использовании общего секрета запрос на маркер доступа между службами содержит следующие параметры: 


|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Тип запроса маркера. Для запроса, использующего JWT, значение должно быть urn: IETF: params: OAuth: Grant-Type: JWT-Bearer.|  
|client_id|обязательные|Идентификатор клиента, настраиваемый при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Он должен совпадать с ИДЕНТИФИКАТОРом ресурса, используемым в первой части, т. е. URL-адресом первого веб-API.| 
|client_secret|обязательные|Секрет приложения, созданный во время регистрации приложения на сервере AD FS.| 
|утверждение|обязательные|Значение токена, используемого в запросе.|  
|requested_token_use|обязательные|Указывает, как должен обрабатываться запрос. В потоке OBO значение должно быть равно on_behalf_of.| 
|resource|обязательные|Идентификатор ресурса, предоставленный при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Идентификатор ресурса должен быть URL-адресом второго приложения среднего уровня веб-API, вызываемого от имени клиента.|
|scope|необязательно|Разделенный пробелами список областей для запроса маркера.| 

#### <a name="example"></a>Пример 
 
Далее `HTTP POST` запрашиваются маркер доступа и маркер обновления. 
 
```
//line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: adfs.contoso.com  
Content-Type: application/x-www-form-urlencoded 
 
grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer 
&client_id=https://webapi.com/ 
&client_secret=BYyVnAt56JpLwUcyo47XODd 
&assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIm… 
&resource=https://secondwebapi.com/
&requested_token_use=on_behalf_of
&scope=openid    
```

### <a name="second-case-access-token-request-with-a-certificate"></a>Второй случай: Запрос маркера доступа с сертификатом 
 
Запрос маркера доступа между службами с сертификатом содержит следующие параметры: 


|Параметр|обязательный или необязательный|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Тип запроса маркера. Для запроса, использующего JWT, значение должно быть urn: IETF: params: OAuth: Grant-Type: JWT-Bearer. |
|client_id|обязательные|Идентификатор клиента, настраиваемый при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Он должен совпадать с ИДЕНТИФИКАТОРом ресурса, используемым в первой части, т. е. URL-адресом первого веб-API.|  
|client_assertion_type|обязательные|Значение должно быть urn: IETF: params: OAuth: Client-assertion-Type: JWT-Bearer.| 
|client_assertion|обязательные|Утверждение (веб-токен JSON), которое необходимо создать и подписать с помощью сертификата, зарегистрированного в качестве учетных данных для приложения.|  
|утверждение|обязательные|Значение токена, используемого в запросе.| 
|requested_token_use|обязательные|Указывает, как должен обрабатываться запрос. В потоке OBO значение должно быть равно on_behalf_of.| 
|resource|обязательные|Идентификатор ресурса, предоставленный при регистрации первого веб-API в качестве серверного приложения (приложение среднего уровня). Идентификатор ресурса должен быть URL-адресом второго приложения среднего уровня веб-API, вызываемого от имени клиента.|
|scope|необязательно|Разделенный пробелами список областей для запроса маркера.|


Обратите внимание, что параметры являются практически такими же, как и в случае запроса с помощью общего секрета, за исключением того, что параметр client_secret заменяется двумя параметрами: client_assertion_type и client_assertion. 

#### <a name="example"></a>Пример 
Следующий запрос HTTP POST запрашивает маркер доступа для веб-API с помощью сертификата.

``` 
// line breaks for legibility only 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer 
&client_id= https://webapi.com/ 
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer 
&client_assertion=eyJhbGciOiJSUzI1NiIsIng1dCI6Imd4OHRHeXN5amNS… 
&resource=https://secondwebapi.com/
&requested_token_use=on_behalf_of
&scope= openid 
```    

### <a name="service-to-service-access-token-response"></a>Ответ службы на маркер доступа к службе 
 
Ответ об успешном выполнении — это JSON-ответ OAuth 2,0 со следующими параметрами. 


|Параметр|Описание|
|-----|-----| 
|token_type|Указывает значение типа токена. Единственный тип, поддерживаемый AD FS, — Bearer. | 
|scope|Область доступа, предоставленная в токене.| 
|expires_in|Период времени в секундах, в течение которого маркер доступа является допустимым.| 
|access_token|Запрашиваемый маркер доступа. Вызывающая служба может использовать этот токен для проверки подлинности принимающей службы.| 
|id_token|JSON Web Token (JWT). Приложение может декодировать сегменты этого маркера, чтобы запросить сведения о пользователе, выполнившего вход. Приложение может кэшировать значения и отображать их, но не должно полагаться на них для авторизации или разграничения безопасности.| 
|refresh_token|Маркер обновления для запрошенного маркера доступа. Вызывающая служба может использовать этот токен для запроса другого маркера доступа после истечения срока действия текущего маркера доступа.|
|Refresh_token_expires_in|Продолжительность времени в секундах, в течение которого маркер обновления является допустимым. 

### <a name="success-response-example"></a>Пример ответа об успешном выполнении 
 
В следующем примере показан ответ об успешном выполнении запроса на запрос маркера доступа для веб-API. 

``` 
{ 
  "token_type": "Bearer", 
  "scope": openid, 
  "expires_in": 3269, 
  "access_token": "eyJ0eXAiOiJKV1QiLCJub25jZSI6IkFRQUJBQUFBQUFCbmZpRy1t" 
  "id_token": "aWRfdG9rZW49ZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKU1V6STFOa" 
  "refresh_token": "OAQABAAAAAABnfiG…" 
  "refresh_token_expires_in": 28800, 
} 
```  
 
 
Использование маркера доступа для доступа к защищенному ресурсу Теперь служба среднего уровня может использовать полученный выше маркер, чтобы сделать запросы, прошедшие проверку подлинности, на нижестоящий веб-API, установив маркер в заголовке авторизации.  

#### <a name="example"></a>Пример 
``` 
GET /v1.0/me HTTP/1.1 
Host: https://secondwebapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJub25jZSI6IkFRQUJBQUFBQUFCbmZpRy1tQ… 
``` 

## <a name="client-credentials-grant-flow"></a>Поток предоставления учетных данных клиента 
 
Вы можете использовать учетные данные клиента OAuth 2,0, указанные в [RFC 6749](https://tools.ietf.org/html/rfc6749#section-4.4), для доступа к ресурсам, размещенным в Интернете, с помощью удостоверения приложения. Этот тип предоставления обычно используется для взаимодействий "сервер-сервер", которые должны выполняться в фоновом режиме без немедленного взаимодействия с пользователем. Эти типы приложений часто называются управляющими программами или учетными записями служб. 

Поток предоставления учетных данных клиента OAuth 2,0 позволяет веб-службе (конфиденциальному клиенту) использовать собственные учетные данные вместо олицетворения пользователя для проверки подлинности при вызове другой веб-службы. В этом сценарии клиент обычно представляет собой веб-службу среднего уровня, службу управляющей программы или веб-сайт. Для более высокого уровня гарантии AD FS также позволяет вызывающей службе использовать сертификат (вместо общего секрета) в качестве учетных данных. 

### <a name="protocol-diagram"></a>Схема протокола 

На следующей диаграмме показан поток предоставления учетных данных клиента. 

![Учетные данные клиента](media/adfs-scenarios-for-developers/credentials.png)

### <a name="request-a-token"></a>Запрос маркера 
 
Чтобы получить маркер с помощью предоставления учетных данных клиента, отправьте `POST` запрос в конечную точку AD FS/Token:  
 
### <a name="first-case-access-token-request-with-a-shared-secret"></a>Первый случай: Запрос маркера доступа с общим секретом 
 
```
POST /adfs/oauth2/token HTTP/1.1            
//Line breaks for clarity 
 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
client_id=535fb089-9ff3-47b6-9bfb-4f1264799865 
&client_secret=qWgdYAmab0YSkuL1qKv5bPX 
&grant_type=client_credentials 
```

|Параметр|Обязательный/необязательный|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.| 
|scope|необязательно|Разделенный пробелами список областей, на которые пользователь должен согласиться.| 
|client_secret|обязательные|Секрет клиента, созданный для приложения на портале регистрации приложений. Секрет клиента должен быть закодирован в формате URL-адреса перед отправкой.| 
|grant_type|обязательные|Необходимо задать значение `client_credentials`.|

### <a name="second-case-access-token-request-with-a-certificate"></a>Второй случай: Запрос маркера доступа с сертификатом 

``` 
POST /adfs/oauth2/token HTTP/1.1                
 
// Line breaks for clarity 
 
Host: https://adfs.contoso.com 
Content-Type: application/x-www-form-urlencoded 
 
&client_id=97e0a5b7-d745-40b6-94fe-5f77d35c6e05 
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer 
&client_assertion=eyJhbGciOiJSUzI1NiIsIng1dCI6Imd4OHRHeXN5amNScUtqRlBuZDdSRnd2d1pJMCJ9.eyJ{a lot of characters here}M8U3bSUKKJDEg 
&grant_type=client_credentials  
```

|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_assertion_type|обязательные|Значение должно быть установлено в urn: IETF: params: OAuth: Client-assertion-Type: JWT-Bearer.| 
|client_assertion|обязательные|Утверждение (веб-токен JSON), которое необходимо создать и подписать с помощью сертификата, зарегистрированного в качестве учетных данных для приложения.|  
|grant_type|обязательные|Необходимо задать значение `client_credentials`.|
|client_id|необязательно|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение. Это часть client_assertion, поэтому ее не нужно передавать здесь.| 
|scope|необязательно|Разделенный пробелами список областей, на которые пользователь должен согласиться.| 

### <a name="use-a-token"></a>Использование токена 
 
Теперь, когда вы получили маркер, используйте маркер для выполнения запросов к ресурсу. По истечении срока действия маркера повторите запрос к конечной точке/Token, чтобы получить новый маркер доступа.  
 
```
GET /v1.0/me/messages 
Host: https://webapi.com 
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...  
```

## <a name="resource-owner-password-credentials-grant-flow-not-recommended"></a>Пароль владельца ресурса поток предоставления учетных данных (не рекомендуется) 
 
Предоставление учетных данных для пароля владельца ресурса (РОПК) позволяет приложению выполнять вход пользователя путем непосредственной обработки пароля. Поток РОПК требует высокого уровня доверия и раскрытия пользователей, и этот поток следует использовать только в том случае, если другой, более безопасный поток не может использоваться.  
 
### <a name="protocol-diagram"></a>Схема протокола 
 
На следующей диаграмме показан поток РОПК.

![Поток РОПК](media/adfs-scenarios-for-developers/resource.png)

### <a name="authorization-request"></a>Запрос авторизации 
Поток РОПК — это один запрос — он отправляет идентификатор клиента и учетные данные пользователя в IDP, а затем получает маркеры в Return. Перед этим клиент должен запросить адрес электронной почты пользователя (UPN) и пароль. Сразу после успешного запроса клиент должен безопасно освободить учетные данные пользователя из памяти. Он не должен сохранять их.  

```
// Line breaks and spaces are for legibility only. 
 
POST /adfs/oauth2/token HTTP/1.1 
Host: https://adfs.contoso.com  
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
&scope= openid  
&username=myusername@contoso.com 
&password=SuperS3cret 
&grant_type=password 
```


|Параметр|Обязательный/необязательный|Описание| 
|-----|-----|-----|
|client_id|обязательные|Идентификатор клиента| 
|grant_type|обязательные|Необходимо задать значение Password.| 
|username|обязательные|Адрес электронной почты пользователя.| 
|password|обязательные|Пароль пользователя.| 
|scope|необязательно|Список областей с разделителями-пробелами.|

### <a name="successful-authentication-response"></a>Успешный ответ проверки подлинности 
В следующем примере показан успешный ответ маркера: 

```
{ 
    "token_type": "Bearer", 
    "scope": "openid", 
    "expires_in": 3599, 
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIn...", 
    "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGAMxZGUTdM0t4B4...", 
    "refresh_token_expires_in": 28800, 
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIyZDR..." 
}  
```


|Параметр|Описание| 
|-----|-----|
|token_type|Всегда имеет значение носителя.| 
|scope|При возвращении маркера доступа этот параметр перечисляет области, для которых маркер доступа является допустимым.| 
|expires_in|Количество секунд, в течение которых включен маркер доступа.| 
|access_token|Выдается для запрошенных областей.| 
|id_token|JSON Web Token (JWT). Приложение может декодировать сегменты этого маркера, чтобы запросить сведения о пользователе, выполнившего вход. Приложение может кэшировать значения и отображать их, но не должно полагаться на них для авторизации или разграничения безопасности.| 
|refresh_token_expires_in|Количество секунд, в течение которых включен маркер обновления.| 
|refresh_token|Выдается, если исходный параметр области включает offline_access.|

Маркер обновления можно использовать для получения новых маркеров доступа и обновления маркеров с помощью того же потока, описанного выше в разделе поток проверки подлинности предоставления кода.   

## <a name="device-code-flow"></a>Поток кода устройства 
 
Предоставление кода устройства позволяет пользователям входить на устройства с ограниченным входом, например на интеллектуальный телевизор, на устройство IoT или на принтер. Чтобы включить этот поток, на устройстве пользователь должен посетить веб-страницу в браузере на другом устройстве, чтобы войти в систему. После входа пользователя устройство сможет получить маркеры доступа и обновить токены по мере необходимости. 
 
### <a name="protocol-diagram"></a>Схема протокола 
 
Весь поток кода устройства выглядит примерно так же, как на следующей схеме. Мы рассмотрим каждый из шагов, описанных далее в этой статье. 
 
![Поток кода устройства](media/adfs-scenarios-for-developers/device.png)

### <a name="device-authorization-request"></a>Запрос авторизации устройства 
Клиент должен сначала проверить сервер проверки подлинности для устройства и пользовательского кода, который используется для инициации проверки подлинности. Клиент собирает этот запрос из конечной точки/девицекоде. В этом запросе клиент должен также включать разрешения, которые он должен получить от пользователя. С момента отправки этого запроса у пользователя будет всего 15 минут для входа (обычное значение для expires_in), поэтому этот запрос следует выполнять только после того, как пользователь указал, что они готовы к выполнению входа. 

```
// Line breaks are for legibility only. 
 
POST https://adfs.contoso.com/adfs/oauth2/devicecode 
Content-Type: application/x-www-form-urlencoded 
 
client_id=6731de76-14a6-49ae-97bc-6eba6914391e 
scope=openid 
```


|Параметр|Условие|Описание|
|-----|-----|-----| 
|client_id|обязательные|Идентификатор приложения (клиента), которому AD FS назначено ваше приложение.| 
|scope|необязательно|Список областей с разделителями-пробелами.|

### <a name="device-authorization-response"></a>Ответ авторизации устройства 
Успешный ответ — это объект JSON, содержащий необходимые сведения, позволяющие пользователю выполнить вход. 


|Параметр|Описание|
|-----|-----| 
|device_code|Длинная строка, используемая для проверки сеанса между клиентом и сервером авторизации. Клиент использует этот параметр для запроса маркера доступа с сервера авторизации.| 
|user_code|Короткая строка, отображаемая для пользователя, который используется для задания сеанса на вторичном устройстве.| 
|verification_uri|Универсальный код ресурса (URI), по которому пользователь должен обратиться к user_code, чтобы войти в систему.| 
|verification_uri_complete|Универсальный код ресурса (URI), по которому пользователь должен обратиться к user_code, чтобы войти в систему. Это заполняется user_code, поэтому пользователю не нужно вводить user_code| 
|expires_in|Число секунд до истечения срока действия device_code и user_code.| 
|Пределах|Количество секунд, в течение которых клиент должен ожидать между запросами опроса.| 
|message|Понятная пользователю строка с инструкциями для пользователя. Это можно локализовать, включив параметр запроса в запрос формы? МКТ = XX-XX, заполнив код языка и региональных параметров соответствующего языка.  

### <a name="authenticating-the-user"></a>Проверка подлинности пользователя 
После получения user_code и verification_uri клиент отображает их пользователю, указывая, что вход выполняется с помощью мобильного телефона или браузера ПК. Кроме того, клиент может использовать QR-код или аналогичный механизм для вывода verfication_uri_complete, который выполнит шаг ввода user_code для пользователя. Хотя пользователь проходит проверку подлинности в verification_uri, клиент должен опросить конечную точку/Token для запрошенного маркера, используя device_code. 

```
POST https://adfs.contoso.com /adfs/oauth2/token 
Content-Type: application/x-www-form-urlencoded 
 
grant_type: urn:ietf:params:oauth:grant-type:device_code 
client_id: 6731de76-14a6-49ae-97bc-6eba6914391e 
device_code: GMMhmHCXhWEzkobqIHGG_EnNYYsAkukHspeYUk9E8 
```


|Параметр|обязательные|Описание|
|-----|-----|-----| 
|grant_type|обязательные|Должно быть urn: IETF: params: OAuth: Grant-Type: device_code| 
|client_id|обязательные|Должен соответствовать client_id, используемому в первоначальном запросе.| 
|code|обязательные|Device_code, возвращенный в запросе авторизации устройства.|

### <a name="successful-authentication-response"></a>Успешный ответ проверки подлинности 
Успешный ответ маркера будет выглядеть следующим образом:  


|Параметр|Описание|
|-----|-----| 
|token_type|Всегда «Bearer».| 
|scope|При возвращении маркера доступа выводится список областей, для которых маркер доступа является допустимым.| 
|expires_in|Количество секунд, по истечении которого включенный маркер доступа будет действителен для.| 
|access_token|Выдается для запрошенных областей.| 
|id_token|Выдается, если исходный параметр области включал в себя область OpenID Connect.| 
|refresh_token|Выдается, если исходный параметр области включает offline_access.| 
|refresh_token_expires_in|Количество секунд, по истечении которого включенный маркер обновления будет действителен для.| 


## <a name="related-content"></a>Связанное содержимое  
Полный список пошаговых руководств, в которых содержатся пошаговые инструкции по использованию соответствующих потоков, см. в разделе [AD FS Development](../AD-FS-Development.md) . 

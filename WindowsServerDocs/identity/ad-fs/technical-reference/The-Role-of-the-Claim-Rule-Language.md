---
title: Роль языка правил утверждений
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 07/07/2017
ms.topic: article
ms.prod: windows-server
ms.assetid: dda9d148-d72f-4bff-aa2a-f2249fa47e4c
ms.technology: identity-adfs
ms.openlocfilehash: ff4c43bb8dc5582716638f0a3f6e4f6a8022aece
ms.sourcegitcommit: 6aff3d88ff22ea141a6ea6572a5ad8dd6321f199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71407373"
---
# <a name="the-role-of-the-claim-rule-language"></a>Роль языка правил утверждений
Язык правил утверждений службы федерации Active Directory (AD FS) (AD FS) выступает в качестве административного блока для поведения входящих и исходящих утверждений, тогда как обработчик утверждений выступает в качестве механизма обработки для логики на языке правил утверждений, который определяет настраиваемое правило. Дополнительные сведения о том, как все правила обрабатываются подсистемой утверждений, см. [в разделе роль подсистемы утверждений](The-Role-of-the-Claims-Engine.md).  

## <a name="creating-custom-claim-rules-using-the-claim-rule-language"></a>Создание настраиваемых правил утверждений с помощью языка правил утверждений  
AD FS предоставляет администраторам возможность определить настраиваемые правила, которые они могут использовать для определения поведения идентификационных утверждений на языке правил утверждений. С помощью примеров синтаксиса языка правила для утверждений в этом разделе можно создать настраиваемое правило, которое перечисляет, добавляет, удаляет и изменяет утверждения в соответствии с потребностями Организации. Вы можете создать настраиваемые правила, введя в синтаксисе языка правила утверждения в **заявках на отправку с помощью шаблона настраиваемого правила утверждения** .  

Правила отделяются друг от друга точкой с запятой.  

Дополнительные сведения об использовании настраиваемых правил см. в разделе [когда следует использовать настраиваемое правило утверждения](When-to-Use-a-Custom-Claim-Rule.md).  

## <a name="using-claim-rule-templates-to-learn-about-the-claim-rule-language-syntax"></a>Использование шаблонов правил утверждений для получения сведений о синтаксисе языка правил утверждений  
AD FS также предоставляет набор стандартных шаблонов правил принятия заявок и утверждений, которые можно использовать для реализации общих правил утверждений. В диалоговом окне **изменение правил утверждений** для данного отношения доверия можно создать предопределенное правило, а также просмотреть синтаксис языка правил утверждений, составляющий это правило, выбрав вкладку **Просмотр языка правила** для этого правила. С помощью сведений, приведенных в этом разделе, и метода **просмотра правил** , можно получить представление о том, как создавать собственные пользовательские правила.  

Более подробные сведения о правилах утверждений и шаблонах правил утверждений см. [в разделе роль правил утверждений](The-Role-of-Claim-Rules.md).  

## <a name="understanding-the-components-of-the-claim-rule-language"></a>Основные сведения о компонентах языка правил утверждений  
Язык правил утверждений состоит из следующих компонентов, разделенных оператором "= >":  

-   Условие  

-   Оператор выдачи  

### <a name="conditions"></a>Условия  
Условия в правиле можно использовать для проверки входных утверждений и определения того, следует ли выполнять инструкцию выдачи правила. Условие представляет логическое выражение, которое должно быть оценено как истинное для выполнения части тела правила. Если эта часть отсутствует, предполагается логическое значение true. то есть тело правила всегда выполняется. Часть условий содержит список условий, Объединенных вместе с логическим оператором ("& &"). Все условия в списке должны оцениваться как истинные, чтобы вся Условная часть была оценена как истинная. Условие может быть либо оператором выбора утверждений, либо вызовом агрегатной функции. Эти два являются взаимоисключающими, а это означает, что селекторы и агрегатные функции не могут быть объединены в части условий одного правила.  

Условия являются необязательными в правилах. Например, следующее правило не имеет условия:  

```  
=> issue(type = "http://test/role", value = "employee");  
```  

Существует три типа условий.  

-   Единственное условие — это простейшая форма условия. Проверки выполняются только для одного выражения; Например, имя учетной записи Windows = домен пользователь.  

-   Несколько условий — это условие требует дополнительных проверок для обработки нескольких выражений в теле правила. Например, имя учетной записи Windows = домен пользователь и группа = контосопурчасерс.  

> [!NOTE]  
> Существует другое условие, но оно является подмножеством одного или нескольких условий. Он называется условием регулярного выражения (Regex). Он используется для получения входного выражения и сопоставления выражения с заданным шаблоном. Ниже приведен пример того, как это можно использовать.  

В следующих примерах показаны некоторые конструкции синтаксиса, основанные на типах условий, которые можно использовать для создания настраиваемых правил.  

#### <a name="single--condition-examples"></a>Примеры с одним условием  
В следующей таблице описаны условия с одним выражением. Они создаются для простого поиска утверждения с указанным типом утверждения или для утверждения с указанным типом утверждения и значением утверждения.  


|                                                                                                                   Описание условия                                                                                                                    |                           Пример синтаксиса Condition                            |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
|               Это правило имеет условие для проверки наличия входящего утверждения с указанным типом утверждения ("<http://test/name>"). Если соответствующее утверждение находится во входных утверждениях, правило копирует соответствующее утверждение или утверждения в набор выходных утверждений.               |         ``` c: [type == "http://test/name"] => issue(claim = c );```          |
| Это правило имеет условие для проверки наличия входящего утверждения с указанным типом утверждения ("<http://test/name>") и значением утверждения ("Терри"). Если соответствующее утверждение находится во входных утверждениях, правило копирует соответствующее утверждение или утверждения в набор выходных утверждений. | ``` c: [type == "http://test/name", value == "Terry"] => issue(claim = c);``` |

Более сложные условия показаны в следующем разделе, включая условия для проверки нескольких утверждений, условия для проверки издателя утверждения, а также условия для проверки значений, соответствующих шаблону регулярного выражения.  

#### <a name="multiple--condition-examples"></a>Примеры с несколькими условиями  
В следующей таблице приведен пример условий с несколькими выражениями.  


|                                                                                                                   Описание условия                                                                                                                    |                                        Пример синтаксиса Condition                                        |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| Это правило содержит условие для проверки наличия двух входящих утверждений, каждый из которых указанный тип утверждения («<http://test/name> «и» <http://test/email>"). Если два соответствующих утверждения входят в входящие утверждения, правило копирует утверждение имени в набор выходных утверждений. | ``` c1: [type  == "http://test/name"] && c2: [type == "http://test/email"] => issue (claim  = c1 );``` |

#### <a name="regular--condition-examples"></a>Примеры регулярных условий  
В следующей таблице приведен пример регулярного условия на основе выражения.  

|Описание условия|Пример синтаксиса Condition|  
|-------------------------|----------------------------|  
|Это правило имеет условие, которое использует регулярное выражение для проверки того, что утверждение электронной почты заканчивается на "@fabrikam.com". Если соответствующее утверждение найдено во входных утверждениях, оно копирует соответствующее утверждение в набор исходящих утверждений.|```c: [type  == "http://test/email", value  =~ "^. +@fabrikam.com$" ] => issue (claim  = c );```|  

### <a name="issuance-statements"></a>Операторы выдачи  
Пользовательские правила обрабатываются на основе инструкций выдачи (*выдачи* или *добавления* ), которые запрограммированы в правиле утверждений. В зависимости от желаемого результата в правило можно записать инструкцию вопроса или инструкцию Add, чтобы заполнить набор входящих утверждений или набор исходящих утверждений. Пользовательское правило, использующее инструкцию Add, явным образом заполняет значения утверждений только для набора входных утверждений, в то время как настраиваемое правило утверждения, использующее инструкцию Issue, заполняет значения утверждения как в наборе входящих утверждений, так и в наборе исходящих утверждений. Это может быть полезно, если значение утверждения должно использоваться только в будущих правилах набора правил утверждений.  

Например, на следующем рисунке входящее утверждение добавляется во входное утверждение, заданное подсистемой выдачи утверждений. При выполнении первого настраиваемого правила утверждения и соблюдении критериев пользователя домена механизм выдачи утверждений обрабатывает логику в правиле с помощью инструкции Add, а значение **Editor** добавляется в набор входных утверждений. Так как значение Editor содержится в наборе входящих утверждений, правило 2 может успешно обработать инструкцию Issue в своей логике и создать новое значение **Hello**, которое добавляется в набор выходных исходящих заявок и в набор входных утверждений для использования следующим правилом в наборе правил. Правило 3 теперь может использовать все значения, представленные во входном утверждении, в качестве входных данных для обработки своей логики.  

![Роли AD FS](media/adfs2_customrule.gif)  

#### <a name="claim-issuance-actions"></a>Действия по выдаче утверждений  
Текст правила представляет действие выдачи утверждения. Существует два действия выдачи заявки, распознаваемые языком:  

-   **Оператор Issue:** Инструкция Issue создает утверждение, которое передается на входные и выходные наборы утверждений. Например, следующая инструкция выдает новое утверждение на основе набора входящих заявок:  

    ```c:[type == "Name"] => issue(type = "Greeting", value = "Hello " + c.value);```  

-   **Добавить инструкцию:** Инструкция Add создает новое утверждение, которое добавляется только в коллекцию набора входящих утверждений. Например, следующая инструкция добавляет новое утверждение в набор входных утверждений:  

    ```c:[type == "Name", value == "domain user"] => add(type = "Role", value = "Editor");``` 

Инструкция выдачи правила определяет, какие утверждения будут выдаваться правилом при сопоставлении условий. Существует две формы операторов выдачи, касающихся аргументов и поведения инструкции:  

-   **Обычный**— обычные операторы выдачи могут выдавать заявки с помощью литеральных значений в правиле или значений из утверждений, соответствующих условиям. Обычная инструкция выдачи может состоять из одного или обоих следующих форматов:  

    -   *Копия утверждения*. копия утверждения создает копию существующего утверждения в наборе исходящих утверждений. Эта форма выдачи имеет смысл только в том случае, если она сочетается с оператором выдачи "проблема". Если он сочетается с оператором выдачи "Add", он не оказывает никакого влияния.  

    -   *Новое утверждение*. Этот формат создает новое утверждение с учетом значений для различных свойств утверждения. Необходимо указать тип утверждения. все остальные свойства утверждений являются необязательными. Порядок аргументов для этой формы не учитывается.  

-   **Хранилище атрибутов**— в этой форме создаются утверждения со значениями, полученными из хранилища атрибутов. Можно создать несколько типов утверждений с помощью одного оператора выдачи, который важен для хранилищ атрибутов, которые выполняют операции ввода-вывода в сети или на диске при извлечении атрибутов. Поэтому желательно ограничить количество циклов обработки между ядром политики и хранилищем атрибутов. Также можно создать несколько утверждений для данного типа утверждения. Если хранилище атрибутов возвращает несколько значений для данного типа утверждения, то инструкция выдачи автоматически создает утверждение для каждого возвращенного значения утверждения. Реализация хранилища атрибутов использует аргументы Param для замены заполнителей в аргументе запроса значениями, предоставленными в аргументах параметров. Заполнители используют тот же синтаксис, что и функция .NET String. Format () (например, {1}, {2}и т. д.). Порядок аргументов этой формы имеет важное значение, и он должен быть указан в следующей грамматике.  

В следующей таблице описаны некоторые распространенные конструкции синтаксиса для обоих типов операторов выдачи в правилах утверждений.  

|Тип инструкции выдачи|Описание инструкции выдачи|Пример синтаксиса инструкции выдачи|  
|---------------------------|----------------------------------|-------------------------------------|  
|Обычный|Следующее правило всегда создает одно и то же утверждение, когда пользователь имеет указанный тип утверждения и значение:|```c: [type  == "http://test/employee", value  == "true"] => issue (type = "http://test/role", value = "employee");```|  
|Обычный|Следующее правило преобразует один тип утверждения в другой. Обратите внимание, что в инструкции выдачи используется значение утверждения, соответствующее условию "c".|```c: [type  == "http://test/group" ] => issue (type  = "http://test/role", value  = c.Value );```|  
|Хранилище атрибутов|Следующее правило использует значение входящего утверждения для запроса хранилища Active Directory атрибутов:|```c: [Type  == "http://test/name" ] => issue (store  = "Enterprise AD Attribute Store", types  =  ("http://test/email" ), query  = ";mail;{0}", param  = c.Value )```|  
|Хранилище атрибутов|Следующее правило использует значение входящего утверждения для запроса ранее настроенного хранилища атрибутов язык SQL (SQL):|```c: [type  == "http://test/name"] => issue (store  = "Custom SQL store", types  =  ("http://test/email","http://test/displayname" ), query  = "SELECT mail, displayname FROM users WHERE name ={0}", param  = c.value );```|  

#### <a name="expressions"></a>Выражения  
Выражения в правой части используются как для ограничений селектора утверждений, так и для параметров инструкции выдачи. Существует несколько типов выражений, поддерживаемых языком. Все выражения на языке основаны на строках, то есть они принимают строки в качестве входных данных и создают строки. Числа или другие типы данных, такие как Дата и время, в выражениях не поддерживаются. Ниже приведены типы выражений, поддерживаемых языком:  

-   Строковый литерал: строковое значение, разделенное символом кавычки (") на обеих сторонах.  

-   Объединение строк выражений. результатом является строка, созданная путем объединения значений левого и правого.  

-   Вызов функции: функция идентифицируется по идентификатору, а параметры передаются в виде разделенного запятыми списка выражений, заключенных в квадратные скобки ("()").  

-   Доступ к свойствам утверждения в виде имени переменной имя свойства DOT: результат значения указанного свойства утверждения для указанной переменной оценки. Переменная должна быть сначала привязана к селектору утверждений, прежде чем ее можно будет использовать таким образом. Недопустимо использовать переменную, привязанную к селектору утверждений, в пределах ограничений для этого селектора утверждений.  

Для доступа доступны следующие свойства утверждений.  

-   Утверждение. тип  

-   Утверждение. значение  

-   Заявка. Issuer  

-   Утверждение. OriginalIssuer  

-   ClaimSet. ValueType  

-   Заявка. свойства\[свойство\_имя\] (это свойство возвращает пустую строку, если свойство _name не найдено в коллекции свойств утверждения. )  

Для вызова внутри выражения можно использовать функцию Режексреплаце. Эта функция принимает входное выражение и сопоставляет его с заданным шаблоном. Если шаблон соответствует, выходные данные соответствия заменяются замещающим значением.  

#### <a name="exists-functions"></a>Функции Exists  
Функцию EXISTS можно использовать в условии, чтобы определить, существует ли утверждение, совпадающее с условием в наборе входящих утверждений. Если существует соответствующее утверждение, оператор выдачи вызывается только один раз. В следующем примере утверждение "источник" выдается только один раз — при наличии хотя бы одного утверждения в коллекции набора входных утверждений, у которого для издателя задано значение "MSFT", независимо от количества заявок, для которых установлен поставщик "MSFT". Использование этой функции предотвращает выдачу повторяющихся утверждений.  

```  
exists([issuer == "MSFT"])  
   => issue(type = "origin", value = "Microsoft");  
```  

## <a name="rule-body"></a>Тело правила  
Тело правила может содержать только один оператор выдачи. Если условия используются без использования функции Exists, тело правила выполняется один раз для каждого совпадения части условий.  

## <a name="additional-references"></a>Дополнительная справка  
[Создание правила для отправки утверждений с помощью настраиваемого правила](https://technet.microsoft.com/library/dd807049.aspx)  



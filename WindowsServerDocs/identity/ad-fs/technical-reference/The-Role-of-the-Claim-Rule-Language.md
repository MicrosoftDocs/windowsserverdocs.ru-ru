---
title: Роль языка правил утверждений
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 07/07/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.assetid: dda9d148-d72f-4bff-aa2a-f2249fa47e4c
ms.technology: identity-adfs
ms.openlocfilehash: 05728f04f6fb924cf3793bc843df3832c7c383f7
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59855695"
---
>Область применения. Windows Server 2016, Windows Server 2012 R2, Windows Server 2012

# <a name="the-role-of-the-claim-rule-language"></a>Роль языка правил утверждений
Службы федерации Active Directory (AD FS) утверждения языка правил выступает в роли администратора стандартных блоков для поведения входящие и исходящие утверждения, хотя модуль утверждений действует как ядро обработки для логики языка правил утверждений, Определяет настраиваемое правило. Дополнительные сведения о том, как все правила обрабатываются модулем утверждений, см. в разделе [The Role of the Claims Engine](The-Role-of-the-Claims-Engine.md).  
  
## <a name="creating-custom-claim-rules-using-the-claim-rule-language"></a>Создание настраиваемых правил утверждений с помощью языка правил утверждений  
AD FS предоставляет администраторам возможность определения настраиваемых правил, которые они могут использовать для определения поведения идентификационные утверждения с помощью языка правил утверждений. Примерах синтаксиса языка правил утверждений в этом разделе можно использовать для создания настраиваемого правила, которое перечисляет, добавляет, удаляет и изменяет утверждений в соответствии с потребностями вашей организации. Можно создавать настраиваемые правила, введя в синтаксиса языка правил утверждений в **Отправка утверждений с помощью пользовательских утверждений** шаблон правила.  
  
Правила отделяются друг от друга точкой с запятой.  
  
Дополнительные сведения об использовании настраиваемых правил см. в разделе [когда следует использовать настраиваемое правило утверждения](When-to-Use-a-Custom-Claim-Rule.md).  
  
## <a name="using-claim-rule-templates-to-learn-about-the-claim-rule-language-syntax"></a>С помощью шаблонов правил для утверждений, чтобы узнать о синтаксиса языка правил утверждений  
Службы федерации Active Directory также предоставляет набор предопределенных утверждений выдачи и утверждений, правила утверждений, которые можно использовать для реализации распространенных шаблонов правил для принятия. В **изменение правил для утверждений** диалоговое окно для отношения доверия, можно создать это предопределенное правило и просмотреть синтаксиса языка правил утверждений, составляющие этого правила —, нажав кнопку **Просмотр языка правила** вкладка для этого правила. Используя сведения в этом разделе и **Просмотр языка правила** технология могут помочь понять о создании собственных правил.  
  
Более подробные сведения о правилах утверждений и шаблонов правил для утверждений, см. в разделе [The Role of Claim Rules](The-Role-of-Claim-Rules.md).  
  
## <a name="understanding-the-components-of-the-claim-rule-language"></a>Основные сведения о компонентах языка правил утверждений  
Язык правил утверждений состоит из следующих компонентов, разделенных точкой "= >» оператор:  
  
-   Условие  
  
-   Заявление на размещение  
  
### <a name="conditions"></a>Условия  
Можно использовать условия в правиле для проверки входящих утверждений и определить, следует ли выполнять инструкцию выдачи правила. Условие представляет логическое выражение, которое должно вычисляться в значение true, для выполнения части текста правила. Если эта часть не указано, предполагается, что логическое значение true; то есть всегда выполняется тело правила. Часть условия содержит список условий, которые были объединены вместе с совместно логический оператор ("& &»). Все условия в списке должен быть равен true для части совершенно условного вычисляемое значение true. Условие может быть вызов агрегатной функции или оператора выбора утверждений. Эти два являются взаимоисключающими, это означает, что эту заявку, селекторы и агрегатные функции нельзя использовать вместе в части условия одного правила.  
  
Условия являются необязательными в правилах. Например следующее правило имеет условия:  
  
```  
=> issue(type = "http://test/role", value = "employee");  
```  
  
Существует три типа условий:  
  
-   Единый условие — это самая простая форма условие. Проверки выполняются только одного выражения; Например, имя учетной записи windows = пользователя домена.  
  
-   Несколько условие — это условие требует дополнительные проверки для обработки нескольких выражений в тексте правила; Например, имя учетной записи windows = пользователь домена и группы = contosopurchasers.  
  
> [!NOTE]  
> Существует еще одно условие, но он является подмножеством одно условие или несколько условий. Она называется условие регулярных выражений (Regex). Он используется входное выражение и соответствовать выражению с заданным шаблоном. Можно использовать пример того, как показано ниже.  
  
Ниже приведены примеры небольшая часть конструкции синтаксиса, которые основаны на типы условий, можно использовать для создания настраиваемых правил.  
  
#### <a name="single--condition-examples"></a>Один - условие, примеры  
Один - выражение условия описаны в следующей таблице. Они построены, просто установите для утверждения с типом указанного утверждения или для утверждения с типом указанного утверждения и значение утверждения.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило содержит условие для проверки входное утверждение с заданным типом утверждения (» http://test/name"). Если соответствующее утверждение входящих утверждений, правило копирует соответствующее утверждение или утверждения для выходного набора утверждений.|``` c: [type == "http://test/name"] => issue(claim = c );```|  
|Это правило содержит условие для проверки входное утверждение с заданным типом утверждения (» http://test/name") и значение («Александр») утверждения. Если соответствующее утверждение входящих утверждений, правило копирует соответствующее утверждение или утверждения для выходного набора утверждений.|``` c: [type == "http://test/name", value == "Terry"] => issue(claim = c);```|  
  
Более - сложные условия, отображаются в следующем разделе, включая условия, чтобы проверить несколько утверждений, условия для проверки издателя утверждения и условия для проверки значений, соответствующих шаблону регулярного выражения.  
  
#### <a name="multiple--condition-examples"></a>Несколько - примеры условие  
В следующей таблице приведены пример нескольких - выражение условий.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило содержит условие для проверки наличия двух входящих утверждений, каждый из которых указанный тип утверждения (« http://test/name«и» http://test/email"). Если два соответствующих утверждений входящие утверждения, правило копирует утверждение имени для выходного набора утверждений.|``` c1: [type  == "http://test/name"] && c2: [type == "http://test/email"] => issue (claim  = c1 );```|  
  
#### <a name="regular--condition-examples"></a>Регулярные - условие, примеры  
Ниже приведен пример регулярное, выражение-на основе условия.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило содержит условие, которое использует регулярное выражение для проверки для e-утверждения электронной почты, заканчивающиеся на "@fabrikam.com«. Если соответствующее утверждение найдено в входящих утверждений, правило копирует соответствующее утверждение в выходной набор утверждений.|```c: [type  == "http://test/email", value  =~ "^. +@fabrikam.com$" ] => issue (claim  = c );```|  
  
### <a name="issuance-statements"></a>Инструкции выдачи  
Настраиваемые правила обрабатываются в зависимости от инструкции выдачи (*проблема* или *добавить* ) программируется в правило для утверждений. В зависимости от желаемого результата, инструкция выдачи или добавьте инструкцию можно записать в правило для заполнения во входной или выходной набор утверждений. Настраиваемое правило, используется оператор добавить явным образом заполняет утверждение, что значения только для входных данных набор утверждений, а настраиваемое правило для утверждений, использующий инструкцию выдачи заполняет утверждения, значения в обоих входных данных набор утверждений и набор утверждений в выходных данных. Это может быть полезно, когда значение утверждения должен использоваться только будущие правила в наборе правил утверждений.  
  
Например на следующем рисунке, входящее утверждение добавляется во входной набор модулем утверждений выдачи утверждений. Когда выполняется первое правило пользовательского утверждения и удовлетворяет критериям пользователя домена, подсистема выдачи утверждений обрабатывает логику, в правиле, используя инструкцию add, а значение **редактор** добавляется во входной набор утверждений. Так как значение редактор присутствует в входном наборе утверждений, правило 2 можно успешно обработать инструкцию выдачи в своей логике и создать новое значение **Hello**, добавляемым к обоих выходных данных, так и для входных данных набор для использования утверждений следующее правило в наборе правил. Правило 3 теперь можно использовать все значения, которые присутствуют в входного набора утверждений в качестве входных данных для обработки логики.  
  
![Роли AD FS](media/adfs2_customrule.gif)  
  
#### <a name="claim-issuance-actions"></a>Действия выдачи утверждений  
Тело правило представляет действие выдачи утверждений. Существует два действия выдачи утверждения, которые распознает язык:  
  
-   **Выполните инструкцию:** Инструкция выдачи создает утверждение, что наборы утверждений передается входных и выходных данных. Например следующая инструкция выпускает новое утверждение, в зависимости от его во входной набор утверждений:  
  
    ```c:[type == "Name"] => issue(type = "Greeting", value = "Hello " + c.value);```  
  
-   **Добавьте инструкцию.** Добавить оператор создает новое утверждение, который добавляется только к коллекции набор входящих утверждений. Например следующая инструкция добавляет нового утверждения во входной набор утверждений:  
  
    ```c:[type == "Name", value == "domain user"] => add(type = "Role", value = "Editor");``` 
  
Инструкция выдачи правила определяет утверждения, которые будут выданный правило, при выполнении соответствующих условий. Существует два вида выдачи инструкции об аргументах и инструкции поведение:  
  
-   **Обычный**— обычный выдачи инструкций может выдавать утверждения с помощью литералов в правиле или значения из утверждений, которые соответствуют условиям. Обычный выдачи может состоять из одно или оба из следующих форматов:  
  
    -   *Утверждение копирования*: Утверждение копирования создает копию существующего утверждения в выходной наборы утверждений. Эта форма выдачи имеет смысл только при сочетании с инструкцией выдачи «проблема». Когда он объединяется с помощью инструкции выдачи «добавить», он не имеет никакого.  
  
    -   *Новое утверждение*: Этот формат создает новое утверждение, учитывая значения для различных свойств утверждения. Должен быть указан Claim.Type; все остальные утверждения свойства являются необязательными. Порядок аргументов для этой формы учитывается.  
  
-   **Атрибут Store**— Эта форма создает требования со значениями, которые извлекаются из хранилища атрибутов. Можно создать несколько типов утверждений с помощью одного выдачи инструкции, что важно для хранилищ атрибутов, которые делают сети или диска операций ввода вывода (I/O) во время извлечения атрибутов. Таким образом рекомендуется ограничить количество циклов обработки между обработчиком политик и из хранилища атрибутов. Это также можно создать несколько утверждений для данного типа утверждения. По возвращении из хранилища атрибутов несколько значений для данного типа утверждения инструкцию выдачи автоматически создает утверждение для каждого значения, возвращенного утверждения. Реализация атрибута хранилища использует аргументы param заменить заполнители в аргументе запроса с помощью значения, которые указаны в аргументах param. Заполнители используется тот же синтаксис, что и функция .NET String.Format () (например, {1}, {2}, и так далее). Важен порядок аргументов для этой формы выдачи, и он должен быть порядок что описанный в следующей грамматике.  
  
В следующей таблице описаны некоторые распространенные конструкции синтаксис для обоих типов операторов выдачи в правилах для утверждений.  
  
|Тип инструкции выдачи|Описание инструкции выдачи|Пример синтаксиса инструкции выдачи|  
|---------------------------|----------------------------------|-------------------------------------|  
|Обычный|Следующее правило всегда выдает то же утверждение, когда пользователю указанному типу утверждения и значение:|```c: [type  == "http://test/employee", value  == "true"] => issue (type = "http://test/role", value = "employee");```|  
|Обычный|Следующее правило преобразует один тип утверждения в другой. Обратите внимание на то, что значение утверждения, которое соответствует условию «c» используется в инструкции выдачи.|```c: [type  == "http://test/group" ] => issue (type  = "http://test/role", value  = c.Value );```|  
|Хранилище атрибутов|Следующее правило использует значение входящего утверждения запросить хранилище атрибутов Active Directory:|```c: [Type  == "http://test/name" ] => issue (store  = "Enterprise AD Attribute Store", types  =  ("http://test/email" ), query  = ";mail;{0}", param  = c.Value )```|  
|Хранилище атрибутов|Следующее правило использует значение входящего утверждения запросить ранее настроенное хранилище атрибутов Structured Query Language (SQL):|```c: [type  == "http://test/name"] => issue (store  = "Custom SQL store", types  =  ("http://test/email","http://test/displayname" ), query  = "SELECT mail, displayname FROM users WHERE name ={0}", param  = c.value );```|  
  
#### <a name="expressions"></a>Выражения  
Выражения используются в правой части для ограничения выбора утверждений и параметров инструкции выдачи. Существуют различные типы выражений, которые поддерживает язык. Все выражения на языке основаны на строку, что означает, что они принимают строки в качестве входных данных и создания строк. Номера или других типов данных, таких как дата и время, в выражениях не поддерживаются. Ниже приведены типы выражений, которые поддерживает язык.  
  
-   Строковый литерал: Строковое значение, разделяемых строками в качестве знака кавычки ("") с обеих сторон.  
  
-   Объединение строк выражений: Результатом является строка, созданным объединение левого и правого значений.  
  
-   Вызов функции: Функция, определяемая по идентификатору, а параметры передаются как запятую-список разделенных выражений заключена в квадратные скобки (» ()»).  
  
-   Доступ к свойству заявки в виде имени свойства ТОЧКИ имя переменной: Результат значение свойства определенного утверждения для экономического переменной. Переменная сначала должен быть привязан к селектора утверждений, прежде чем он может использоваться таким образом. Не допускается использовать переменную, которая привязана к селектор утверждений внутри ограничения для этой же селектор утверждений.  
  
Для доступа доступны следующие свойства утверждения:  
  
-   Claim.Type  
  
-   Claim.Value  
  
-   Claim.Issuer  
  
-   Claim.OriginalIssuer  
  
-   Claim.ValueType  
  
-   Claim.Properties\[свойство\_имя\] (это свойство возвращает пустую строку, если свойство _name не найден в коллекции свойств утверждения. )  
  
Можно использовать функцию RegexReplace для вызова внутри выражения. Эта функция принимает входное выражение и сопоставляет его с заданным шаблоном. Если шаблон соответствует, выходные данные сопоставления заменяется замещающим значением.  
  
#### <a name="exists-functions"></a>Существует функции  
Функция Exists можно использовать в условии для оценки ли утверждение, что совпадения условие существует во входном наборе утверждений. Если существует любой соответствующее утверждение, инструкция выдачи вызывается только один раз. В следующем примере «началом координат» утверждение выдается только один раз, если имеется хотя бы одно утверждение в коллекции набора входящее утверждение с издателя, равным «MSFT», независимо от того, сколько утверждения будут иметь издателя равным «MSFT». С помощью этой функции предотвращает повторяющиеся утверждения из его выдачи.  
  
```  
exists([issuer == "MSFT"])  
   => issue(type = "origin", value = "Microsoft");  
```  
  
## <a name="rule-body"></a>Текст правила  
Текст правила может содержать только один выдачи инструкции. Если условия используются без использования функция Exists, тексте правило выполняется один раз для каждый раз, соответствующая часть условия.  
  
## <a name="additional-references"></a>Дополнительная справка  
[Создание правила для отправки утверждений с помощью настраиваемого правила](https://technet.microsoft.com/library/dd807049.aspx)  
  


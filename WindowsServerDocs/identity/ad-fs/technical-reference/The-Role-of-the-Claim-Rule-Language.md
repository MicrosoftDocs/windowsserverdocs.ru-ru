---
title: "Роль языка правил утверждений"
description: 
author: billmath
ms.author: billmath
manager: femila
ms.date: 07/07/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.assetid: dda9d148-d72f-4bff-aa2a-f2249fa47e4c
ms.technology: identity-adfs
ms.openlocfilehash: 206da33d33cbded0450db29615dc74eb1161cbce
ms.sourcegitcommit: 84a2bdcb92ba6af45781fab9727617e50fa5e911
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/07/2017
---
>Область применения: Windows Server 2016, Windows Server 2012 R2, Windows Server 2012

# <a name="the-role-of-the-claim-rule-language"></a>Роль языка правил утверждений
Службы федерации Active Directory (AD FS) утверждений языка правил выступает в качестве администратора конструктивного блока для поведения входящие и исходящие утверждения, когда модуль утверждений действует как модуль обработки для логики языка правил утверждений, который определяет настраиваемое правило. Дополнительные сведения о том, как обрабатываются все правила модулем утверждений см. в разделе [The Role of the Claims Engine](The-Role-of-the-Claims-Engine.md).  
  
## <a name="creating-custom-claim-rules-using-the-claim-rule-language"></a>Создание пользовательских правил утверждений с помощью языка правил утверждений  
Службы федерации Active Directory предоставляет администраторам возможность определить настраиваемые правила, которые используются для определения поведения утверждений удостоверений с помощью языка правил утверждений. Примеры синтаксиса языка правил утверждений можно использовать в этом разделе для создания настраиваемого правила, которое перечисляет, добавляет, удаляет и изменяет утверждений в соответствии с потребностями вашей организации. Вы можете создать настраиваемые правила, введя в синтаксиса языка правил утверждений в **Отправка утверждений с помощью настраиваемых утверждений** шаблона правила.  
  
Правила разделяются друг от друга точкой с запятой.  
  
Дополнительные сведения об использовании настраиваемых правил см. в разделе [когда следует использовать настраиваемое правило утверждения](When-to-Use-a-Custom-Claim-Rule.md).  
  
## <a name="using-claim-rule-templates-to-learn-about-the-claim-rule-language-syntax"></a>С помощью шаблонов правил для утверждений для изучения синтаксиса языка правил утверждений  
Службы федерации Active Directory также предоставляет набор предопределенных утверждения выдачи и утверждения, что шаблоны правил принятия, которые можно использовать для реализации общие правила утверждений. В **изменение правил для утверждений** диалоговое окно для отношения доверия, можно создать предопределенное правило и просмотрите синтаксис языка правил утверждений, содержащийся в этом правиле —, щелкнув **Просмотр языка правила** вкладку для этого правила. Используя сведения в этом разделе и **Просмотр языка правила** методика можно дать представление о способах создания собственных настраиваемых правил.  
  
Дополнительные сведения о правилах утверждений и шаблонов правил для утверждений см. в разделе [роль правил утверждений](The-Role-of-Claim-Rules.md).  
  
## <a name="understanding-the-components-of-the-claim-rule-language"></a>Общее представление о компоненты языка правил утверждений  
Язык правил утверждений состоит из следующих компонентов, разделяя их точкой с» = > «оператор:  
  
-   Условие  
  
-   Инструкция выдачи  
  
### <a name="conditions"></a>Условия  
Вы можете использовать условия правила для проверки входных утверждений и определить, следует ли выполнять инструкцию выдачи правила. Условие представляет логическое выражение, которое необходимо оценить значение true, чтобы выполнить часть тела правило. Если эта часть отсутствует, предполагается логическое значение true. то есть всегда выполняется тело правило. Часть условия содержит список условий, которые объединяются вместе с логический оператор вместе («& &»). Все условия в списке должен быть равен true всего условного части для оценки значение true. Условие может быть оператора выбора утверждений или вызов статистические функции. Эти два являются взаимоисключающими, что означает, что, утверждений селекторы и статистические функции нельзя сочетать в части условия одно правило.  
  
Условия являются необязательными в правилах. Например следующее правило не имеет условие:  
  
```  
=> issue(type = "http://test/role", value = "employee");  
```  
  
Существует три типа условий:  
  
-   Один условие — это самая простая форма условие. Проверки выполняются только один выражение; Например, имя учетной записи windows = пользователя домена.  
  
-   Несколько условий, требующем дополнительных проверок для обработки нескольких выражений в теле правило; Например, имя учетной записи windows = домена пользователя и группы = contosopurchasers.  
  
> [!NOTE]  
> Существует еще одно условие, но это подмножество условие один или несколько условий. Он называется условие регулярных выражений (Regex). Он используется для ввода выражения и совпадает с выражением с заданному шаблону. Можно использовать пример того, как показано ниже.  
  
В следующих примерах показано несколько конструкций синтаксис, которые основаны на типы условий, что можно использовать для создания настраиваемых правил.  
  
#### <a name="single--condition-examples"></a>Один - условие примеры  
Один - выражение условия описаны в следующей таблице. Они имеют иерархическую структуру для просто проверки для утверждения в указанный тип утверждения или утверждения с указанный тип утверждения и значение утверждения.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило содержит условие, чтобы проверить наличие входное утверждение с указанный тип утверждения («http://test/name»). Если соответствующее утверждение ввода утверждений, правило копирует соответствующее утверждение или утверждения в выходной набор утверждений.|``` c: [type == "http://test/name"] => issue(claim = c );```|  
|Это правило содержит условие для проверки наличия входное утверждение с указанный тип утверждения («http://test/name») и утверждения на значение («Иван»). Если соответствующее утверждение ввода утверждений, правило копирует соответствующее утверждение или утверждения в выходной набор утверждений.|``` c: [type == "http://test/name", value == "Terry"] => issue(claim = c);```|  
  
Более - сложных условий отображаются в следующем разделе, включая условия, чтобы проверить наличие нескольких утверждений условия, чтобы проверить издателя утверждения условия и для проверки значений, соответствующих регулярному выражению.  
  
#### <a name="multiple--condition-examples"></a>Примеры нескольких - условие  
В следующей таблице приведены пример нескольких - условий выражения.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило содержит условие для проверки двух ввода утверждений, имеющих указанный тип утверждения («http://test/name» и «http://test/email»). Если два соответствующие утверждения в ввода утверждений, правило копирует имя утверждение в выходной наборы утверждений.|``` c1: [type  == "http://test/name"] && c2: [type == "http://test/email"] => issue (claim  = c1 );```|  
  
#### <a name="regular--condition-examples"></a>Регулярное - условие примеры  
Ниже приводится пример, выражение-на основе условия.  
  
|Описание условия|Пример синтаксиса условие|  
|-------------------------|----------------------------|  
|Это правило имеет условие, которое использует регулярное выражение для проверки для e-утверждения почты заканчивается в «@fabrikam.com». Если найден соответствующее утверждение в ввода утверждений, правило копирует соответствующее утверждение в выходной набор утверждений.|```c: [type  == "http://test/email", value  =~ "^. +@fabrikam.com$" ] => issue (claim  = c );```|  
  
### <a name="issuance-statements"></a>Инструкции выдачи  
Настраиваемые правила, обрабатываются в зависимости от инструкции выдачи (*проблему* или *добавить* ) программирования в правило утверждения. В зависимости от желаемого результата, инструкция выдачи или добавить инструкции, которые могут быть записаны в правило, чтобы заполнить во входной набор утверждений или выходной наборы утверждений. Настраиваемое правило, используется оператор добавить явно заполняет утверждения, что значения только для ввода набор утверждений, когда настраиваемое правило для утверждений, инструкция выдачи использует заполняет утверждения, значения, как во входной набор утверждений и в выходной набор утверждений. Это полезно в том случае, когда значение утверждения предназначено для использования только в будущем правил в наборе правил утверждений.  
  
Например на следующем рисунке входящего утверждения добавляется во входной набор утверждений подсистемой выдачи утверждений. Когда выполняется первое правило пользовательских утверждений и выполнено критериям пользователя домена, подсистема выдачи утверждений обрабатывает логику, в правило, с помощью добавить оператор и значение **редактор** добавляется во входной набор утверждений. Поскольку значение редактор присутствует в во входной набор утверждений, правило 2 могут успешно обработать инструкцию выдачи в своей логике и создавать новое значение **Hello**, что добавлены обоих в выходной набор утверждений и входной набор утверждений для использования с помощью следующего правила в правиле. Правило 3 теперь можно использовать все значения, которые присутствуют в из входного набора утверждений, в качестве входных данных для обработки логики.  
  
![Роли AD FS](media/adfs2_customrule.gif)  
  
#### <a name="claim-issuance-actions"></a>Действия выдачи утверждений  
Правило основной текст представляет действие выдачи утверждений. Существует два действия выдачи утверждений, которые распознает языка:  
  
-   **Выполните инструкцию:** создает инструкцию выдачи утверждений, что переходит входной и выходной наборы утверждений. Например следующий оператор выдает новое утверждение, в зависимости от его входной набор утверждений:  
  
    ```c:[type == "Name"] => issue(type = "Greeting", value = "Hello " + c.value);```  
  
-   **Добавьте оператор:** инструкция add создает новое утверждение, добавляются только коллекции набор входящих утверждений. Например следующий оператор добавляет новый утверждения во входной набор утверждений:  
  
    ```c:[type == "Name", value == "domain user"] => add(type = "Role", value = "Editor");``` 
  
Определяет инструкцию выдачи правила утверждения, которые будут выпустившего с помощью данного правила, соответствующие условиям. Существует два вида выдачи инструкции относительно аргументы и поведение оператора.  
  
-   **Обычный**— обычный выдачи операторы могут выдавать утверждения с помощью литеральные значения в правиле или значений утверждений, которые соответствуют условиям. Инструкция выдачи обычный может содержать один или оба из следующих форматов:  
  
    -   *Утверждения копирования*: копирования утверждения создает копию существующего утверждения в выходной набор утверждений. Эта форма выдачи имеет смысл только вместе с инструкцию выдачи «выдачи». Когда оно объединено с инструкцию выдачи «Добавление», не иметь никакого эффекта.  
  
    -   *Новое утверждение*: это формат reates новое утверждение, присвоенные значения утверждений, различные свойства. Должен быть указан Claim.Type; все остальные свойства утверждений являются необязательными. Порядок аргументов для этой формы игнорируется.  
  
-   **Хранилища атрибутов**— в этой форме создает утверждений с помощью значений, извлекаемых из хранилища атрибутов. Можно создать несколько типов утверждений, используя выражение одного выпуска, что важно для хранилищ атрибутов, которые делают сети или диска операций ввода вывода (I/O) во время извлечения атрибута. Таким образом желательно ограничить число циклов передачи между модуль политики и хранилище атрибутов. Допустимо также создать несколько утверждений для утверждений для данного типа. При возвращении к хранилищу атрибутов несколько значений для типа утверждения для конкретного инструкцию выдачи автоматически создает утверждения для каждого значения возвращенный утверждения. Реализация хранилища атрибутов использует аргументы param для замены заполнители в аргументе запроса со значениями, которые предоставляются в param аргументы. Тот же синтаксис использовать заполнители в качестве функции .NET String.Format () (например, {1}, {2} и т. д). Порядок аргументы для выдачи в этой форме, и он должен быть порядок, который описанный в следующей грамматической конструкции.  
  
В следующей таблице описаны некоторые распространенные конструкции синтаксис для обоих типов инструкции выдачи в правилах для утверждений.  
  
|Тип инструкции выдачи|Описание инструкция выдачи|Пример синтаксиса инструкция выдачи|  
|---------------------------|----------------------------------|-------------------------------------|  
|Норм.|Следующее правило выдает всегда же утверждения, каждый раз, когда пользователь имеет указанный тип утверждения и значение:|```c: [type  == "http://test/employee", value  == "true"] => issue (type = "http://test/role", value = "employee");```|  
|Норм.|Следующее правило преобразует одного типа утверждения в другой. Обратите внимание, что значения утверждения, которое соответствует условие «c» используется в инструкцию выдачи.|```c: [type  == "http://test/group" ] => issue (type  = "http://test/role", value  = c.Value );```|  
|Хранилища атрибутов|Следующее правило использует значение входящего утверждения запросить хранилище атрибутов Active Directory:|```c: [Type  == "http://test/name" ] => issue (store  = "Enterprise AD Attribute Store", types  =  ("http://test/email" ), query  = ";mail;{0}", param  = c.Value )```|  
|Хранилища атрибутов|Следующее правило использует значение входящего утверждения запросить хранилище атрибутов с ранее настроенного языка структурированных запросов (SQL):|```c: [type  == "http://test/name"] => issue (store  = "Custom SQL store", types  =  ("http://test/email","http://test/displayname" ), query  = "SELECT mail, displayname FROM users WHERE name ={0}", param  = c.value );```|  
  
#### <a name="expressions"></a>Выражения  
Использовать выражения справа для ограничения селектора утверждений и параметров инструкции выдачи. Существуют различные типы выражений, которые поддерживает язык. Все выражения на языке основаны на строку, что означает, что они принимают строки в качестве входных данных и создания строк. Номера и другие типы данных, например дату и время в выражениях не поддерживаются. Ниже приведены типы выражений, которые поддерживает язык:  
  
-   Строкового литерала: строковое значение, разделенных кавычки ("), с обеих сторон.  
  
-   Объединение выражений строк: результат — это строка, предоставляемое объединение значений влево и вправо.  
  
-   Вызов функции: функция определяется идентификатор и параметры передаются в виде запятой-список с разделителями выражения в квадратные скобки («()»).  
  
-   Доступ к свойству утверждения в форме имени свойства точка имя переменной: результат значение свойства определенных утверждений для данного переменной оценки. Переменная сначала должна быть привязана к селектора утверждений, прежде чем можно будет использовать таким образом. Недопустимо использовать переменную, привязанный к селектором утверждений внутри ограничения для этой же селектора утверждений.  
  
Для доступа к доступны следующие свойства утверждений:  
  
-   Claim.Type  
  
-   Claim.Value  
  
-   Claim.Issuer  
  
-   Claim.OriginalIssuer  
  
-   Claim.ValueType  
  
-   Claim.Properties\[property\_name\] (это свойство возвращает пустую строку, если свойство _name не удается найти в коллекцию свойств утверждения. )  
  
Функция RegexReplace вызовите внутри выражения. Эта функция использует выражение ввода и соответствует заданному шаблону. При совпадении шаблона, выходные данные соответствия заменяется значением замены.  
  
#### <a name="exists-functions"></a>Существует функции  
Существует функция может использоваться в условие для оценки соответствия, сопоставления, которые достаточно во входной набор утверждений утверждения. Если существует любой соответствующее утверждение, инструкция выдачи вызывается только один раз. В следующем примере «источник» утверждение выдается только один раз — при наличии хотя бы одно утверждение в коллекции набор входящих утверждений с поставщиком, значение «MSFT», независимо от того, сколько утверждения могут издатель значение «MSFT». С помощью этой функции предотвращает повторяющиеся утверждений по выдаче.  
  
```  
exists([issuer == "MSFT"])  
   => issue(type = "origin", value = "Microsoft");  
```  
  
## <a name="rule-body"></a>Правило текст  
Текст правило может содержать только один выдачи инструкции. Если условия используются без использования функции Exists, тело правило выполняется один раз для каждый раз при совпадении часть условий.  
  
## <a name="additional-references"></a>Дополнительные ссылки  
[Создание правила для отправки утверждений с помощью настраиваемого правила](https://technet.microsoft.com/library/dd807049.aspx)  
  


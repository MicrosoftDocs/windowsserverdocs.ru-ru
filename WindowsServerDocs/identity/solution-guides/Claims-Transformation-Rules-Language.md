---
ms.assetid: e831f781-3c45-4d44-b411-160d121d1324
title: Язык правил преобразования утверждений
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adds
ms.openlocfilehash: a1f5c724d041a9f64c3b2697a8b5acd17a2a7bd9
ms.sourcegitcommit: eaf071249b6eb6b1a758b38579a2d87710abfb54
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/31/2019
ms.locfileid: "66445813"
---
# <a name="claims-transformation-rules-language"></a>Язык правил преобразования утверждений

>Область применения. Windows Server 2016, Windows Server 2012 R2, Windows Server 2012

Между лесами утверждений включает функцию преобразования для моста утверждений для динамического контроля доступа через границы лесов путем установки политик преобразования утверждений для отношения доверия между лесами. Основным компонентом для всех политик — правила, которые написаны на языке правил преобразования утверждений. В этом разделе содержатся сведения об этом языке и руководство о создании правила преобразования утверждений.  
  
Командлеты Windows PowerShell для политики преобразования на между лесами доверяет установить параметры, чтобы установить простые политики, которые являются обязательные в распространенных сценариях. Эти командлеты преобразует входные данные пользователя в политиках и правилах в язык правил преобразования утверждений и затем сохранять их в Active Directory в указанном формате. Дополнительные сведения о командлетах для преобразования утверждений см. в разделе [командлеты AD DS для динамического контроля доступа](https://go.microsoft.com/fwlink/?LinkId=243150).  
  
В зависимости от конфигурации утверждений и требований на отношение доверия между лесами в лесах Active Directory политик преобразования утверждений может потребоваться более сложные, чем политикам, поддерживаемым командлеты Windows PowerShell для Active Каталог. Для эффективного создания таких политик, очень важно для понимания синтаксиса языка правил преобразования утверждений и семантику. Это утверждения, язык правил преобразования («язык») в Active Directory — это подмножество языка, который используется [служб федерации Active Directory](https://go.microsoft.com/fwlink/?LinkId=243982) для похожих целей и он имеет очень похожа синтаксиса и семантики. Тем не менее существует меньше операций, разрешенных и дополнительные возможности синтаксиса ограничения, помещаются в Active Directory версию языка.  
  
В этом разделе приводится краткое описание синтаксиса и семантики языка правил преобразования утверждений в Active Directory и рекомендации, которые необходимо учитывать при создании политики. Он предоставляет несколько наборов правил пример для начала работы и примеры неверный синтаксис и сообщения, которые они создают, которые помогут расшифровать сообщения об ошибках при создании правила.  
  
## <a name="tools-for-authoring-claims-transformation-policies"></a>Средства для создания политик преобразования утверждений  
**Командлеты Windows PowerShell для Active Directory**: Это предпочтительный и рекомендуемый способ создания и задать политики преобразования утверждений. Эти командлеты укажите параметры для простой политики и проверить правила, заданные для более сложных политик.  
  
**LDAP**: Политики преобразования утверждений можно изменить в Active Directory через Lightweight Directory Access Protocol (LDAP). Тем не менее это не рекомендуется, поскольку политики имеют несколько сложных компонентов и средств, которые можно использовать не может проверить политику перед записью в Active Directory. Впоследствии для этого может потребоваться значительное время для диагностики проблем.  
  
## <a name="active-directory-claims-transformation-rules-language"></a>Язык правил преобразования утверждений Active Directory  
  
### <a name="syntax-overview"></a>Общие сведения о синтаксисе  
Ниже приведен краткий обзор синтаксиса и семантики языка.  
  
-   Набор правил преобразования утверждений состоит из нуля или нескольких правил. Каждое правило состоит из двух частей active: **Выберите список условий** и **Rule Action**. Если **выберите список условий** имеет значение TRUE, выполняется соответствующее действие правила.  
  
-   **Выберите список условий** имеет ноль или более **выберите условия**. Все **выберите условия** должны иметь значение TRUE для **выберите список условий** чтобы иметь значение TRUE.  
  
-   Каждый **выбрать условие** имеет набор из нуля или более **условия, соответствующие**. Все **условия, соответствующие** должны иметь значение TRUE для условия выберите иметь значение TRUE. Все эти условия анализируются с использованием одно утверждение. Утверждение, которое соответствует **выбрать условие** можно пометить **идентификатор** и упомянутых в **действие правила**.  
  
-   Каждый **условие соответствия** указывает условие, проверяемое **тип** или **значение** или **ValueType** утверждения с помощью разных  **Условие операторы** и **строковые литералы**.  
  
    -   При указании **условие соответствия** для **значение**, необходимо также указать **условие соответствия** для конкретного **ValueType** и наоборот. Эти условия должны находиться рядом друг с другом в синтаксис.  
  
    -   **ValueType** соответствующие условия должны использовать определенные **ValueType** только литералы.  
  
-   Объект **действие правила** можно скопировать одно утверждение, помеченная **идентификатор** или выдавать одно утверждение, в зависимости от утверждение, помеченная идентификатор или учитывая строковых литералов.  
  
**Пример правила**  
  
В этом примере показано правило, которое может использоваться для преобразования типа утверждений между лесами, в условии, что они используют те же утверждения ValueTypes и иметь же интерпретаций утверждений значения для этого типа. Правило содержит одно условие сопоставления и инструкцию проблема, которую использует строковые литералы и ссылкой на сопоставления утверждений.  
  
```  
C1: [TYPE=="EmployeeType"]    
                 => ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE);  
[TYPE=="EmployeeType"] == Select Condition List with one Matching Condition for claims Type.  
ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE) == Rule Action that issues a claims using string literal and matching claim referred with the Identifier.  
  
```  
  
### <a name="runtime-operation"></a>Операция времени выполнения  
Важно понимать работу среды выполнения преобразования утверждений, чтобы эффективно создавать правила. Операция времени выполнения используется три набора заявок:  
  
1.  **Входящих утверждений набора**: Входной набор утверждений, на которые указывает на операцию преобразования утверждений.  
  
2.  **Рабочий набор утверждений**: Промежуточные утверждения, которые считываются из и в записываемый во время преобразования утверждений.  
  
3.  **Исходящих утверждений набора**: Выходные данные операции преобразования утверждений.  
  
Ниже приведен краткий обзор среды выполнения операции преобразования утверждений:  
  
1.  Входящих утверждений для преобразования утверждений используются для инициализации рабочего набора утверждений.  
  
    1.  При обработке каждого правила, рабочий набор утверждений используется для входящих утверждений.  
  
    2.  Список условий выбора в правиле противопоставляется все возможные наборы утверждений из рабочего набора утверждений.  
  
    3.  Чтобы выполнить действие, в нем используется каждого набора соответствующих утверждений.  
  
    4.  Выполнение результатов действий правила в одно утверждение, который добавляется в выходные данные утверждений, набор и рабочий набор утверждений. Таким образом выходные данные из правила используется в качестве входных данных для последующих правил в наборе правил.  
  
2.  Правила в наборе правил обрабатываются в последовательном порядке, начиная с первого правила.  
  
3.  При обработке набора правил всей выходного набора утверждений обрабатывается для удаления повторяющихся утверждений и других проблем безопасности. Итоговый утверждения — это выходные данные процесса преобразования утверждений.  
  
Это можно написать преобразования сложных утверждений на основе прежнее поведение среды выполнения.  
  
**Пример: Операция времени выполнения**  
  
В этом примере показана операция среды выполнения, использующий два правила преобразования утверждений.  
  
```  
  
     C1:[Type=="EmpType", Value=="FullTime",ValueType=="string"] =>  
                Issue(Type=="EmployeeType", Value=="FullTime",ValueType=="string");  
     [Type=="EmployeeType"] =>   
               Issue(Type=="AccessType", Value=="Privileged", ValueType=="string");  
Input claims and Initial Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
After Processing Rule 1:  
 Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"), (Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  
After Processing Rule 2:  
Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
Final Output:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
```  
  
### <a name="special-rules-semantics"></a>Семантика специальные правила  
Ниже приведены специальный синтаксис для правила.  
  
1.  Пустой набор правил == выходные утверждения не  
  
2.  Очистить список условий выберите == совпадения каждого утверждения списке выберите условие  
  
    **Пример: Пустое условие выберите список**  
  
    Следующее правило соответствует каждого утверждения в рабочем множестве.  
  
    ```  
    => Issue (Type = "UserType", Value = "External", ValueType = "string")  
    ```  
  
3.  Очистить Выбор сопоставления список == каждого утверждения соответствует списке выберите условие  
  
    **Пример: Пустой условия сопоставления**  
  
    Следующее правило соответствует каждого утверждения в рабочем множестве. Это правило основные «Allow-all», если он используется отдельно.  
  
    ```  
    C1:[] => Issule (claim = C1);  
    ```  
  
## <a name="security-considerations"></a>Замечания по безопасности  
**Утверждения, которые входят в лес**  
  
Утверждения, представленные участников, которые являются входящие в лес нужно тщательно проверить на соответствие убедитесь, что мы разрешить или выдавать только правильные утверждения. Неправильная утверждений может нарушить безопасность леса, а это должен быть основным фактором, при создании политики преобразования утверждений, которые входят в лес.  
  
Active Directory имеет следующие возможности для предотвращения неправильной настройки утверждений, которые входят в лес.  
  
-   Если доверие леса не политикой преобразования утверждений, заданной для утверждения, которые входят в лесу, в целях безопасности Active Directory удаляет все субъекта утверждения, которые входят в лесу.  
  
-   Если выполняется набор на заявках правил, которые вводит результаты леса в утверждения, которые не определены в лесу, не определено утверждений удаляются из исходящие утверждения.  
  
**Утверждения, которые покидают лес**  
  
Утверждения, которые покидают лес предоставляют меньшее безопасности для леса важна, чем размер утверждения, которые входят в лесу. Утверждения могут оставить лесу, что — даже при наличии утверждения, не соответствующие политики преобразование на месте. Можно также выдавать утверждения, которые не определены в лесу, в процессе преобразования утверждений, которые оставляют леса. Это позволяет легко настроить отношения доверия между лесами с утверждениями. Администратор может определить, если утверждения, которые входят в лесу необходимо преобразовать и настроить соответствующую политику. Например администратор может настроить политику, если требуется скрыть утверждения, чтобы избежать раскрытия информации.  
  
**Синтаксические ошибки в правила преобразования утверждений**  
  
Если политики преобразования утверждений данной имеет набор правил, синтаксически неверен или возникли другие проблемы синтаксиса или хранилища, политика считается недопустимым. Это обрабатывается не так, как упоминалось ранее условий по умолчанию.  
  
Active Directory не удается определить цель в данном случае и переходит в безопасный режим, где выходные утверждения не создаются для этого доверия + направление обхода. Для устранения проблемы требуется вмешательство администратора. Это может произойти, если LDAP используется для изменения политики преобразования утверждений. Командлеты Windows PowerShell для Active Directory имеют проверки для предотвращения ситуаций записи политики с синтаксические ошибки.  
  
## <a name="other-language-considerations"></a>Дополнительные рекомендации языка  
  
1.  Существует несколько ключевых слов или символов, которые являются специальными на этом языке (называется терминалы). Будут показаны в [терминалы языка](Claims-Transformation-Rules-Language.md#BKMK_LT) таблице далее в этом разделе. Сообщения об ошибках используйте теги для терминалы для устранения неоднозначности.  
  
2.  Терминалы иногда может использоваться как строковые литералы. Тем не менее, такое использование может конфликтовать с определением языка, или иметь непредвиденные последствия. Такого рода использование не рекомендуется.  
  
3.  Действие правила не выполняет преобразования типов на значения утверждений и набор правил, который содержит действие правила считается недопустимым. Это приведет к ошибке времени выполнения, а выходные утверждения не создаются.  
  
4.  Если действия правила ссылается на идентификатор, который не использовался в списке выберите условие правила, это недопустимое назначение. Это вызовет синтаксическую ошибку.  
  
    **Пример: Неверная ссылка на идентификатор**  
    Следующее правило иллюстрирует неправильный идентификатор, используемый в действии правила.  
  
    ```  
    C1:[] => Issue (claim = C2);  
    ```  
  
## <a name="sample-transformation-rules"></a>Пример правила преобразования  
  
-   **Разрешить все утверждения определенного типа**  
  
    Точный тип  
  
    ```  
    C1:[type=="XYZ"] => Issue (claim = C1);  
    ```  
  
    С помощью регулярных выражений  
  
    ```  
    C1: [type =~ "XYZ*"] => Issue (claim = C1);  
    ```  
  
-   **Запретить определенного типа утверждения**  
    Точный тип  
  
    ```  
    C1:[type != "XYZ"] => Issue (claim=C1);  
    ```  
  
    С помощью регулярных выражений  
  
    ```  
    C1:[Type !~ "XYZ?"] => Issue (claim=C1);  
    ```  
  
## <a name="examples-of-rules-parser-errors"></a>Примеры правил средство синтаксического анализа ошибок  
Правила преобразования утверждений, обрабатываются с пользовательское средство синтаксического анализа на наличие синтаксических ошибок. Это средство синтаксического анализа выполняется, связанных с ним командлетов Windows PowerShell перед сохранением правила в Active Directory. Все ошибки в правила, включая синтаксические ошибки синтаксического анализа выводятся на консоль. Средство синтаксического анализа также работают контроллеры домена перед использованием правила для преобразования утверждений, и они входят ошибки в журнале событий (Добавление номеров журнала событий).  
  
В этом разделе показаны некоторые примеры правил, созданных с помощью синтаксиса и соответствующий синтаксис ошибки, создаваемые средством синтаксического анализа.  
  
1. Пример.  
  
   ```  
   c1;[]=>Issue(claim=c1);  
   ```  
  
   В этом примере имеет неправильно используется точка с запятой вместо двоеточия.   
   **Сообщение об ошибке:**  
   *POLICY0002: Не удалось проанализировать данные о политике.*  
   *Номер строки: 1, номер столбца: Токен 2, ошибка:;. Line: 'c1;[]=>Issue(claim=c1);'.*  
   *Ошибка средства синтаксического анализа: "POLICY0030: Синтаксическая ошибка: непредвиденный «;», ожидалось одно из следующих: ":". "*  
  
2. Пример.  
  
   ```  
   c1:[]=>Issue(claim=c2);  
   ```  
  
   В этом примере не определен идентификатор тега в инструкции выдачи копирования.   
   **Сообщение об ошибке**:   
   *POLICY0011: Ни одно из условий в правиле утверждения соответствует тегу условие, указанное в CopyIssuanceStatement: «c2».*  
  
3. Пример.  
  
   ```  
   c1:[type=="x1", value=="1", valuetype=="bool"]=>Issue(claim=c1)  
   ```  
  
   «bool» не в окне терминала на язык, и он не является допустимым типом значения. Допустимые терминалы, перечислены в следующее сообщение об ошибке.   
   **Сообщение об ошибке:**  
   *POLICY0002: Не удалось проанализировать данные о политике.*  
   Номер строки: 1, номер столбца: Токен 39, ошибка: «bool». Line: 'c1:[type=="x1", value=="1",valuetype=="bool"]=>Issue(claim=c1);'.   
   *Ошибка средства синтаксического анализа: "POLICY0030: Синтаксическая ошибка: непредвиденный «STRING», ожидается одно из следующих: «INT64_TYPE» «UINT64_TYPE» «STRING_TYPE» «BOOLEAN_TYPE», «ИДЕНТИФИКАТОР»*  
  
4. Пример.  
  
   ```  
   c1:[type=="x1", value==1, valuetype=="boolean"]=>Issue(claim=c1);  
   ```  
  
   Цифра **1** в этом примере не является допустимым маркером на языке, и в соответствующее условие, такое использование не допускается. Он должен быть заключен в двойные кавычки, чтобы сделать его строкой.   
   **Сообщение об ошибке:**  
   *POLICY0002: Не удалось проанализировать данные о политике.*  
   *Номер строки: 1, номер столбца: 23, токен ошибки. 1. Line: 'c1:[type=="x1", value==1, valuetype=="bool"]=>Issue(claim=c1);'.* <em>Parser error: "POLICY0029: Непредвиденные входные данные.</em>  
  
5. Пример.  
  
   ```  
   c1:[type == "x1", value == "1", valuetype == "boolean"] =>   
  
        Issue(type = c1.type, value="0", valuetype == "boolean");  
   ```  
  
   В этом примере используется двойной знак равенства (==), а не один знак равенства (=).   
   **Сообщение об ошибке:**  
   *POLICY0002: Не удалось проанализировать данные о политике.*  
   *Номер строки: 1, номер столбца: Токен 91, ошибка: ==. Line: 'c1:[type=="x1", value=="1",*  
   *valuetype=="boolean"]=>Issue(type=c1.type, value="0", valuetype=="boolean");'.*  
   *Ошибка средства синтаксического анализа: "POLICY0030: Синтаксическая ошибка, Непредвиденная «==», ожидается одно из следующих: «=»*  
  
6. Пример.  
  
   ```  
   c1:[type=="x1", value=="boolean", valuetype=="string"] =>   
  
         Issue(type=c1.type, value=c1.value, valuetype = "string");  
   ```  
  
   Данный пример является синтаксически и семантически правильный. Тем не менее с помощью «boolean», как строковое значение привязан к привести к путанице, и его следует избегать. Как упоминалось ранее, с помощью языка терминалы, как следует избегать значения утверждений, где это возможно.  
  
## <a name="BKMK_LT"></a>Терминальные слова языка  
Ниже перечислены полный набор строк терминалов и терминалами соответствующего языка, которые используются в язык правил преобразования утверждений. В этих определениях использовались строк UTF-16 без учета регистра.  
  
|Строка|Терминалов|  
|----------|------------|  
|"=>"|ПОДРАЗУМЕВАЕТ|  
|";"|ТОЧКА С ЗАПЯТОЙ|  
|":"|ДВОЕТОЧИЕ|  
|","|ЗАПЯТАЯ|  
|"."|ТОЧКА|  
|"["|O_SQ_BRACKET|  
|"]"|C_SQ_BRACKET|  
|"("|O_BRACKET|  
|")"|C_BRACKET|  
|"=="|EQ|  
|"!="|NEQ|  
|"=~"|REGEXP_MATCH|  
|"!~"|REGEXP_NOT_MATCH|  
|"="|НАЗНАЧИТЬ|  
|"&&"|AND|  
|«проблема»|ПРОБЛЕМА|  
|"type"|TYPE|  
|«value»|ЗНАЧЕНИЕ|  
|"valuetype"|VALUE_TYPE|  
|«Утверждение»|УТВЕРЖДЕНИЕ|  
|"[_A-Za-z][_A-Za-z0-9]*"|ИДЕНТИФИКАТОР|  
|"\\«[^\\«\n]*\\«»|СТРОКА|  
|"uint64"|UINT64_TYPE|  
|"int64"|INT64_TYPE|  
|«string»|STRING_TYPE|  
|«boolean»|BOOLEAN_TYPE|  
  
## <a name="language-syntax"></a>Синтаксис языка  
В форме ABNF задается следующий язык правил преобразования утверждений. Это определение использует терминалами, которые указаны в приведенной выше таблице, в дополнение к ABNF производства, заданные здесь. Правила должны быть закодированы в кодировке UTF-16 и сравнения строк должны обрабатываться без учета регистра.  
  
```  
Rule_set        = ;/*Empty*/  
             / Rules  
Rules         = Rule  
             / Rule Rules  
Rule          = Rule_body  
Rule_body       = (Conditions IMPLY Rule_action SEMICOLON)  
Conditions       = ;/*Empty*/  
             / Sel_condition_list  
Sel_condition_list   = Sel_condition  
             / (Sel_condition_list AND Sel_condition)  
Sel_condition     = Sel_condition_body  
             / (IDENTIFIER COLON Sel_condition_body)  
Sel_condition_body   = O_SQ_BRACKET Opt_cond_list C_SQ_BRACKET  
Opt_cond_list     = /*Empty*/  
             / Cond_list  
Cond_list       = Cond  
             / (Cond_list COMMA Cond)  
Cond          = Value_cond  
             / Type_cond  
Type_cond       = TYPE Cond_oper Literal_expr  
Value_cond       = (Val_cond COMMA Val_type_cond)  
             /(Val_type_cond COMMA Val_cond)  
Val_cond        = VALUE Cond_oper Literal_expr  
Val_type_cond     = VALUE_TYPE Cond_oper Value_type_literal  
claim_prop       = TYPE  
             / VALUE  
Cond_oper       = EQ  
             / NEQ  
             / REGEXP_MATCH  
             / REGEXP_NOT_MATCH  
Literal_expr      = Literal  
             / Value_type_literal  
  
Expr          = Literal  
             / Value_type_expr  
             / (IDENTIFIER DOT claim_prop)  
Value_type_expr    = Value_type_literal  
             /(IDENTIFIER DOT VALUE_TYPE)  
Value_type_literal   = INT64_TYPE  
             / UINT64_TYPE  
             / STRING_TYPE  
             / BOOLEAN_TYPE  
Literal        = STRING  
Rule_action      = ISSUE O_BRACKET Issue_params C_BRACKET  
Issue_params      = claim_copy  
             / claim_new  
claim_copy       = CLAIM ASSIGN IDENTIFIER  
claim_new       = claim_prop_assign_list  
claim_prop_assign_list = (claim_value_assign COMMA claim_type_assign)  
             /(claim_type_assign COMMA claim_value_assign)  
claim_value_assign   = (claim_val_assign COMMA claim_val_type_assign)  
             /(claim_val_type_assign COMMA claim_val_assign)  
claim_val_assign    = VALUE ASSIGN Expr  
claim_val_type_assign = VALUE_TYPE ASSIGN Value_type_expr  
Claim_type_assign   = TYPE ASSIGN Expr  
  
```  
  



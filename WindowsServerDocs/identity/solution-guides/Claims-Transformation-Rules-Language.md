---
ms.assetid: e831f781-3c45-4d44-b411-160d121d1324
title: "Язык правил преобразования утверждений"
description: 
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adds
ms.openlocfilehash: 4a6b378bc4aef180ebedd260008febaa2f2a76ae
ms.sourcegitcommit: db290fa07e9d50686667bfba3969e20377548504
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/12/2017
---
# <a name="claims-transformation-rules-language"></a>Язык правил преобразования утверждений

>Область применения: Windows Server 2016, Windows Server 2012 R2, Windows Server 2012

Между лесами утверждений преобразования компонент позволяет вам мост утверждений для динамического контроля доступа через границы лесов, задав политик преобразования утверждений для отношений доверия между лесами. Основным компонентом все политики — это правила, которые записываются в язык правил преобразования утверждений. В этом разделе содержатся сведения об этом языке и даются рекомендации по созданию правил преобразования утверждений.  
  
Командлеты Windows PowerShell для преобразования политики между лесами доверия возможностей по настройке простой политики, которые требуется в обычных сценариях. Эти командлеты перевода пользовательского ввода в политикам и правилам в язык правил преобразования утверждений и хранить их в Active Directory предписанный формат. Дополнительные сведения о командлетах для преобразования утверждений см. в разделе [командлеты AD DS для динамического контроля доступа](https://go.microsoft.com/fwlink/?LinkId=243150).  
  
В зависимости от требований, помещаются в отношениях доверия между лесами в вашем лесах Active Directory и конфигурация утверждений политик преобразования утверждений может потребоваться более сложная, чем политик, поддерживаются с помощью командлетов Windows PowerShell для Active Directory. Эффективно создавать такие политики, очень важно понять семантику и синтаксисе языка правил преобразования утверждений. Это утверждений язык правил преобразования («язык») в Active Directory — подмножество языка, который используется с [служб федерации Active Directory](https://go.microsoft.com/fwlink/?LinkId=243982) для аналогичных целей и он имеет очень похоже синтаксиса и семантики. Тем не менее меньшее количество операций, которые разрешено, и дополнительные синтаксис ограничения размещаются в Active Directory версии языка.  
  
В этом разделе приводится краткое описание синтаксиса и семантики язык правил преобразования утверждений в Active Directory и рекомендации, которые следует принять при создании политики. Он предоставляет несколько наборов правил примере можно приступить к работе, и примеры неправильный синтаксис и сообщения, которые они создают, чтобы расшифровать сообщения об ошибках при создании правил.  
  
## <a name="tools-for-authoring-claims-transformation-policies"></a>Средства для разработки политик преобразования утверждений  
**Командлеты Windows PowerShell для Active Directory**: Это предпочтительный и рекомендуемый способ создания, а также задавать политики преобразования утверждений. Эти командлеты обеспечивают коммутаторы простых политик и убедитесь, правила, которые задаются для более сложных политик.  
  
**LDAP**: политик преобразования утверждений можно редактировать в Active Directory через облегченного доступа к каталогам LDAP Directory Access Protocol (). Однако это не рекомендуется, поскольку политики несколько сложных компоненты и средства, которые можно использовать не может проверять политики перед ее записью Active Directory. Впоследствии для этого может потребоваться значительное время для диагностики проблем.  
  
## <a name="active-directory-claims-transformation-rules-language"></a>Язык правил преобразования утверждений Active Directory  
  
### <a name="syntax-overview"></a>Общие сведения о синтаксисе  
Вот краткий обзор синтаксиса и семантики языка.  
  
-   Набор правил преобразования утверждений состоит из ноль или несколько правил. Каждое правило состоит из двух частей active: **списка выберите условие** и **действие правила**. Если **списка выберите условие** возвращает значение TRUE, соответствующее правило действие выполняется.  
  
-   **Выберите условие список** содержит ноль или больше **выберите условия**. Все **выберите условия** должна возвращать значение TRUE для **списка выберите условие** для оценки значение TRUE.  
  
-   Каждый **выберите условие** имеет ряд ноль или больше **условия, соответствующие**. Все **условия, соответствующие** должна возвращать значение TRUE, выберите условия оценить значение TRUE. Все эти условия сопоставляются одно утверждение. Утверждения, которое соответствует **выберите условие** тег с **идентификатор**, а в **действие правила**.  
  
-   Каждый **условие соответствия** условие в соответствии с **тип** или **значение** или **ValueType** утверждения с помощью различных **условные операторы** и **строковых литералов**.  
  
    -   При указании **условие соответствия** для **значение**, необходимо также указать **условие соответствия** для конкретного **ValueType** и наоборот. Эти условия необходимо рядом друг с другом в синтаксисе.  
  
    -   **ValueType** соответствующих условий необходимо использовать конкретное **ValueType** только литералы.  
  
-   A **действие правила** можно скопировать одного утверждения, которые связаны с **идентификатор** или выдачи одно утверждение на основе утверждений, который отмечен идентификатором и/или предоставлено строковых литералов.  
  
**Пример правила**  
  
В этом примере показаны правила, которое может использоваться для преобразования утверждений типа между двумя лесами, если они используют одинаковые утверждения ValueTypes, а имеются же интерпретации утверждений значения для этого типа. Правило имеет одно условие соответствия и инструкция выдачи, используемая строковых литералов и соответствующей ссылки утверждений.  
  
```  
C1: [TYPE=="EmployeeType"]    
                 => ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE);  
[TYPE=="EmployeeType"] == Select Condition List with one Matching Condition for claims Type.  
ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE) == Rule Action that issues a claims using string literal and matching claim referred with the Identifier.  
  
```  
  
### <a name="runtime-operation"></a>Операция среды выполнения  
Важно понимать операцию среды выполнения преобразования утверждений для создания правил эффективно. Операция среды выполнения использует три набора утверждений:  
  
1.  **Набор утверждений ввода**: входного набора утверждений, которые предоставляются операции преобразования утверждений.  
  
2.  **Набор утверждений работать**: промежуточный утверждения, которые считываются из и записи во время преобразования утверждений.  
  
3.  **Выходные данные утверждений набор**: результат преобразования утверждений.  
  
Вот краткий обзор среды выполнения операции преобразования утверждений.  
  
1.  Ввода утверждений для преобразования утверждений используются для инициализации рабочий набор утверждений.  
  
    1.  При обработке каждого правила, рабочий набор утверждений используется для ввода утверждений.  
  
    2.  Список выбора условий в правиле противопоставляется все возможные наборы утверждений из рабочего набора утверждений.  
  
    3.  Для выполнения действия в это правило, используется каждого набора соответствующих утверждений.  
  
    4.  Выполнение правила результаты действий в одно утверждение, который добавляется к выходные данные утверждений набор и рабочий набор утверждений. Таким образом выходные данные правило используется в качестве входных данных для последующих правил в наборе правил.  
  
2.  Правила в наборе правил обрабатываются последовательно, начиная с первого правила.  
  
3.  При обработке набор правил на всей выходной набор утверждений обрабатывается для удаления повторяющихся утверждений и другими безопасности issues.The утверждения — это выходные данные процесса преобразования утверждений.  
  
Это позволяет писать преобразования сложных утверждений в зависимости от предыдущих поведение в среде выполнения.  
  
**Пример: Среда выполнения операции**  
  
В этом примере показано операцию среды выполнения, который использует два правила преобразования утверждений.  
  
```  
  
     C1:[Type=="EmpType", Value=="FullTime",ValueType=="string"] =>  
                Issue(Type=="EmployeeType", Value=="FullTime",ValueType=="string");  
     [Type=="EmployeeType"] =>   
               Issue(Type=="AccessType", Value=="Privileged", ValueType=="string");  
Input claims and Initial Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
After Processing Rule 1:  
 Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"), (Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  
After Processing Rule 2:  
Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
Final Output:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
```  
  
### <a name="special-rules-semantics"></a>Семантика особые правила  
Ниже перечислены специальный синтаксис для правил.  
  
1.  Пустой набор правил == утверждения не выходные данные  
  
2.  Очистка списка выберите условие == каждый утверждения соответствует списке выберите условие  
  
    **Пример: Пустой выберите условие списка**  
  
    Следующее правило соответствует каждые утверждения в рабочем наборе.  
  
    ```  
    => Issue (Type = "UserType", Value = "External", ValueType = "string")  
    ```  
  
3.  Очистка списка выберите соответствия == каждые утверждения соответствует списке выберите условие  
  
    **Пример: Пустой соответствующих условий**  
  
    Следующее правило соответствует каждые утверждения в рабочем наборе. Это правило основные «разрешить все», если он используется отдельно.  
  
    ```  
    C1:[] => Issule (claim = C1);  
    ```  
  
## <a name="security-considerations"></a>Вопросы безопасности  
**Утверждения, введите леса**  
  
Утверждения, предъявленный участников, которые являются входящие в лес необходимо исследовать тщательно убедитесь, что мы разрешить или выдавать только правильный утверждения. Ненадлежащее утверждений может нарушить безопасность леса и следует верхней следует учитывать при разработке политик преобразования утверждений, которые вводить леса.  
  
Active Directory имеет следующие возможности для предотвращения неправильной настройки утверждения, введите леса:  
  
-   Если доверие леса не политики преобразования утверждений для утверждения, введите леса, в целях безопасности Active Directory отбрасывает участника утверждения, которые введите леса.  
  
-   Если выполняется набора утверждениями правил, вводит результаты леса в утверждения, которые не определены в лесу, на основе утверждений, выходные данные удаляются undefined утверждений.  
  
**Утверждения, которые покидают лес**  
  
Утверждения, которые покидают лес представить меньшего проблему безопасности для леса, чем утверждения, введите леса. Утверждения могут оставить лесу, что и-— даже при отсутствии утверждения, не соответствующие политики преобразование на месте. Можно также выдавать утверждения, которые не определены в лесу, в рамках процесса преобразования утверждений, которые оставляют леса. Это позволяет легко настроить отношения доверия между лесами с утверждениями. Администратор может определить, если утверждения, введите леса необходимо преобразовать и настроить соответствующую политику. Например администратор может настроить политики, если нужно скрыть утверждения, чтобы избежать раскрытия информации.  
  
**Синтаксических ошибок в правила преобразования утверждений**  
  
Если политики преобразования утверждений заданного набора правил, синтаксически неверный или возникли другие проблемы синтаксис или хранилища, политики считается недействительным. Это не так, как было показано ранее условий по умолчанию обрабатывается.  
  
Active Directory не удается определить цель в этом случае и переходит в безопасном режиме, где утверждения выходные данные не создаются для этого доверия + направление обхода. Для устранения этой проблемы требуется вмешательство администратора. Это может произойти, если LDAP используется для изменения политики преобразования утверждений. Командлеты Windows PowerShell для Active Directory имеют проверки в месте, чтобы предотвратить запись политики с проблемами синтаксис.  
  
## <a name="other-language-considerations"></a>Другие аспекты языка  
  
1.  Существует несколько ключевые слова или символы, которые являются особыми на этом языке (так называемой терминалы). Будут показаны в [терминалы язык](Claims-Transformation-Rules-Language.md#BKMK_LT) в таблице ниже в этом разделе. Сообщения об ошибках использовать теги для этих терминалов для уточнения.  
  
2.  Иногда терминалы можно использовать как строковых литералов. Тем не менее, такие использование может конфликтовать с определение языка или имеют к непредвиденным последствиям. Этот тип использования не рекомендуется.  
  
3.  Действие правила невозможно выполнять преобразования любого типа на значений утверждений и набор правил, который содержит действия правила считается недействительным. Это вызовет ошибку во время выполнения, а утверждения выходные данные не создаются.  
  
4.  Если действие правила ссылается идентификатор, который не использовался в списке выберите условие правила, это недопустимое использование. Это приведет к ошибке синтаксис.  
  
    **Пример: Неверный идентификатор ссылки**  
    Следующее правило показан неверный идентификатор, используемый в действие правила.  
  
    ```  
    C1:[] => Issue (claim = C2);  
    ```  
  
## <a name="sample-transformation-rules"></a>Пример правила преобразования  
  
-   **Разрешить все утверждения определенного типа**  
  
    Точный тип  
  
    ```  
    C1:[type=="XYZ"] => Issue (claim = C1);  
    ```  
  
    Использование регулярных выражений  
  
    ```  
    C1: [type =~ "XYZ*"] => Issue (claim = C1);  
    ```  
  
-   **Запретить определенного типа утверждения**  
    Точный тип  
  
    ```  
    C1:[type != "XYZ"] => Issue (claim=C1);  
    ```  
  
    Использование регулярных выражений  
  
    ```  
    C1:[Type !~ "XYZ?"] => Issue (claim=C1);  
    ```  
  
## <a name="examples-of-rules-parser-errors"></a>Примеры ошибок синтаксического анализа правила  
Правила преобразования утверждений анализируются анализатором, настраиваемые на наличие синтаксических ошибок. Это средство синтаксического анализа в случае запуска соответствующих командлетов Windows PowerShell перед сохранением правила в Active Directory. Любые ошибки при анализе правил, включая ошибки синтаксиса, печатаются на консоли. Контроллеры домена также запускать средство синтаксического анализа перед использованием правила для преобразования утверждений, и они входят ошибки в журнале событий (Добавление номеров журнала событий).  
  
В этом разделе перечислены некоторые примеры правил, созданных с помощью синтаксиса и соответствующий синтаксис ошибок, формируемых средством синтаксического анализа.  
  
1.  Пример:  
  
    ```  
    c1;[]=>Issue(claim=c1);  
    ```  
  
    В этом примере есть неправильно используемых точкой с запятой вместо двоеточия.   
    **Сообщение об ошибке:**  
    *POLICY0002: Не удалось проанализировать данные о политике.*  
    *Номер строки: 1, номер столбца: 2, ошибка маркер:;. Строка: "c1; [] = > Issue(claim=c1); ".*  
    *Ошибка синтаксического анализа: "POLICY0030: синтаксическая ошибка, Непредвиденная «;», ожидаемое один из следующих:": "."*  
  
2.  Пример:  
  
    ```  
    c1:[]=>Issue(claim=c2);  
    ```  
  
    В этом примере тег идентификатор в инструкцию выдачи копирования не определен.   
    **Сообщение об ошибке**:   
    *POLICY0011: Без условий в правиле утверждения соответствует тег условие, указанное в CopyIssuanceStatement: «c2».*  
  
3.  Пример:  
  
    ```  
    c1:[type=="x1", value=="1", valuetype=="bool"]=>Issue(claim=c1)  
    ```  
  
    «bool» не терминалов на языке, и не является допустимым ValueType. Допустимые терминалы, перечислены в следующее сообщение об ошибке.   
    **Сообщение об ошибке:**  
    *POLICY0002: Не удалось проанализировать данные о политике.*  
    Номер строки: 1, номер столбца: 39, ошибка маркера: «bool». Строка: "c1: [тип == значение «x1» == «1», valuetype == «bool»] = > Issue(claim=c1);".   
    *Ошибка синтаксического анализа: "POLICY0030: синтаксическая ошибка, Непредвиденная «строка», ожидается одно из следующих действий: «INT64_TYPE» «UINT64_TYPE» «STRING_TYPE» «BOOLEAN_TYPE» «Идентификатор»*  
  
4.  Пример:  
  
    ```  
    c1:[type=="x1", value==1, valuetype=="boolean"]=>Issue(claim=c1);  
    ```  
  
    Цифра **1** в этом примере не является допустимым маркером на языке, и в соответствующее условие запрещено такого использования. Оно должно быть заключена в двойные кавычки, чтобы сделать его строку.   
    **Сообщение об ошибке:**  
    *POLICY0002: Не удалось проанализировать данные о политике.*  
    *Номер строки: 1, номер столбца: 23, ошибка маркер: 1. строка: "c1: [тип == значение «x1» == 1, valuetype == «bool»] = > Issue(claim=c1);". **Ошибке средства синтаксического анализа: "POLICY0029: Неожиданный ввод.*  
  
5.  Пример:  
  
    ```  
    c1:[type == "x1", value == "1", valuetype == "boolean"] =>   
  
         Issue(type = c1.type, value="0", valuetype == "boolean");  
    ```  
  
    В этом примере используется двойной знак равенства (==) вместо один знак равенства (=).   
    **Сообщение об ошибке:**  
    *POLICY0002: Не удалось проанализировать данные о политике.*  
    *Номер строки: 1, номер столбца: 91, ошибка маркер: ==. Строка: "c1: [тип == значение «x1» == «1»,*  
    *ValueType == «boolean»] = > проблемы (type=c1.type, значение «0», valuetype == «boolean»); ".*  
    *Ошибка синтаксического анализа: "POLICY0030: синтаксическая ошибка, Непредвиденная «==», ожидается одно из следующих: «=»*  
  
6.  Пример:  
  
    ```  
    c1:[type=="x1", value=="boolean", valuetype=="string"] =>   
  
          Issue(type=c1.type, value=c1.value, valuetype = "string");  
    ```  
  
    В этом примере синтаксически и семантически правильно. Тем не менее использование «логическое значение» строковое значение привязан к вызвать путаницу, а следует избегать. Как упоминалось ранее, с помощью языка терминалы, как следует избегать значений утверждений, где это возможно.  
  
## <a name="BKMK_LT"></a>Терминалы языка  
В следующей таблице перечислены полный набор строк терминалов и терминалов соответствующего языка, которые используются в язык правил преобразования утверждений. Эти определения используйте без учета регистра UTF-16 строки.  
  
|Строка|Терминалов|  
|----------|------------|  
|"=>"|ПОДРАЗУМЕВАЕТ|  
|";"|ТОЧКА С ЗАПЯТОЙ|  
|":"|ДВОЕТОЧИЕ|  
|","|ЗАПЯТОЙ|  
|"."|ТОЧКА|  
|"["|O_SQ_BRACKET|  
|"]"|C_SQ_BRACKET|  
|"("|O_BRACKET|  
|")"|C_BRACKET|  
|"=="|EQ|  
|"!="|NEQ|  
|"=~"|REGEXP_MATCH|  
|"!~"|REGEXP_NOT_MATCH|  
|"="|НАЗНАЧЕНИЕ|  
|"&&"|И|  
|«проблема»|ПРОБЛЕМА|  
|«Тип»|ТИП|  
|«value»|ЗНАЧЕНИЕ|  
|«valuetype»|VALUE_TYPE|  
|«утверждения»|УТВЕРЖДЕНИЯ|  
|«[_A-Za-z][_A-Za-z0-9]*»|ИДЕНТИФИКАТОР|  
|"\\"[^\\"\n]*\\""|СТРОКА|  
|«uint64»|UINT64_TYPE|  
|«int64»|INT64_TYPE|  
|«Строка»|STRING_TYPE|  
|«Логическое»|BOOLEAN_TYPE|  
  
## <a name="language-syntax"></a>Синтаксис языка  
Следующие язык правил преобразования утверждений указывается в виде ABNF. Это определение использует терминалов, которые указаны в предыдущей таблице, в дополнение к ABNF производства, здесь. Правила должны иметь кодировку UTF-16 и сравнения строк должен рассматриваться как без учета регистра.  
  
```  
Rule_set        = ;/*Empty*/  
             / Rules  
Rules         = Rule  
             / Rule Rules  
Rule          = Rule_body  
Rule_body       = (Conditions IMPLY Rule_action SEMICOLON)  
Conditions       = ;/*Empty*/  
             / Sel_condition_list  
Sel_condition_list   = Sel_condition  
             / (Sel_condition_list AND Sel_condition)  
Sel_condition     = Sel_condition_body  
             / (IDENTIFIER COLON Sel_condition_body)  
Sel_condition_body   = O_SQ_BRACKET Opt_cond_list C_SQ_BRACKET  
Opt_cond_list     = /*Empty*/  
             / Cond_list  
Cond_list       = Cond  
             / (Cond_list COMMA Cond)  
Cond          = Value_cond  
             / Type_cond  
Type_cond       = TYPE Cond_oper Literal_expr  
Value_cond       = (Val_cond COMMA Val_type_cond)  
             /(Val_type_cond COMMA Val_cond)  
Val_cond        = VALUE Cond_oper Literal_expr  
Val_type_cond     = VALUE_TYPE Cond_oper Value_type_literal  
claim_prop       = TYPE  
             / VALUE  
Cond_oper       = EQ  
             / NEQ  
             / REGEXP_MATCH  
             / REGEXP_NOT_MATCH  
Literal_expr      = Literal  
             / Value_type_literal  
  
Expr          = Literal  
             / Value_type_expr  
             / (IDENTIFIER DOT claim_prop)  
Value_type_expr    = Value_type_literal  
             /(IDENTIFIER DOT VALUE_TYPE)  
Value_type_literal   = INT64_TYPE  
             / UINT64_TYPE  
             / STRING_TYPE  
             / BOOLEAN_TYPE  
Literal        = STRING  
Rule_action      = ISSUE O_BRACKET Issue_params C_BRACKET  
Issue_params      = claim_copy  
             / claim_new  
claim_copy       = CLAIM ASSIGN IDENTIFIER  
claim_new       = claim_prop_assign_list  
claim_prop_assign_list = (claim_value_assign COMMA claim_type_assign)  
             /(claim_type_assign COMMA claim_value_assign)  
claim_value_assign   = (claim_val_assign COMMA claim_val_type_assign)  
             /(claim_val_type_assign COMMA claim_val_assign)  
claim_val_assign    = VALUE ASSIGN Expr  
claim_val_type_assign = VALUE_TYPE ASSIGN Value_type_expr  
Claim_type_assign   = TYPE ASSIGN Expr  
  
```  
  



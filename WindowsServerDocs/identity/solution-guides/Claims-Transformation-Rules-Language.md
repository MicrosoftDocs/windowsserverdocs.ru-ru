---
ms.assetid: e831f781-3c45-4d44-b411-160d121d1324
title: Язык правил преобразования утверждений
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server
ms.technology: identity-adds
ms.openlocfilehash: 200d592bc68562856bbdee623e70d73d41457c15
ms.sourcegitcommit: 6aff3d88ff22ea141a6ea6572a5ad8dd6321f199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71357576"
---
# <a name="claims-transformation-rules-language"></a>Язык правил преобразования утверждений

>Область применения: Windows Server 2016, Windows Server 2012 R2, Windows Server 2012

Функция преобразования заявок между лесами позволяет распределять утверждения для динамического контроля доступа через границы леса, настроив политики преобразования утверждений для отношений доверия между лесами. Основным компонентом всех политик являются правила, написанные на языке правил преобразования утверждений. В этом разделе содержатся сведения об этом языке и даются рекомендации по созданию правил преобразования утверждений.  
  
Командлеты Windows PowerShell для политик преобразования в отношениях доверия между лесами имеют параметры для установки простых политик, необходимых в типичных сценариях. Эти командлеты преобразуют введенные пользователем данные в политики и правила на языке правил преобразования утверждений, а затем сохраняют их в Active Directory в предписанном формате. Дополнительные сведения о командлетах для преобразования утверждений см. в разделе [командлеты AD DS для динамического контроля доступа](https://go.microsoft.com/fwlink/?LinkId=243150).  
  
В зависимости от конфигурации утверждений и требований, накладываемых на доверие между лесами в Active Directory лесах, политики преобразования заявок могут быть сложнее, чем политики, поддерживаемые командлетами Windows PowerShell для Active Каталоги. Для эффективного создания таких политик важно понимать синтаксис и семантику языка правил преобразования утверждений. Этот язык правил преобразования утверждений (язык) в Active Directory является подмножеством языка, используемого [службы федерации Active Directory (AD FS)](https://go.microsoft.com/fwlink/?LinkId=243982) для аналогичных целей, и имеет очень похожий синтаксис и семантику. Однако допускается меньше операций, а в Active Directory версии языка размещаются дополнительные синтаксические ограничения.  
  
В этом разделе кратко описывается синтаксис и семантика языка правил преобразования утверждений в Active Directory и рекомендации, которые необходимо выполнить при создании политик. Он предоставляет несколько наборов примеров правил для начала работы, а также примеры неправильного синтаксиса и сообщений, которые они создают, чтобы помочь вам расшифровать сообщения об ошибках при создании правил.  
  
## <a name="tools-for-authoring-claims-transformation-policies"></a>Средства для создания политик преобразования утверждений  
**Командлеты Windows PowerShell для Active Directory**: это предпочтительный и рекомендуемый способ создания и установки политик преобразования утверждений. Эти командлеты предоставляют переключатели для простых политик и проверяют правила, заданные для более сложных политик.  
  
**LDAP**: политики преобразования утверждений можно изменять в Active Directory по протоколу LDAP. Однако это не рекомендуется, поскольку политики имеют несколько сложных компонентов, а используемые инструменты могут не проверять политику перед записью в Active Directory. Это может впоследствии потребовать значительного времени для диагностики проблем.  
  
## <a name="active-directory-claims-transformation-rules-language"></a>Язык правил преобразования «Active Directory утверждений»  
  
### <a name="syntax-overview"></a>Обзор синтаксиса  
Ниже приведен краткий обзор синтаксиса и семантики языка.  
  
-   Набор правил преобразования утверждений состоит из одного или нескольких правил. Каждое правило состоит из двух активных частей: **выберите список условий** и **действие правила**. Если **список условие SELECT** имеет значение true, выполняется соответствующее действие правила.  
  
-   **Выберите список** условий ноль или более **условий выбора**. Все **условия выбора** должны иметь значение true, чтобы **список выбора условий** вычисляют значение true.  
  
-   Каждое **условие выбора** имеет набор из одного или нескольких **условий сопоставления**. Все **условия сопоставления** должны иметь значение true, если условие SELECT оценивается как истинное. Все эти условия оцениваются по одному утверждению. Утверждение, соответствующее **условию SELECT** , может быть помечено **идентификатором** и ссылаться на **действие правила**.  
  
-   Каждое **условие сопоставления** определяет условие, соответствующее **типу** или **значению** , или **ValueType** утверждения с помощью различных **операторов условия** и **строковых литералов**.  
  
    -   При указании **условия сопоставления** для **значения**необходимо также указать **условие сопоставления** для конкретного **ValueType** и наоборот. Эти условия должны быть рядом друг с другом в синтаксисе.  
  
    -   Условия сопоставления **ValueType** должны использовать только определенные литералы **ValueType** .  
  
-   **Действие правила** может копировать одно утверждение, помеченное **идентификатором** , или выдавать одно утверждение на основе утверждения, помеченного идентификатором или заданным строковым литералом.  
  
**Пример правила**  
  
В этом примере показано правило, которое можно использовать для преобразования типа утверждений между двумя лесами при условии, что они используют одинаковые значения ValueTypeа утверждений и имеют одинаковые интерпретации для значений утверждений для этого типа. Правило имеет одно условие сопоставления и инструкцию Issue, которая использует строковые литералы и соответствующую ссылку на утверждения.  
  
```  
C1: [TYPE=="EmployeeType"]    
                 => ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE);  
[TYPE=="EmployeeType"] == Select Condition List with one Matching Condition for claims Type.  
ISSUE (TYPE= "EmpType", VALUE = C1.VALUE, VALUETYPE = C1.VALUETYPE) == Rule Action that issues a claims using string literal and matching claim referred with the Identifier.  
  
```  
  
### <a name="runtime-operation"></a>Операция среды выполнения  
Важно понимать, как работает выполнение преобразований утверждений, чтобы эффективно создавать правила. В операции времени выполнения используются три набора утверждений:  
  
1.  **Набор входных утверждений**: входной набор утверждений, предоставленных операции преобразования утверждений.  
  
2.  **Набор рабочих утверждений**: промежуточные утверждения, которые считываются из и записываются в ходе преобразования утверждений.  
  
3.  **Набор выходных утверждений**: выходные данные операции преобразования утверждений.  
  
Ниже приведен краткий обзор операции преобразования утверждений времени выполнения.  
  
1.  Для инициализации рабочего набора заявок используются входные утверждения для преобразования утверждений.  
  
    1.  При обработке каждого правила для входных утверждений используется набор рабочих утверждений.  
  
    2.  Список условий выбора в правиле соответствует всем возможным наборам утверждений из набора рабочих утверждений.  
  
    3.  Каждый набор соответствующих утверждений используется для выполнения действия в этом правиле.  
  
    4.  Выполнение действия правила приводит к одному утверждению, которое добавляется к набору выходных утверждений и набору рабочих утверждений. Таким образом, выходные данные правила используются в качестве входных данных для последующих правил в наборе правил.  
  
2.  Правила в наборе правил обрабатываются в последовательном порядке, начиная с первого правила.  
  
3.  Когда обрабатывается весь набор правил, набор исходящих утверждений обрабатывается для удаления повторяющихся утверждений и других проблем безопасности. Результирующие утверждения — это выходные данные процесса преобразования заявок.  
  
Можно написать сложные преобразования утверждений на основе предыдущего поведения среды выполнения.  
  
**Пример: операция среды выполнения**  
  
В этом примере показана операция среды выполнения преобразования «утверждения», в которой используются два правила.  
  
```  
  
     C1:[Type=="EmpType", Value=="FullTime",ValueType=="string"] =>  
                Issue(Type=="EmployeeType", Value=="FullTime",ValueType=="string");  
     [Type=="EmployeeType"] =>   
               Issue(Type=="AccessType", Value=="Privileged", ValueType=="string");  
Input claims and Initial Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
After Processing Rule 1:  
 Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"), (Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  
After Processing Rule 2:  
Evaluation Context:  
  {(Type= "EmpType"),(Value="FullTime"),(ValueType="String")}  
{(Type= "Organization"),(Value="Marketing"),(ValueType="String")}  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
Output Context:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
Final Output:  
  {(Type= "EmployeeType"),(Value="FullTime"),(ValueType="String")}  
  {(Type= "AccessType"),(Value="Privileged"),(ValueType="String")}  
  
```  
  
### <a name="special-rules-semantics"></a>Семантика особых правил  
Ниже приведен специальный синтаксис для правил.  
  
1.  Пустой набор правил = = нет исходящих утверждений  
  
2.  Пустой список выбора условий = = каждое утверждение соответствует списку выбора условия  
  
    **Пример: пустой список выбора условий**  
  
    Следующее правило соответствует каждому утверждению в рабочем наборе.  
  
    ```  
    => Issue (Type = "UserType", Value = "External", ValueType = "string")  
    ```  
  
3.  Пустой SELECT Matching List = = каждое утверждение соответствует списку выбора условия  
  
    **Пример: пустые условия сопоставления**  
  
    Следующее правило соответствует каждому утверждению в рабочем наборе. Это базовое правило "разрешить все", если оно используется отдельно.  
  
    ```  
    C1:[] => Issule (claim = C1);  
    ```  
  
## <a name="security-considerations"></a>Вопросы безопасности  
**Утверждения, которые вводят лес**  
  
Утверждения, представленные участниками, входящими в лес, необходимо тщательно проверить, чтобы убедиться в том, что мы разрешают или выдаете только правильные утверждения. Неправильные утверждения могут нарушать безопасность леса, и это должно быть лучшим вопросом при создании политик преобразования для утверждений, которые вводят лес.  
  
Active Directory имеет следующие возможности для предотвращения ненужной настройки утверждений, которые вводят лес.  
  
-   Если для доверия лесов не задана политика преобразования утверждений для утверждений, которые вводят лес, то в целях безопасности Active Directory удаляет все субъекты-утверждения, которые вводят лес.  
  
-   При выполнении набора правил для утверждений, которые вводят лес, приводит к позаявкам, которые не определены в лесу, а неопределенные утверждения удаляются из исходящих утверждений.  
  
**Утверждения, которые оставляют лес**  
  
Утверждения, которые оставляют лес, представляют меньшую проблему безопасности леса, чем утверждения, которые вводят лес. Утверждения могут оставить лес как есть даже при отсутствии соответствующей политики преобразования утверждений. Кроме того, можно выдавать утверждения, которые не определены в лесу, в рамках преобразования утверждений, которые оставляют лес. Это позволяет легко настраивать отношения доверия между лесами с утверждениями. Администратор может определить, нужно ли преобразовать утверждения, которые вводят лес, и настроить соответствующую политику. Например, администратор может задать политику, если необходимо скрыть утверждение, чтобы предотвратить раскрытие информации.  
  
**Синтаксические ошибки в правилах преобразования утверждений**  
  
Если в заданной политике преобразования утверждений заданы синтаксически неправильные правила или возникли другие проблемы с синтаксисом или хранилищем, то политика считается недопустимой. Это обрабатывается иначе, чем упомянутые выше условия по умолчанию.  
  
Active Directory не удается определить намерение в этом случае и переходит в незащищенный режим, где не создаются выходные утверждения для этого отношения доверия и направления обхода. Для устранения проблемы требуется вмешательство администратора. Это может произойти, если для изменения политики преобразования утверждений используется протокол LDAP. Командлеты Windows PowerShell для Active Directory имеют проверку, чтобы предотвратить запись политики с синтаксическими проблемами.  
  
## <a name="other-language-considerations"></a>Другие рекомендации по языку  
  
1.  Существует несколько ключевых слов или символов, которые являются специальными для этого языка (называются терминалами). Они представлены в таблице [языковых терминалов](Claims-Transformation-Rules-Language.md#BKMK_LT) далее в этом разделе. Сообщения об ошибках используют теги для этих терминалов для устранения неоднозначности.  
  
2.  Иногда терминалы могут использоваться в качестве строковых литералов. Однако такое использование может конфликтовать с определением языка или иметь непредвиденные последствия. Этот тип использования не рекомендуется.  
  
3.  Действие правила не может выполнять преобразования типов в значениях утверждений, а набор правил, содержащий такое действие правила, считается недопустимым. Это вызовет ошибку времени выполнения, и выходные утверждения не создаются.  
  
4.  Если действие правила ссылается на идентификатор, который не был использован в части правила выбор условия, это недопустимое использование. Это вызовет синтаксическую ошибку.  
  
    **Пример: Неверная ссылка на идентификатор**  
    Следующее правило иллюстрирует неверный идентификатор, используемый в действии правила.  
  
    ```  
    C1:[] => Issue (claim = C2);  
    ```  
  
## <a name="sample-transformation-rules"></a>Примеры правил преобразования  
  
-   **Разрешить все утверждения определенного типа**  
  
    Точный тип  
  
    ```  
    C1:[type=="XYZ"] => Issue (claim = C1);  
    ```  
  
    Использование Regex  
  
    ```  
    C1: [type =~ "XYZ*"] => Issue (claim = C1);  
    ```  
  
-   **Запретить определенный тип утверждения**  
    Точный тип  
  
    ```  
    C1:[type != "XYZ"] => Issue (claim=C1);  
    ```  
  
    Использование Regex  
  
    ```  
    C1:[Type !~ "XYZ?"] => Issue (claim=C1);  
    ```  
  
## <a name="examples-of-rules-parser-errors"></a>Примеры ошибок синтаксического анализатора правил  
Правила преобразования утверждений анализируются пользовательским анализатором для проверки синтаксических ошибок. Это средство синтаксического анализа запускается связанными командлетами Windows PowerShell перед сохранением правил в Active Directory. Ошибки при синтаксическом анализе правил, включая синтаксические ошибки, выводятся на консоль. Контроллеры домена также запускают средство синтаксического анализа перед использованием правил для преобразования утверждений и задействуют ошибки в журнале событий (Добавление номеров журнала событий).  
  
В этом разделе показаны некоторые примеры правил, написанных с неверным синтаксисом, и соответствующие синтаксические ошибки, сформированные средством синтаксического анализа.  
  
1. Пример.  
  
   ```  
   c1;[]=>Issue(claim=c1);  
   ```  
  
   В этом примере неправильно использовалась точка с запятой вместо двоеточия.   
   **Сообщение об ошибке:**  
   *POLICY0002: не удалось проанализировать данные политики.*  
   *Номер строки: 1, номер столбца: 2, токен ошибки:;. Строка: C1; [] = > проблемы (утверждение = C1); '.*  
   *Ошибка средства синтаксического анализа: "POLICY0030: синтаксическая ошибка, непредвиденный"; ", ожидается один из следующих:": ".*  
  
2. Пример.  
  
   ```  
   c1:[]=>Issue(claim=c2);  
   ```  
  
   В этом примере тег identifier в инструкции Copy выдачи не определен.   
   **Сообщение об ошибке**:   
   *POLICY0011: ни одно условие в правиле утверждений не соответствует тегу условия, указанному в Кописсуанцестатемент: "C2".*  
  
3. Пример.  
  
   ```  
   c1:[type=="x1", value=="1", valuetype=="bool"]=>Issue(claim=c1)  
   ```  
  
   "bool" не является терминалом на языке и не является допустимым значением ValueType. Допустимые терминалы перечислены в следующем сообщении об ошибке.   
   **Сообщение об ошибке:**  
   *POLICY0002: не удалось проанализировать данные политики.*  
   Номер строки: 1, номер столбца: 39, маркер ошибки: "bool". Line: "C1: [type = =" x1 ", значение = =" 1 ", ValueType = =" bool "] = >ая ошибка (утверждение = C1);".   
   *Ошибка средства синтаксического анализа: "POLICY0030: синтаксическая ошибка, Непредвиденная строка" STRING ", ожидается один из следующих:" INT64_TYPE "" UINT64_TYPE "" STRING_TYPE "" BOOLEAN_TYPE "" идентификатор "*  
  
4. Пример.  
  
   ```  
   c1:[type=="x1", value==1, valuetype=="boolean"]=>Issue(claim=c1);  
   ```  
  
   Цифра **1** в этом примере не является допустимым маркером языка, и такое использование не допускается в условии сопоставления. Его необходимо заключить в двойные кавычки, чтобы сделать его строкой.   
   **Сообщение об ошибке:**  
   *POLICY0002: не удалось проанализировать данные политики.*  
   *Номер строки: 1, номер столбца: 23, маркер ошибки: 1. строка: "C1: [type = =" x1 ", Value = = 1, ValueType = =" bool "] = > проблемы (утверждение = C1);".* <em>Ошибка средства синтаксического анализа: ' POLICY0029: непредвиденные входные данные.</em>  
  
5. Пример.  
  
   ```  
   c1:[type == "x1", value == "1", valuetype == "boolean"] =>   
  
        Issue(type = c1.type, value="0", valuetype == "boolean");  
   ```  
  
   В этом примере используется знак равенства (= =), а не один знак равенства (=).   
   **Сообщение об ошибке:**  
   *POLICY0002: не удалось проанализировать данные политики.*  
   *Номер строки: 1, номер столбца: 91, маркер ошибки: = =. Line: "C1: [type = =" x1 ", значение = =" 1 ",*  
   *ValueType = = "Boolean"] = > проблемы (Type = C1. Type, value = "0", ValueType = = "Boolean"); ".*  
   *Ошибка средства синтаксического анализа: "POLICY0030: синтаксическая ошибка, непредвиденная" = = ", ожидается один из следующих:" = "*  
  
6. Пример.  
  
   ```  
   c1:[type=="x1", value=="boolean", valuetype=="string"] =>   
  
         Issue(type=c1.type, value=c1.value, valuetype = "string");  
   ```  
  
   Этот пример синтаксически и семантически правильный. Однако использование "Boolean" в качестве строкового значения связано с путаницой, и его следует избегать. Как упоминалось ранее, использование языковых терминалов в качестве значений утверждений следует избегать там, где это возможно.  
  
## <a name="BKMK_LT"></a>Терминалы языка  
В следующей таблице перечислены полные наборы строк терминала и связанные с ними терминалы языка, используемые на языке правил преобразования утверждений. В этих определениях используются строки UTF-16 без учета регистра.  
  
|Строка|Терминалов|  
|----------|------------|  
|"= >"|ОДНОЗНАЧНО|  
|";"|ЗАКАНЧИВАЕТСЯ|  
|":"|СТАВИТ|  
|","|СИМВОЛА|  
|"."|Оператор|  
|"["|O_SQ_BRACKET|  
|"]"|C_SQ_BRACKET|  
|"("|O_BRACKET|  
|")"|C_BRACKET|  
|"=="|EQ|  
|"!="|нек|  
|"=~"|REGEXP_MATCH|  
|"!~"|REGEXP_NOT_MATCH|  
|"="|НАЗНАЧАТЬ|  
|"& &"|И|  
|Issue|ПРОБЛЕМА|  
|Тип|TYPE|  
|значений|ЗНАЧЕНИЙ|  
|внедрен|VALUE_TYPE|  
|утверждают|УТВЕРЖДАЮТ|  
|"[_A-Za-z] [_A-Za-z0-9] *"|Идентификатор|  
|"\\" [^\\"\n] *\\" "|Строка|  
|UInt64|UINT64_TYPE|  
|Int64|INT64_TYPE|  
|Строка|STRING_TYPE|  
|логическая|BOOLEAN_TYPE|  
  
## <a name="language-syntax"></a>Синтаксис языка  
В форме ABNF указан следующий язык правил преобразования утверждений. В этом определении используются терминалы, указанные в предыдущей таблице, а также производства ABNF, определенные здесь. Правила должны быть закодированы в кодировке UTF-16, а сравнения строк должны обрабатываться без учета регистра.  
  
```  
Rule_set        = ;/*Empty*/  
             / Rules  
Rules         = Rule  
             / Rule Rules  
Rule          = Rule_body  
Rule_body       = (Conditions IMPLY Rule_action SEMICOLON)  
Conditions       = ;/*Empty*/  
             / Sel_condition_list  
Sel_condition_list   = Sel_condition  
             / (Sel_condition_list AND Sel_condition)  
Sel_condition     = Sel_condition_body  
             / (IDENTIFIER COLON Sel_condition_body)  
Sel_condition_body   = O_SQ_BRACKET Opt_cond_list C_SQ_BRACKET  
Opt_cond_list     = /*Empty*/  
             / Cond_list  
Cond_list       = Cond  
             / (Cond_list COMMA Cond)  
Cond          = Value_cond  
             / Type_cond  
Type_cond       = TYPE Cond_oper Literal_expr  
Value_cond       = (Val_cond COMMA Val_type_cond)  
             /(Val_type_cond COMMA Val_cond)  
Val_cond        = VALUE Cond_oper Literal_expr  
Val_type_cond     = VALUE_TYPE Cond_oper Value_type_literal  
claim_prop       = TYPE  
             / VALUE  
Cond_oper       = EQ  
             / NEQ  
             / REGEXP_MATCH  
             / REGEXP_NOT_MATCH  
Literal_expr      = Literal  
             / Value_type_literal  
  
Expr          = Literal  
             / Value_type_expr  
             / (IDENTIFIER DOT claim_prop)  
Value_type_expr    = Value_type_literal  
             /(IDENTIFIER DOT VALUE_TYPE)  
Value_type_literal   = INT64_TYPE  
             / UINT64_TYPE  
             / STRING_TYPE  
             / BOOLEAN_TYPE  
Literal        = STRING  
Rule_action      = ISSUE O_BRACKET Issue_params C_BRACKET  
Issue_params      = claim_copy  
             / claim_new  
claim_copy       = CLAIM ASSIGN IDENTIFIER  
claim_new       = claim_prop_assign_list  
claim_prop_assign_list = (claim_value_assign COMMA claim_type_assign)  
             /(claim_type_assign COMMA claim_value_assign)  
claim_value_assign   = (claim_val_assign COMMA claim_val_type_assign)  
             /(claim_val_type_assign COMMA claim_val_assign)  
claim_val_assign    = VALUE ASSIGN Expr  
claim_val_type_assign = VALUE_TYPE ASSIGN Value_type_expr  
Claim_type_assign   = TYPE ASSIGN Expr  
  
```  
  



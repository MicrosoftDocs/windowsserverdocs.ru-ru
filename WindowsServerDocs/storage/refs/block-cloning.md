---
description: 'Дополнительные сведения: блокировать клонирование в ReFS'
ms.assetid: fd427da3-3869-428f-bf2a-56c4b7d99b40
title: Клонирование блоков в ReFS
author: gawatu
ms.author: gawatu
manager: gawatu
ms.date: 10/17/2018
ms.topic: article
ms.openlocfilehash: c73f6bde78011e2244ce857b52ed3cbe97abe8ff
ms.sourcegitcommit: 65b6de6b44d41f1180c45db11cdd60cb2a093b46
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "97041273"
---
# <a name="block-cloning-on-refs"></a>Клонирование блоков в ReFS

>Применяется к: Windows Server 2019, Windows Server 2016, Windows Server (Semi-Annual Channel)

Клонирование блоков — это копирование диапазон байтов файла от имени приложения, при этом конечный файл может совпадать с исходным или нет. К сожалению, операции копирования являются дорогостоящими, поскольку они инициируют затратные операции чтения и записи физических данных.

Однако при клонировании блоков в ReFS выполняется не требующая много ресурсов операция копирования метаданных вместо чтения и записи данных в файл. Поскольку ReFS позволяет нескольким файлам совместно использовать одни логические кластеры (физические расположения на томе), операциям копирования достаточно просто изменить сопоставление области файла с отдельным физическим расположением, т. е. дорогостоящая физическая операция превращается в быструю логическую процедуру. Это позволяет быстрее завершать копирование и инициировать меньше операций ввода-вывода в базовом хранилище. Это улучшение также дает преимущества для рабочих нагрузок виртуализации, например операции слияния контрольной точки VHDX-файлов значительно ускоряются при использовании клонирования блоков. Кроме того, поскольку несколько файлов могут совместно использовать одни логические кластеры, одинаковые данные не хранятся физически несколько раз, что дает больше свободного места.

## <a name="how-it-works"></a>Принцип работы

Клонирование блоков в ReFS позволяет превратить операцию с данными файла в обработку метаданных. Для такой оптимизации в ReFS представлены счетчики ссылок в метаданных для скопированных регионов. Такие счетчики записывают количество отдельных областей файлов, которые ссылаются на одни и те же физические области. Это позволяет нескольким файлам использовать одни физические данные:

![Отображение обновлений счетчиков ссылок, если несколько файлов ссылаются на одну область](media/ref-count-example.gif)

Сохраняя счетчик ссылок для каждого логического кластера, ReFS не разрывает изоляцию между файлами: операции записи в общие области инициируют механизм выделения при записи, когда ReFS выделяет новый регион для записи. Этот механизм сохраняет целостность общих логических кластеров.

### <a name="example"></a>Пример
Предположим, что существует два файла, X и Y, каждый из которых состоит из трех областей, а каждая область соответствует отдельным логическим кластерам.

![Два файлы с тремя отдельными областями, все из которых сопоставляются с областями с числом ссылок, равным 1](media/block-clone-1.png)

Теперь предположим, что приложение инициирует клонирование блоков из файла X в файл Y для копирования регионов A и B по смещению региона E. В результате файловая система перейдет в следующее состояние:

![Счетчик ссылок равен 2 для области с клонированными блоками](media/block-clone-2.png)

Это состояние обозначает успешное дублирование области с клонированными блоками. Так как ReFS выполняет эту операцию копирования, только изменяя сопоставления VCN до LCN, физические данные были прочитаны или перезаписаны в файле Y. Файл X и Y теперь совместно используют логические кластеры, что отражают счетчики ссылок в таблице. Поскольку данные не копируются физически, ReFS сокращает используемый объем тома.

Теперь предположим, что приложение пытается перезаписать область A в файле X. ReFS дублирует общую область, соответствующим образом обновит счетчик ссылок и выполнит входящую операцию записи в дублированную область. Это сохраняет изоляцию между файлами.

![Изоляция сохраняется за счет записи в новую область G и обновления счетчиков ссылок](media/block-clone-3.png)

После изменения записи область B по-прежнему используется обоими файлами. Обратите внимание, что если область A больше кластера, только измененный кластер будет дублирован, а оставшееся часть останется общей.


## <a name="functionality-restrictions-and-remarks"></a>Функциональные ограничения и примечания
- Исходная и конечная область должны начинаться и заканчиваться на границе кластера.
- Размер клонированной области должен быть меньше 4 ГБ.
- Максимальное число областей файлов, которые можно сопоставить с одной физической областью — 8175.
- Конечная область не должна выходить за конец файла. Если приложению необходимо расширить конечную область, добавив клонированные данные, необходимо сначала вызвать метод [SetEndOfFile](/windows/win32/api/fileapi/nf-fileapi-setendoffile).
- Если исходная и конечная области находятся в одном файле, они не должны пересекаться. (Приложение может продолжить работу, разделив операцию клонирования блоков на несколько клонов, которые не пересекаются.)
- Исходный и конечный файлы должны размещаться на одном томе ReFS.
- У исходного и конечного файла должен быть одинаковый параметр [Потоки целостности](/windows/win32/fileio/file-attribute-constants).
- Если исходный файл разреженные, конечный файл также должен быть разреженным.
- Операция клонирования блоков нарушит общие уступающие блокировки ([уступающие блокировки 2 уровня](/windows/win32/fileio/types-of-opportunistic-locks)).
- Том ReFS должен быть отформатированы с помощью Windows Server 2016, а если используется отказоустойчивый кластер, то во время форматирования функциональным уровнем кластеризации должна быть Windows Server 2016 или более поздняя версия.

## <a name="additional-references"></a>Дополнительные ссылки

-   [Обзор ReFS](refs-overview.md)
-   [Потоки целостности ReFS](integrity-streams.md)
-   [Обзор Локальные дисковые пространства](../storage-spaces/storage-spaces-direct-overview.md)
-   [DUPLICATE_EXTENTS_DATA](/windows/win32/api/winioctl/ns-winioctl-duplicate_extents_data)
-   [FSCTL_DUPLICATE_EXTENTS_TO_FILE](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)

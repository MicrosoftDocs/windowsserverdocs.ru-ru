---
title: Руководство по разработке пакетов Server Performance Advisor
description: Руководство по разработке пакетов Server Performance Advisor
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: c647e8a335aac924067d92dcb41ab4d17e0cceef
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59884865"
---
# <a name="server-performance-advisor-pack-development-guide"></a>Руководство по разработке пакетов Server Performance Advisor

>Область применения. Windows Server (полугодовой канал), Windows Server 2016, Windows Server 2012 R2, Windows Server 2012, Windows 8, Windows 10

Это руководство по разработке для помощника по производительности Microsoft Server (SPA) предоставляет рекомендации для разработчиков и системных администраторов разрабатывать пакеты advisor для анализа производительности сервера.

Предполагается, что вы знакомы с журналы производительности и оповещения (PLA), счетчики производительности, параметры реестра, инструментария управления Windows (WMI), трассировка событий для Windows (ETW) и Transact SQL (T-SQL).

Дополнительные сведения об использовании SPA см. в разделе [производительности ядра СУБД в руководстве пользователя серверного](server-performance-advisor-users-guide.md).

## <a name="spa-advisor-pack-overview"></a>Обзор пакета помощник по SPA


Пакет ядра СУБД обычно предназначен для роли конкретного сервера и определяет следующее:

* Должны собираться через PLA, включая инструментарий управления Windows (WMI), счетчики производительности, параметры реестра, файлов и трассировки событий для Windows (ETW)

* Правила, которые показаны оповещения и рекомендации

* Данные для отображения (собранные необработанные данные, агрегированные данные или списков лучших 10)

* Статистические данные, чтобы просмотреть значение, которое меняется со временем

* Статистика значения, которые могут быть тренды

Пакет ядра СУБД включает следующие элементы:

* **Метаданные XML** (ProvisionMetadata.xml)

    * [Журналы производительности и оповещения (PLA)](https://msdn.microsoft.com/library/windows/desktop/aa372635.aspx) набор сборщиков данных

    * макет отчета

* **Скрипты SQL**

    * Главная хранимая процедура

    * Объекты SQL, таких как хранимые процедуры и определяемые пользователем функции

* **Файл схемы ETW** (Schema.man), это не обязательно

### <a name="advisor-pack-workflow"></a>Рабочий процесс пакетов советника

![рабочий процесс пакетов советника](../media/server-performance-advisor/spa-dev-guide-workflow.png)

В этой блок-схема зеленый круги представляют пакеты advisor. Все другие круги представляют этапы, выполняемые в процессе платформы одностраничных ПРИЛОЖЕНИЙ. SPA использует пакет ядра СУБД для сбора данных, импорт данных в базе данных, инициализации среды выполнения и выполнять скрипты SQL.

### <a name="collect-data"></a>Сбор данных

Пакет ядра СУБД в очередь для определенного сервера с помощью SPA, модуль сбора данных запрашивает набор сборщиков данных XML из пакета помощник по и собирает данные от целевого сервера. Необработанные данные хранятся в общей папке указанного пользователем файла. Сбор данных не будет останавливаться, пока не превышен SPA, указанной пользователем длительность выполнения.

### <a name="import-data-into-the-database"></a>Импорт данных в базе данных

После завершения сбора данных каждого типа данных импортируются в соответствующей таблицы в базе данных SQL Server. Например, параметры реестра, импортируются в таблицу с именем \#registryKeys.

трассировки событий Windows для импорта файла требуется файл схемы ETW для декодирования ETL-файла. Файл схемы трассировки событий Windows — это файл XML. Его можно создать с помощью tracerpt.exe, входящий в состав Windows. Файл схемы ETW — только требуется, если пакет advisor необходимо импортировать данные трассировки событий Windows.

### <a name="switch-to-low-user-rights"></a>Переключиться в режим пользователя с низким уровня прав

Платформы одностраничных ПРИЛОЖЕНИЙ автоматически корректирует привилегии, чтобы свести к минимуму требуется уровень доступа. Так как пакеты advisor может быть разработан или изменено кем-либо, возможна пакет ядра СУБД должен содержать искаженные скриптов SQL. Чтобы уменьшить риск безопасности, любые скрипты SQL для пакета помощник по должна быть запущена с правами пользователя с низким уровня. Он имеет доступ только к ограниченной объектам, например временные таблицы и API-интерфейсы одностраничных ПРИЛОЖЕНИЙ, в виде хранимых процедур. Скрипты SQL, в состав пакета advisor можно вызвать их хранимых процедур для взаимодействия с помощью платформы SPA.

### <a name="initialize-execution-environment"></a>Инициализация среды выполнения

Пакеты Advisor можно создавать различные типы вывода, таких как уведомления, рекомендации, таблицы фактов, статистики и диаграммы для статистики. Скрипты SQL выполнять определенные вычисления от собранных данных. Получения первых результатов, хранятся во временных таблицах через общедоступный API SPA. на этапе инициализации эти временные таблицы и других системных ресурсов необходимо подготовить.

### <a name="run-sql-scripts"></a>Запуск скриптов SQL

Отсутствует основной хранимая процедура, которая называется разработчиком пакета помощник по. SPA framework вызывает эту хранимую процедуру, чтобы инициировать вычисления. Хранимая процедура использует собранные данные и передает конечный результат платформы одностраничных ПРИЛОЖЕНИЙ.

### <a name="switch-to-administrative-rights"></a>Переключиться в режим администратора

Для создания отчета требуются права администратора. Создание отчета полностью управляется SPA. Это снижает вероятность быть подделаны.

### <a name="generate-a-report"></a>Создание отчета

До Главная хранимая процедура завершения для пакет ядра СУБД, все вычисленные результаты, например уведомлений и статистику, не сохраняются. На этом этапе платформы одностраничных ПРИЛОЖЕНИЙ передает конечные результаты из временных таблиц в таблицы в определенном формате. После завершения этого этапа, можно просмотреть отчеты с помощью консоли SPA.

## <a name="authoring-an-advisor-pack"></a>Создание пакета advisor


### <a name="quick-guidelines"></a>Краткие рекомендации

На следующей схеме показано шаги разработки пакет полностью функциональной помощник по. В этом разделе также включает в себя пошаговые примеры для более подробного объяснения каждого шага.

![процесс разработки пакетов советника](../media/server-performance-advisor/spa-dev-guide-dev-flowchart.png)

Обычно пакет ядра СУБД структурированы следующим образом:

Пакет Advisor

ProvisionMetadata.xml

Сценарии

Main.SQL

func.SQL

Schema.man

Каждый пакет advisor необходимо иметь файл с именем ProvisionMetadata.xml. Он определяет сведения о пакете основные advisor, какие данные следует собрать, правила, уведомлениях и отчет должен знать, как сохранение и отображение. Платформы одностраничных ПРИЛОЖЕНИЙ использует эти сведения для создания временной таблицы, а затем передать результаты во временной таблице в таблицу, пользователи могут обращаться к.

Все отчета скрипты SQL, которые должны сохраняться во вложенной папке **сценариев**. Для выполнения задач технического обслуживания рекомендуется сохранять объекты другой базы данных в разные файлы SQL Server. Должно существовать хотя бы одну хранимую процедуру как главную точку входа.

> [!NOTE]
> Файл schema.man не является обязательным, если ваш пакет ядра СУБД собирает трассировки событий Windows. Этот файл схемы используется для описания схемы событий трассировки событий Windows, так и для расшифровки событий трассировки событий Windows.

### <a name="defining-basic-information"></a>Определение основных сведений

В этом разделе описываются некоторые основные элементы, входящие в состав пакета advisor, включая ProvisionMetadata.xml и атрибуты.

Ниже приведен пример заголовка файла ProvisionMetadata.xml.

``` syntax
<advisorPack
xmlns="http://microsoft.com/schemas/ServerPerformanceAdvisor/ap/2010"
name="Microsoft.ServerPerformanceAdvisor.CoreOS.V2"
displayName="Microsoft CoreOS Advisor Pack V2"
description="Microsoft CoreOS Advisor Pack"
author="Microsoft"
version="1.0"
frameworkversion="3.0"
minOSversion="6.0"
reportScript="ReportScript">
</advisorPack>
```

### <a name="advisor-pack-version"></a>Версия пакета Advisor

Имя атрибута: **версии**

Помощник по пакета разработчики могут определять основного и дополнительного номеров версий для пакета помощник по:

* Основной номер версии обычно включает в себя значительные улучшения. Результаты, которые создаются с помощью старой версии может оказаться несовместимым с новым. Мы настоятельно рекомендуем, включая основной номер версии в помощник по имени пакета.

* SPA предназначена для обновления дополнительного номера версии при наличии лишь небольшие изменения без проблем несовместимости данных.

Дополнительные сведения об управлении версиями см. в разделе [дополнительные разделы](#bkmk-advancedtopics).

### <a name="script-entry-point"></a>Точки входа сценариев

Имя атрибута: **reportScript**

SPA framework ищет имя основной хранимой процедуры из точки входа скрипт и запускает его защищенным способом.

### <a name="other-attributes"></a>Другие атрибуты

Ниже приведены некоторые другие атрибуты, которые могут использоваться для идентификации пакета advisor.

* Отображаемое имя: **displayName**

* Описание: **описание**

* Автор: **автора**

* Версии платформы: **frameworkversion** (по умолчанию — 3.0)

* Минимальная версия операционной системы: **minOSversion** (зарезервировано для будущего расширения)

* Потеряно уведомления о событии: **showEventLostWarning**

### <a href="" id="bkmk-definedatacollector"></a>Определение сборщиков данных

Набор сборщиков данных определяет данные производительности, платформы одностраничных ПРИЛОЖЕНИЙ следует собирать с целевого сервера. Он поддерживает счетчики производительности параметры, WMI, реестра и файлы из целевого сервера и трассировки событий Windows.

``` syntax
<advisorPack>
<dataSourceDefinition xmlns="http://microsoft.com/schemas/ServerPerformanceAdvisor/dc/2010">
 <dataCollectorSet duration="10">
<registryKeys>
 ?<registryKey>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes\\</registryKey>
</registryKeys>
<managementpaths>
 ?<path>Root\Cimv2:select * FROM Win32_DiskDrive</path>
</managementpaths>
<performanceCounters interval="2">
 ?<performanceCounter>\PhysicalDisk(*)\Avg. Disk sec/Transfer</performanceCounter>
</performanceCounters>
<files>
 ?<path>%windir%\System32\inetsrv\config\applicationHost.config</path>
</files>
<providers>
 ?<provider session="NT Kernel Logger" guid="{9E814AAD-3204-11D2-9A82-006008A86939}" keywordsany="06010201" keywordsAll="00000000" level="00000000" />
</providers>
 </dataCollectorSet>
</dataSourceDefinition>
</advisorPack>
```

**Длительность** атрибут **&lt;dataCollectorSet /&gt;** в предыдущем примере определяет длительность сбора данных (единица измерения времени — секунд). **длительность** атрибут является обязательным. Этот параметр определяет длительность коллекции, используемой счетчиками производительности и трассировки событий Windows.

### <a name="collect-registry-data"></a>Сбор данных реестра

Вы можете собирать данные реестра из следующих кустов реестра:

* ОТКРЫВАЕМЫЙ РАЗДЕЛ HKEY\_КЛАССЫ\_КОРНЕВОЙ

* Открываемый раздел HKEY\_текущей\_конфигурации

* Открываемый раздел HKEY\_текущей\_пользователя

* ОТКРЫВАЕМЫЙ РАЗДЕЛ HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ

* ОТКРЫВАЕМЫЙ РАЗДЕЛ HKEY\_ПОЛЬЗОВАТЕЛЕЙ

Чтобы собрать параметр реестра, укажите полный путь к имя значения: Открываемый раздел HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\MyKey\\MyValue

Чтобы собрать все параметры в разделе реестра, укажите полный путь к разделу реестра: Открываемый раздел HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\MyKey\\

Чтобы собрать все значения в разделе реестра и его подразделах (PLA рекурсивно выполняет сбор данных реестра), укажите две черты подряд для последнего разделителя пути: Открываемый раздел HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\MyKey\\\\

Чтобы собрать информацию реестра с удаленного компьютера, включают имя компьютера в начале пути в реестре: Открываемый раздел HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\MyKey\\MyValue

Например имеется раздел реестра, который выглядит следующим образом:

``` syntax
Windows registry editor version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes]
"activePowerScheme"="db310065-829b-4671-9647-2261c00e86ef"

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes\db310065-829b-4671-9647-2261c00e86ef]
"Description"=
 FriendlyName = Power Source Optimized 

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes\db310065-829b-4671-9647-2261c00e86ef \0012ee47-9041-4b5d-9b77-535fba8b1442\6738e2c4-e8a5-4a42-b16a-e040e769756e
"ACSettingIndex"=dword:000000b4
"DCSettingIndex"=dword:0000001e
```

Пример 1: Возвращает только активные PowerSchemes и их значения:

``` syntax
<registryKey>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes</registryKey>
```

Пример 2: Возвращает все пары ключ-значение в этом пути:

> [!NOTE]
> PLA выполняется учетные данные пользователя. Некоторые разделы реестра требует учетных данных администратора. Перечисление останавливается, если ей не удается получить доступ к любому из подразделов.

``` syntax
<registryKey>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes\\</registryKey>
```

Все собранные данные будут импортированы во временную таблицу с именем  **\#registryKeys** перед отчета SQL выполняется сценарий. В следующей таблице показаны результаты для примера 2:

keyName | KeytypeId | Значение
------ | ----- | -------
HKEY_LOCAL_MACHINE...\PowerSchemes | 1 | db310065-829b-4671-9647-2261c00e86ef
\db310065-829b-4671-9647-2261c00e86ef\Description | 2 | |
\db310065-829b-4671-9647-2261c00e86ef\FriendlyName | 2 | Источник питания оптимизированных для операций
...\6738e2c4-e8a5-4a42-b16a-e040e769756e\ACSettingIndex | 4 | 180
...\6738e2c4-e8a5-4a42-b16a-e040e769756e\DCSettingIndex | 4 | 30

Схема для **#registryKeys** является таблица базы данных в качестве следующим образом:

Имя столбца | Тип данных SQL | Описание
-------- | -------- | --------
keyName | Nvarchar(300) NOT NULL | Имя полный путь к разделу реестра
KeytypeId | smallint NOT NULL | Внутренний тип идентификатора
Значение | Nvarchar(4000) NOT NULL | Все значения

**KeytypeID** столбец может иметь одно из следующих типов:
ID | Тип
--- | ---
1 | Строка
2 | expandString
3 | Бинарный
4 | DWord
5 | DWordBigEndian
6 | Ссылка
7 | MultipleString
8 | Resourcelist
9 | FullResourceDescriptor
10 | ResourceRequirementslist
11 | QWORD

### <a name="collect-wmi"></a>Собирать WMI

Вы можете добавить любой запрос WMI. Дополнительные сведения о написании запросов WMI см. в разделе [WQL (SQL для WMI)](https://msdn.microsoft.com/library/windows/desktop/aa394606.aspx). В следующем примере запрашивается расположение файла страницы:

``` syntax
<path>Root\Cimv2:select * FROM Win32_PageFileUsage</path>
```

В приведенном выше примере запрос возвращает одну запись:

Заголовок | Имя | PeakUsage
----- | ----- | -----
C:\pagefile.sys | C:\pagefile.sys | 215

Так как WMI возвращает таблицу с различным столбцам, при импорте собранные данные в базу данных, SPA выполняет нормализацию данных и добавляется для следующих таблиц:

**\#Таблица WMIObjects**

SequenceID | Пространство имен | className | Relativepath | WmiqueryID
----- | ----- | ----- | ----- | -----
10 | Root\Cimv2 | Win32_PageFileUsage | Win32_PageFileUsage.Name=<br>C:\\pagefile.sys | 1

**\#Таблица WmiObjectsProperties**

ID | запрос
--- | ---
1 | Root\Cimv2:select * FROM Win32_PageFileUsage

**\#Таблица WmiQueries**

ID | запрос
--- | ---
1 | Root\Cimv2:select * FROM Win32_PageFileUsage

**\#Схема таблицы WmiObjects**

Имя столбца | Тип данных SQL | Описание
--- | --- | ---
SequenceId | int NOT NULL | Сопоставление строки и его свойства
Пространство имен | Nvarchar(200) NOT NULL | Пространство имен WMI
className | Nvarchar(200) NOT NULL | Имя класса WMI
Relativepath | Nvarchar(500) NOT NULL | Относительный путь WMI
WmiqueryId | int NOT NULL | Сопоставлять ключ #WmiQueries

**\#Схема таблицы WmiObjectProperties**

Имя столбца | Тип данных SQL | Описание
--- | --- | ---
SequenceId | int NOT NULL | Сопоставление строки и его свойства
Имя | Nvarchar(1000) NOT NULL | Имя свойства
Значение | Nvarchar(4000) NULL | Значение текущего свойства

**\#Схема таблицы WmiQueries**

Имя столбца | Тип данных SQL | Описание
--- | --- | ---
Id | int NOT NULL | > уникальный идентификатор запроса
запрос | Nvarchar(4000) NOT NULL | Исходная строка запроса в метаданных подготовки

### <a name="collect-performance-counters"></a>Сбор данных счетчиков производительности

Здесь пример того, как сбор данных счетчика производительности:

``` syntax
<performanceCounters interval="1">
  <performanceCounter>\PhysicalDisk(*)\Avg. Disk sec/Transfer</performanceCounter>
</performanceCounters>
```

**Интервал** атрибута требуется параметр действует глобально для всех счетчиков производительности. Он определяет интервал (единица измерения времени секунд) сбора данных о производительности.

В предыдущем примере, счетчик \\физический диск (\*)\\Avg. Диску (сек) будет запрашиваться каждую секунду.

Возможны два экземпляра. **\_Общее** и **0 C: D:**, и выходные данные могут иметь следующий вид:

Метка времени | «Категория» | CounterName | Значение экземпляра _Total | Значение экземпляра 0 C: D:
---- | ---- | ---- | ---- | ----
13:45:52.630 | PhysicalDisk | Ср. Диску (сек) | 0.00100008362473995 |0.00100008362473995
13:45:53.629 | PhysicalDisk | Ср. Диску (сек) | 0.00280023414927187 | 0.00280023414927187
13:45:54.627 | PhysicalDisk | Ср. Диску (сек) | 0.00385999853230048 | 0.00385999853230048
13:45:55.626 | PhysicalDisk | Ср. Диску (сек) | 0.000933297607934224 | 0.000933297607934224

Чтобы импортировать данные в базу данных, данные будут нормализованы в таблицу с именем  **\#PerformanceCounters**.

CategoryDisplayName | InstanceName | CounterdisplayName | Значение
---- | ---- | ---- | ----
PhysicalDisk | _Всего | Ср. Диску (сек) | 0.00100008362473995
PhysicalDisk | 0 C: D: | Ср. Диску (сек) | 0.00100008362473995
PhysicalDisk | _Всего | Ср. Диску (сек) | 0.00280023414927187
PhysicalDisk | 0 C: D: | Ср. Диску (сек) | 0.00280023414927187
PhysicalDisk | _Всего | Ср. Диску (сек) | 0.00385999853230048
PhysicalDisk | 0 C: D: | Ср. Диску (сек) | 0.00385999853230048
PhysicalDisk | _Всего | Ср. Диску (сек) | 0.000933297607934224
PhysicalDisk | 0 C: D: | Ср. Диску (сек) | 0.000933297607934224

**Примечание** локализованные имена, такие как **CategoryDisplayName** и **CounterdisplayName**, различаются в зависимости от отображаемый язык, используемый на целевом сервере. Старайтесь не использовать эти поля, если вы хотите создать пакет ядра СУБД не зависящий от языка.

**\#PerformanceCounters** схемы таблицы

Имя столбца | Тип данных SQL | Описание
---- | ---- | ---- | ----
Метка времени | datetime2(3) NOT NULL | Собранные даты и времени в формате UNC
«Категория» | Nvarchar(200) NOT NULL | Имя категории
CategoryDisplayName | Nvarchar(200) NOT NULL | Имя локализованной категории
InstanceName | Nvarchar(200) NULL | Имя экземпляра
CounterName | Nvarchar(200) NOT NULL | Имя счетчика
CounterdisplayName | Nvarchar(200) NOT NULL | Имя локализованного счетчика
Значение | Число с плавающей запятой не равно NULL | Собранное значение

### <a name="collect-files"></a>Собирать файлы

Пути может быть абсолютным или относительным. Имя файла может содержать подстановочный знак (\*) и вопросительный знак (?). Например, чтобы собрать все файлы во временной папке, можно указать c:\\temp\\\*. Символ-шаблон применяется к файлам в указанной папке.

Если вы хотите также собирать файлы из вложенных папок указанной папки, укажите две черты подряд в поисках последнего папку разделителя, например, c:\\temp\\\\\*.

Здесь пример, который запрашивает **applicationHost.config** файла:

``` syntax
<path>%windir%\System32\inetsrv\config\applicationHost.config</path>
```

Результаты можно найти в таблице, именуемой  **\#файлы**, например:

querypath | FullPath | Свойство Parentpath | имя_файла | Content
----- | ----- | ----- | ----- | -----
%windir%\...\applicationHost.config |C:\Windows<br>\... \applicationHost.config | C:\Windows<br>\... \Config | applicationHost.confi | 0x3C3F78

**\#Схема таблицы файлов**

Имя столбца | Тип данных SQL | Описание
---- | ---- | ----
querypath | Nvarchar(300) NOT NULL | Исходной инструкции запроса
FullPath | Nvarchar(300) NOT NULL | Абсолютный путь к файлу и имя файла
Свойство Parentpath | Nvarchar(300) NOT NULL | Путь к файлу
имя_файла | Nvarchar(300) NOT NULL | Имя файла
Content | Varbinary(max) NULL | Содержимое файла в двоичном файле

### <a name="defining-rules"></a>Определение правил

После сбора достаточного количества данных с помощью PLA на целевом сервере пакет advisor можно использовать эти данные для проверки и итоги быстрого системным администраторам.

Правила обеспечивают с общими сведениями о сервере s производительности. Они быстрее обнаруживать проблемы и давать рекомендации. Можно перечислить все правила, которые вы хотите проверить пакет ядра СУБД. Например если вы хотите разрабатывать пакет ядра СУБД ядра операционной системы, может содержать возможные правила:

* Ли ЦП power режим выполняется сохранение power

* Работает ли сервер в виртуальной среде

* Существует ли Нехватка дискового ввода-вывода

Правила содержат следующие элементы:

* Зависимые пороговое значение (можно настроить часть правила)

* Определение правила (предупреждения и рекомендации)

Здесь приведен пример простого правила:

``` syntax
<advisorPack>
   
  <reportDefinition>
    <thresholds>
      <threshold  />
    </thresholds>
    <rules>
      <rule  />
      </rule>
    </rules>
  </reportDefinition>
</advisorPack>
```

### <a name="threshold"></a>Пороговое значение

Пороговое значение — можно настроить коэффициент, на который позволяет системным администраторам определить, когда правило должно отображаться хорошего или плохого состояния. Следующий пример показывает правило, чтобы обнаружить свободного пространства на системном диске и предупреждение, когда свободного места не превышает 10 ГБ.

``` syntax
<threshold name="freediskSize" caption="Free Disk Size (GB)" description="Free Disk Size  value="10" />
```

Однако в этом случае системный администратор имеет более мелкие жесткий диск. Он думает, 5 ГБ свободного пространства может по-прежнему хорошем состоянии, и он не должен появиться предупреждение. Он можно обновить значение по умолчанию от 10 до 5 через консоль SPA без необходимости понять, как разработать пакет ядра СУБД.

Знакомство с пороговым значением помогает системным администраторам быстро изменить значение без необходимости изменять пакет ядра СУБД.

В примере, все атрибуты, за исключением **описание** являются обязательными. Вы можете использовать любой номер для **значение**.

Пороговое значение может использоваться несколькими правилами.

### <a name="alerts-and-recommendations"></a>Оповещения и рекомендации

Определение правила не затрагивает все вычисления логики. Он определяет, как может выглядеть пользовательского интерфейса и как SQL Server сообщать сценарий передает результаты в пользовательский интерфейс.

Правило состоит из трех частей:

* Предупреждения (правило заголовок)

* Рекомендации (Совет)

* Связанные пороговое значение (Дополнительные сведения о зависимостях)

Ниже приведен пример правила:

``` syntax
<rule name="freediskSize" caption="Free Disk Size on System Drive" description="This rule checks free disk size on system drive ">
<advice name="SuccessAdvice" level="Success" message="No issue found.">No Recommendation.</advice>
<advice name="WarningAdvice" level="Warning" message="Not enough free space on system drive.">
Install OS on larger disk.</advice>
<dependencies>
 <threshold ref="freediskSize"/>
</dependencies>
</rule>
```

Вы можете определить столько советы, как требуется, и обычно определяются рекомендации. **Уровень** совет может быть **успех** или **предупреждение**.

Можно связать с столько пороговые значения, как требуется. Можно даже связывать с пороговым значением, не имеет значения для текущего правила. Связывание помогает консоль SPA, легко управлять пороговые значения.

Имя правила и рекомендации являются ключами, и они являются уникальными в своей области. Два правила не может иметь то же имя, а две рекомендации в одно правило не может быть тем же именем. Эти имена будут очень важно при написании отчет скрипта SQL. Можно вызвать \[dbo\].\[ SetNotification\] API для задания состояние правила.

### <a name="defining-ui-display-elements"></a>Определение элементов для отображения пользовательского интерфейса

После определения правил, системные администраторы могут просматривать отчет сводки. Тем не менее часто системным администраторам, заинтересованным в объединенные данные, и ему нужны для проверки источников данных, которые использовались в правила производительности.

Продолжая предыдущий пример, пользователю известно, имеется ли недостаточно свободного дискового пространства на системном диске. Пользователи также могут быть заинтересованы в фактический размер свободного места на диске. Группу одно значение используется для хранения и отображения таких результатов. Несколько отдельных значений могут быть сгруппированы и показано в таблице в консоли SPA. Таблица содержит только два столбца, имя и значение, как показано ниже.

Имя | Значение
---- | ----
Свободного места на диске на системном диске (ГБ) | 100
Общего размера диска установлена (ГБ) | 500 

Если пользователь хочет просмотреть список всех жестких дисков, установленные на сервере, а также их размер дисков, мы могли бы вызвать значение списка, который содержит три столбца и несколько строк, как показано ниже.

Disk | Размер места на диске (ГБ) | Общий размер (ГБ)
---- | ---- | ----
0 | 100 | 500
1 | 20 | 320

В состав пакета advisor может быть много таблиц (групп одно значение и значение списка таблиц). Раздел можно использовать для организации и классифицировать эти таблицы.

Таким образом существует три типа элементов пользовательского интерфейса:

* [Разделы](#bkmk-ui-section)

* [Одно значение группы](#bkmk-ui-svg)

* [значение списка таблиц](#bkmk-ui-lvt)

Здесь s пример, показаны элементы пользовательского интерфейса.

``` syntax
<advisorPack>
<dataSourceDefinition/>
<reportDefinition>
 <datatypes>
<datatype .../>
 </datatypes>
 <thresholds/>
 <rule/>
 <sections>
<section .../>
 </sections>
 <singleValues>
<singleValue .../>
 </singleValues>
 <listValues>
<listValue .../>
 </listValues>
</reportDefinition>
</advisorPack>
```

### <a href="" id="bkmk-ui-section"></a>Разделы

Раздел предназначен исключительно для макета пользовательского интерфейса. Он не участвует в каких вычислениях, логических. Каждый единый отчет содержит набор разделов верхнего уровня, у которых нет родительского раздела. Разделы верхнего уровня представлены в виде вкладок в отчете. Состав разделов могут входить подразделах, более 10 уровней. Все подразделы в разделе верхнего уровня, представлены в раскрывающиеся области. Раздел может содержать несколько подразделов, группы одно значение и значение списка таблиц. Группы одно значение и значение списка таблиц представлены в виде таблицы.

Ниже приведен пример раздела верхнего уровня.

``` syntax
<section name="CPU" caption="CPU"/>
```

Имя раздела должно быть уникальным. Он используется как ключ, который может быть связан с помощью других разделах, одно значение группы и значение списка таблиц.

В следующем примере есть атрибут, **родительского**, и указывает на разделе ЦП. CPUFacts является дочерним раздела с именем ЦП. **Родительский** должно ссылаться на предыдущее имя раздела; в противном случае это может привести в цикле.

``` syntax
<section name="CPUFacts" caption="Facts" parent="CPU"/>
```

Следующие группы однозначных имеет атрибут, **разделе**, и он может указывать любой раздел, в зависимости от макета пользовательского интерфейса.

``` syntax
<singleValue name="CPUInformation" section="CPUFacts" caption="Physical CPU Information"> </singleValue>
```

### <a name="data-types"></a>Типы данных

Одно значение группы и таблицы значение списка содержат различные виды данных, таких как string, int и float. Поскольку эти значения хранятся в базе данных SQL Server, можно определить тип данных SQL для каждого свойства данных. Тем не менее определение типа данных SQL — довольно сложными. Вам нужно будет указать длину и точность, который может быть часто меняются.

Чтобы определить логические типы данных, можно использовать первый дочерний  **&lt;reportDefinition /&gt;**, который является, где можно определить сопоставление типа данных SQL и логический тип.

В следующем примере определяется два типа данных. Он **строка** , а другой — **companyCode**.

``` syntax
<datatype name="string" = sqltype="nvarchar(4000)" />
<datatype name="companyCode" sqltype="nvarchar(100)" />
```

Имя типа данных может быть любая допустимая строка. Ниже приведен список допустимых типов данных SQL:

* bigint

* binary

* Бит

* char

* date

* datetime

* datetime2

* datetimeoffset

* decimal

* float

* ssNoversion

* деньги

* nchar

* Numeric

* nvarchar

* real

* smalldatetime

* smallint

* smallmoney

* time

* tinyint

* uniqueidentifier

* varbinary

* varchar

Дополнительные сведения об этих типах данных SQL см. в разделе [типы данных (Transact-SQL)](https://msdn.microsoft.com/library/ms187752.aspx).

### <a href="" id="bkmk-ui-svg"></a>Одно значение группы

Одно значение группы группирует несколько отдельных значений друг с другом, для представления в таблице, как показано ниже.

``` syntax
<singleValue name="Systemoverview" section="SystemoverviewSection" caption="Facts">
<value name="OsName" type="string" caption="Operating system" description="WMI: Win32_OperatingSystem/Caption"/>
<value name="Osversion" type="string" caption="OS version" description="WMI: Win32_OperatingSystem/version"/>
<value name="OsLocation" type="string" caption="OS location" description="WMI: Win32_OperatingSystem/SystemDrive"/>
</singleValue>
```

В предыдущем примере мы определили группу одно значение. Он является дочерним для узла раздела **SystemoverviewSection**. Эта группа имеет одного значения, которые являются **OsName**, **Osversion**, и **OsLocation**.

Одно значение должен иметь атрибут глобальное уникальное имя. В этом примере — глобальное уникальное имя атрибута **Systemoverview**. Уникальное имя будет использоваться для создания соответствующего представления для отчета. Каждое представление содержит префикс **vw**, например vwSystemoverview.

Несмотря на то, что можно определить несколько групп одно значение, не два имени одного значения могут совпадать, даже если они находятся в разных группах. Имя одно значение используется в отчете скрипт SQL для задания значения соответствующим образом.

Можно определить тип данных для каждого одно значение. Допустимые входные данные для **тип** определяется в  **&lt;datatype /&gt;**. Итоговый отчет может выглядеть следующим образом:

**факты**

Имя | Значение
--- | ---
Операционная система | &lt;_значение устанавливается сценарием отчета_&gt;
Версия ОС | &lt;_значение устанавливается сценарием отчета_&gt;
Расположение ОС | &lt;_значение устанавливается сценарием отчета_&gt;

**Заголовок** атрибут **&lt;значение /&gt;** представлены в первом столбце. В столбце значения устанавливаются в будущем с помощью скрипта отчета через \[dbo\].\[ SetSingleValue\]. **Описание** атрибут **&lt;значение /&gt;** отображается во всплывающей подсказке. Как правило, подсказка отображается пользователям источник данных. Дополнительные сведения о всплывающих подсказках см. в разделе [подсказки](#bkmk-tooltips).

### <a href="" id="bkmk-ui-lvt"></a>значение списка таблиц

Определение значения списка — как аналогично определению таблицы.

``` syntax
<listValue name="NetworkAdapterInformation" section="NetworkIOFacts" caption="Physical network adapter information">
<column name="NetworkAdapterId" type="string" caption="ID" description="WMI: Win32_NetworkAdapter/DeviceID"/>
<column name="NetworkAdapterName" type="string" caption="Name" description="WMI: Win32_NetworkAdapter/Name"/>
<column name="type" type="string" caption="type" description="WMI: Win32_NetworkAdapter/Adaptertype"/>
<column name="Speed" type="decimal" caption="Speed (Mbps)" description="WMI: Win32_NetworkAdapter/Speed"/>
<column name="MACaddress" type="string" caption="MAC address" description="WMI: Win32_NetworkAdapter/MACaddress"/>
</listValue>
```

Имя списка значение должно быть глобально уникальным. Это имя станет именем временной таблицы. В предыдущем примере, таблица с именем \#NetworkAdapterInformation будет создан на этапе инициализации среды выполнения, который содержит все столбцы, которые описаны. Как и имя одно значение, имя списка значение также используется как часть имени настраиваемого представления, к примеру, vwNetworkAdapterInformation.

@type из &lt;столбца /&gt; определяется &lt;datatype /&gt;

Макет пользовательского интерфейса итоговый отчет может выглядеть следующим образом:

**Сведения о физических сетевых адаптерах**

ID | Имя | Тип | Скорость (Мбит/с) | MAC-адрес;
--- | --- | --- | --- | ---
 | <br> | | |
 | | | |


**Заголовок** атрибут &lt;столбца /&gt; отображается как имя столбца и **описание** атрибут &lt;столбца /&gt; отображается в виде всплывающей подсказки для соответствующий заголовок столбца. Обычно подсказка показывает пользователю источник данных. Дополнительные сведения см. в разделе [подсказки](#bkmk-tooltips).

В некоторых случаях таблица может содержать много столбцов и только небольшое число строк, поэтому переключения столбцов и строк может сделать таблицу поиска гораздо лучше. Чтобы переключить столбцов и строк, можно добавить следующий атрибут стиля:

``` syntax
<listValue style="Transpose"  
```

### <a name="defining-charting-elements"></a>Определение построения диаграмм элементы

Можно выбрать любой Статистика ключ и просмотр значений в хронологической диаграммы или диаграмму тренда. Существует два типа статистических данных:

* **Статические статистики** одного значения, который известен во время разработки. Например свободного места на системном диске будет статический статистического показателя.

* **Динамические статистики** может быть неизвестен во время разработки. Например средняя загрузка ЦП для каждого ядра является динамической статистики, поскольку неизвестно, сколько ядер ЦП может в системе во время разработки.

Ключа статистики имеет ограничение, что данные должны быть совместимы с double-тип данных. Он может быть целое число, decimal или строку, которую можно преобразовать в double.

SPA использует группу одно значение для поддержки статического статистики и таблицей значение списка для поддержки динамической статистики. Как определить статический статистики и ключи динамической статистики в следующих разделах.

### <a name="static-statistics"></a>Статические статистики

Как упоминалось ранее, статические статистика не одно значение. Логически любое отдельное значение может быть задан как статический статистического показателя. Тем не менее не имеет смысла для просмотра одно значение, которое не может быть приведен к числовой тип. Чтобы определить статический статистику, можно просто добавить атрибут **trendable** для соответствующего одно значение ключа как показано ниже:

``` syntax
<value name="freediskSize" type="int" trendable="true"  
```

### <a name="dynamic-statistics"></a>Динамические статистики

Ключи динамической статистики не известны во время разработки, поэтому неизвестно количество возможных значений. Тем не менее так как список значений хранятся в нескольких строках, было бы легко использовать таблицу значение списка для хранения динамических статистики.

Например, если необходимо показать диаграммы для средняя загрузка ЦП разных ядер, мы можем определить таблицу со столбцами для **CpuId** и **AverageCpuUsage**:

``` syntax
<listValue name="CpuPerformance">
<column name="CpuId" type="string" caption="CPU ID" columntype="Key"/>
<column name="AverageCpuUsage" type="decimal" caption="Average" columntype="Value"/>
</listValue>
```

Еще один атрибут, **columntype**, может быть **ключ**, **значение**, или **Информационное**. Тип данных **ключ** столбец должен быть типа double или double можно преобразовать. В **ключ** столбца, и те же ключи нельзя вставить в таблицу. **Значение** или **Информационное** столбцов не имеют этого ограничения.

Статистика значения хранятся в **значение** столбцов.

**Информационное** столбцы, как любые другие столбцы в таблицах значение обычного списка. **Информационное** — это тип столбца по умолчанию, если вы не укажете. Такие столбцы не влияют на количество ключей статистики или участвовать в вычислениях, статистические данные, относящиеся.

Продолжая в предыдущем примере, если сервер имеет два ядра ЦП, результат в таблице может выглядеть следующим образом:

CpuId | AverageCpuUsage
:---: | :---:
0 | 10
1 | 30

В то же время ключи два статистики создаются платформой одностраничных ПРИЛОЖЕНИЙ. Одно предназначено для ЦП 0, а другой — для ЦП 1.

Как показано в следующем примере несколько **значение** столбцы с несколькими **ключ** столбцов поддерживается.

CounterName | InstanceName | Среднее | Sum
--- | :---: | :---: | :---:
% загруженности процессора | _Всего | 10 | 20
% загруженности процессора | CPU0 | 20 | 30 

В этом примере имеется два **ключ** столбцы и два **значение** столбцов. SPA создает два ключа статистики для среднего столбца и другой два ключа для столбца Sum. Статистика ключи являются:

* (% Загруженности процессора) counterName и InstanceName (\_общее) / среднее

* (% Загруженности процессора) counterName и InstanceName (CPU0) / среднее

* (% Загруженности процессора) counterName и InstanceName (\_общее) / Sum

* (% Загруженности процессора) counterName и InstanceName (CPU0) / Sum

CounterName и InstanceName, объединяются в виде одного ключа. Комбинированного ключа не может иметь дублирования.

SPA создает много ключей статистики. Некоторые из них могут быть вам интересным, и вы можете скрыть их из пользовательского интерфейса. SPA позволяет разработчикам создавать фильтр для отображения только ключи полезной статистики.

для предыдущего примера, системные администраторы могут только заинтересовать ключей, в которых является InstanceName \_общее число страниц или CPU1. Фильтр можно определить следующим образом:

``` syntax
<listValue name="CpuPerformance">
<column name="CounterName" type="string" columntype="Key"/>
<column name="InstanceName" type="string" columntype="Key">
 <trendableKeyValues>
<value>_Total</value>
<value>CPU1</value>
 </trendableKeyValues>
</column>
<column name="Average" type="decimal" columntype="Value"/>
<column name="Sum" type="decimal" columntype="Value"/>
</listValue>
```

**&lt;trendableKeyValues /&gt;**  можно определить в любой ключевой столбец. Если более чем один столбец ключа имеет фильтр настроен и логики будет применяться.

### <a name="developing-report-scripts"></a>Разработка сценариев отчета

После определения метаданных подготовки мы начнем писать сценарий отчета, который является T-SQL хранимой процедурой.

Существуют **имя** и **reportScript** атрибуты в заголовок метаданных подготовки, как показано ниже:

``` syntax
<advisorPack name="Microsoft.ServerPerformanceAdvisor.CoreOS.V1" reportScript="ReportScript"  
```

Этот сценарий основного отчета называется путем объединения **имя** и **reportScript** атрибуты. В следующем примере будет \[Microsoft.ServerPerformanceAdvisor.CoreOS.V2\].\[ ReportScript\].

``` syntax
create PROCEDURE [Microsoft.ServerPerformanceAdvisor.CoreOS.V2].[ReportScript] AS SET NOCOUNT ON

- Set alert and notification

- Prepare data for report view
```

**Имя** атрибут будет использоваться как имя схемы базы данных, таких как пространство имен. Это правило применяется ко всем объектам базы данных, принадлежащих текущий пакет ядра СУБД, например значение списка и хранимые процедуры.

Это имя схемы перед объекты базы данных, что преимущества:

* Как избежать конфликт имен для пакетов различных advisor

* Повышает безопасность

В базе данных SQL Server, имя схемы по умолчанию — **dbo**. Учетные данные владельца базы данных обычно требуются для работы объектов базы данных в группе **dbo**. Если нам не нужно создавать схему для каждого пакета advisor, весьма вероятно, что два пакета ядра СУБД определит значение списка с таким именем. Это должно быть не имеет значения, поскольку можно ввести имя схемы, чтобы устранить эту проблему. Кроме того отзыв пакета помощник по гораздо проще. Так как объект пакета advisor принадлежит схеме отличное от **dbo**, это позволяет соглашение SPA, чтобы использовать более низким уровнем привилегий пользователя для доступа к ним.

Сценарий обычного отчета выполняет следующие функции:

* Обращений к необработанные собранные данные

* Выполняет вычисления на основе необработанных данных

* Изменения оповещения и рекомендации

* Подготавливает данные для представления отчета

### <a name="access-raw-collected-data"></a>Необработанные собранные данные доступа

Все собранные данные импортируются в следующие соответствующие таблицы. Дополнительные сведения о схеме таблицы см. в разделе [определение сборщиков данных](#bkmk-definedatacollector).

* Реестра

    * \#registryKeys

* WMI

    * \#WMIObjects

    * \#WmiObjectProperties

    * \#WmiQueries

* Счетчик производительности

    * \#PerformanceCounters

* Файл

    * \#Файлы

* Трассировка событий Windows

    * \#События

    * \#EventProperties

### <a name="set-rule-status"></a>Состояние правила набора

\[Dbo\].\[ SetNotification\] API задает состояние правила, чтобы можно было видеть **успех** или **предупреждение** значка в пользовательском Интерфейсе.

* @ruleName nvarchar(50)

* @adviceName nvarchar(50)

Предупреждение и рекомендацию сообщения хранятся в XML-файл метаданных подготовки. Это упрощает управление скрипт отчета.

Изначально состояние каждого правила является н/д. Этот API можно использовать для задания состояния правила, указав имя советы. Уровень уведомления имя будет использоваться как состояние правила.

Вспомните, что мы ранее определили следующее правило:

``` syntax
<rule name="freediskSize" caption="Free Disk Size on System Drive" description="This rule checks free disk size on the system drive ">
<advice name="SuccessAdvice" level="Success" message="No issue found.">No recommendation.</advice>
<advice name="WarningAdvice" level="Warning" message="Not enough free space on system drive.">Install the operating system on a larger disk.</advice>
</rule>
```

При условии, что свободного места — меньше, чем 2 ГБ, мы должны задать правило **предупреждение** уровень. Скрипт SQL будет иметь следующий вид:

``` syntax
if (@freediskSizeInGB < 2)
BEGIN
    exec dbo.SetNotification N'freediskSize', N'WarningAdvice'
END
ELSE
BEGIN
    exec dbo.SetNotification N'freediskSize', N'SuccessAdvice'
END 
```

### <a name="get-threshold-value"></a>Получить пороговое значение

\[Dbo\].\[ GetThreshold\] API возвращает пороговые значения:

* @key nvarchar(50)

* @value выходные данные с плавающей запятой

> [!NOTE]
> Пороговые значения являются парами "имя значение", и в них можно было ссылаться на какие-либо правила. Системные администраторы могут использовать консоль SPA, чтобы настроить пороговые значения.

 Продолжая предыдущий пример, для порогового значения, определение будет следующим:

``` syntax
<thresholds>
  <threshold name="freediskSize" caption="Free Disk Size (GB)" description="Free Disk Size  value="10" />
</thresholds>
<rule name="freediskSize" caption="Free Disk Size on System Drive" description="This rule checks free disk size on system drive ">
<advice name="SuccessAdvice" level="Success" message="No issue found.">No recommendation.</advice>
<advice name="WarningAdvice" level="Warning" message="Not enough free space on the system drive.">
Install the operating system on a larger disk.</advice>
<dependencies>
 <threshold ref="freediskSize"/>
</dependencies>
</rule>
```

Сценарий отчетов могут быть изменены, как показано ниже:

``` syntax
DECLARE @freediskSize FLOat
exec dbo.GetThreshold N freediskSize , @freediskSize output

if (@freediskSizeInGB < @freediskSize)
 
```

### <a name="set-or-remove-the-single-value"></a>Установка или удаление одного значения

\[Dbo\].\[ SetSingleValue\] API задает одно значение:

* @key nvarchar(50)

* @value SQL\_variant

Это значение можно выполнить несколько раз для одного ключа одно значение. Последнее значение сохраняется.

В следующем примере показано, что некоторые определенные отдельные значения:

``` syntax
<singleValue section="Systemoverview" caption="Facts">
<value name="OsName" type="string" caption="Operating System" description="WMI: Win32_OperatingSystem/Caption"/>
<value name="Osversion" type="string" caption="OS version" description="WMI: Win32_OperatingSystem/version"/>
<value name="OsLocation" type="string" caption="OS Location" description="WMI: Win32_OperatingSystem/SystemDrive"/>
</singleValue>
```

Затем можно задать одно значение, как показано ниже:

``` syntax
exec dbo.SetSingleValue N OsName ,  Windows 7 
exec dbo.SetSingleValue N Osversion ,  6.1.7601 
exec dbo.SetSingleValue N OsLocation ,  c:\ 
```

В редких случаях может потребоваться удалить результат, который был ранее установлен с помощью \[dbo\].\[ removeSingleValue\] API.

* @key nvarchar(50)

Следующий скрипт можно использовать для удаления ранее заданного значения.

``` syntax
exec dbo.removeSingleValue N Osversion 
```

### <a name="get-data-collection-information"></a>Получить сведения о сборе данных

\[Dbo\].\[ GetDuration\] API возвращает пользователя, назначенного длительность в секундах для сбора данных:

* @duration int выходных данных

Здесь s пример отчета сценария:

``` syntax
DECLARE @duration int
exec dbo.GetDuration @duration output
```

\[Dbo\].\[ GetInternal\] API Возвращает интервал счетчика производительности. Он может вернуть значение NULL, если текущий отчет не содержит сведений о счетчиках производительности.

* @interval int выходных данных

Здесь s пример отчета сценария:

``` syntax
DECLARE @interval int
exec dbo.GetInterval @interval output
```

### <a name="set-a-list-value-table"></a>Настройте таблицу значение списка

Не существует API для обновлении таблиц значение списка. Тем не менее можно обращаться напрямую к таблицам значение списка. на этапе инициализации будет создан соответствующий временную таблицу для каждого значения в списке.

В следующем примере показано значение таблицы списка:

``` syntax
<listValue name="NetworkAdapterInformation" section="NetworkIOFacts" caption="Physical Network Adapter Information">
<column name="NetworkAdapterId" type="string" caption="ID" description="WMI: Win32_NetworkAdapter/DeviceID"/>
<column name="NetworkAdapterName" type="string" caption="Name" description="WMI: Win32_NetworkAdapter/Name"/>
<column name="type" type="string" caption="type" description="WMI: Win32_NetworkAdapter/Adaptertype"/>
<column name="Speed" type="decimal" caption="Speed (Mbps)" description="WMI: Win32_NetworkAdapter/Speed"/>
<column name="MACaddress" type="string" caption="MAC address" description="WMI: Win32_NetworkAdapter/MACaddress"/>
</listValue>
```

Затем можно написать скрипт SQL для вставки, обновления или удаления результатов:

``` syntax
INSERT INTO #NetworkAdapterInformation (
  NetworkAdapterId,
  NetworkAdapterName,
  type,
  Speed,
  MACaddress
)
VALUES (
   
)
```

## <a name="development-and-debugging"></a>Разработка и отладка


### <a name="writing-logs"></a>Записи журналов

Если информация, которую требуется взаимодействовать для системных администраторов, вы можете сохранять журналы. Есть ли какой-либо журнал для конкретного отчета, желтый баннер отображается в заголовке отчета. В следующем примере показано, как можно создавать журнал:

``` syntax
exec dbo.WriteSystemLog N'Any information you want to show to the system administrators , N Warning 
```

Первый параметр является сообщение, которое вы хотите показать в журнале. Второй параметр — уровень ведения журнала. Допустимые входные данные для второго параметра может быть **Информационное**, **предупреждение**, или **ошибка**.

### <a name="debug"></a>Отладка

Консоль SPA могут работать в двух режимах, отладка или выпуск. Режим выпуска используется по умолчанию, и он очищает все собранные необработанные данные, после создания отчета. Режим отладки сохраняет все необработанные данные в общую папку и базы данных, таким образом, можно отлаживать скрипт отчета, в будущем.

**Для отладки скрипта отчета**

1.  Установка Microsoft SQL Server Management Studio (SSMS).

2.  После запуска SSMS, подключиться к локальному компьютеру\\SQLExpress. Имейте в виду, что необходимо использовать localhost, а не. . В противном случае может не появиться возможность запустить отладчик в SQL Server.

3.  Выполните следующий скрипт, чтобы включить режим отладки:

    ``` syntax
    USE SPADB
    UPdate dbo.Configurations
    SET Value = N'true'
    WHERE Name = N'Debugmode'
    ```

4.  Запустите консоль SPA и запустите помощник по пакет, в котором необходимо выполнить отладку.

5.  Дождитесь завершения задачи. Если отчет успешно создан, вернитесь в SSMS и найдите последнюю задачу.

    ``` syntax
    select TOP 1 * FROM dbo.Tasks OrdER BY Id DESC
    ```

    Например результат может быть:

    Id | SessionId | AdvisoryPackageId | ReportStatusId | LastUpdatetime | ThresholdversionId
    :---: | :---: | :---: | :---: | :---: | :---:
    12 | 17 | 1 | 2 | 2011-05-11 05:35:24.387 | 1

6.  Столько раз, сколько требуется выполнить скрипт отчета для идентификатора 12 можно запустить следующий сценарий:

    ``` syntax
    exec dbo.DebugReportScript 12
    ```

    **Примечание** также можно нажать клавишу F11, чтобы войти в предыдущей инструкции и отладки.

     

Под управлением \[dbo\].\[ DebugReportScript\] возвращает несколько результирующих наборов, в том числе:

1.  Microsoft SQL Server сообщений и журналов пакет ядра СУБД

2.  Результаты правил

3.  Статистика ключи и значения

4.  Отдельные значения

5.  Все таблицы значение списка

## <a name="best-practices"></a>Рекомендации

### <a name="naming-convention-and-styles"></a>Соглашение об именовании и стили

Pascal регистр | Смешанный регистр знаков | верхний регистр
--- | ---- | ---
<ul><li>Names in ProvisionMetadata.xml</li><li>Хранимые процедуры</li><li>Функции</li><li>Имена представлений</li><li>Имена временных таблиц</li></ul> | <ul><li>Имена параметров</li><li>Локальные переменные</li></ul> | Используйте для все Зарезервированные ключевые слова

### <a name="other-recommendations"></a>Другие рекомендации

* Переместите наиболее логических частей в другие хранимые процедуры и определяемые пользователем функции.

* Внести в основном сценарии достаточно кратким для выполнения задач технического обслуживания.

* Используйте полное имя объекта SQL.

* Считайте коде SQL с учетом регистра.

* Добавить **SET NOCOUNT ON** в начале каждой хранимой процедуры.

* Рассмотрите возможность использования временных таблиц для передачи огромное количество данных.

* Рассмотрите возможность использования **УСТАНОВИТЬ XACT\_ON ПРЕРЫВАНИЯ** завершить процесс при возникновении ошибки.

* Всегда включать основной номер версии в отображаемом имени пакет ядра СУБД.

## <a href="" id="bkmk-advancedtopics"></a>Дополнительные разделы

### <a name="run-multiple-advisor-packs-simultaneously"></a>Одновременного выполнения нескольких пакетов советника

SPA поддерживает запуск нескольких пакетов советника в то же время. Это особенно полезно, если вы хотите изучить Internet Information Services (IIS) и производительность ядра операционной системы, в то же время. Многие сборщиков данных, которые используются пакетом помощник по IIS также может использоваться пакетом advisor Core ОС. При выполнении на том же компьютере две или несколько пакетов advisor SPA не собирает те же данные дважды.

В следующем примере показано рабочего процесса для запуска двух пакетов advisor.

![Запуск нескольких пакетов советника](../media/server-performance-advisor/spa-dev-guide-multi-advisor-packs.png)

Средство слияния сборщиков данных — только для сбора данных счетчиков производительности и источников данных трассировки событий Windows. Применяются следующие правила объединения.

1.  SPA принимает крупнейших длительности новый срок действия.

2.  При наличии конфликтов слияния соблюдаются следующие правила:

    1.  Наименьший интервал принимают в качестве нового интервала.

    2.  Воспользуйтесь super набор счетчиков производительности. Например, с помощью **процесса (\*)\\% загруженности процессора** и **процесса (\*)\\\*,\\процесса (\*)\\ \***  возвращает дополнительные данные, поэтому **процесса (\*)\\% загруженности процессора** и **процесса (\*)\\ \***  удаляется из сборщиков объединенных данных.

### <a name="collect-dynamic-data"></a>Собирать динамические данные

Потребности SPA, сборщиков данных на время разработки. Не всегда возможно узнать, какие данные необходимы для создания отчетов, так как динамические данные и путь запроса неизвестны до его зависимые данные недоступны.

Например если требуется получить список всех понятные имена сетевых адаптеров, сначала необходимо запросить WMI для перечисления всех сетевых адаптеров. Каждая возвращенная WMI-объект содержит путь к разделу реестра, где хранятся понятное имя. Путь к разделу реестра неизвестен во время разработки. В этом случае динамические данные должны поддерживать.

Чтобы перечислить все сетевые адаптеры, можно использовать следующий запрос WMI с помощью Windows PowerShell:

``` syntax
Get-WmiObject -Namespace Root\Cimv2 -query "select PNPDeviceID FROM Win32_NetworkAdapter" | forEach-Object { Write-Output $_.PNPDeviceID }
```

Он возвращает список объектов сетевых адаптеров. Каждый объект имеет свойство с именем **код PnP-устройства**, содержит путь к разделу, относительный реестра. Здесь пример выходных данных из предыдущего запроса:

``` syntax
ROOT\*ISatAP\0001
PCI\VEN_8086&DEV_4238&SUBSYS_11118086&REV_35\4&372A6B86&0&00E4
ROOT\*IPHTTPS\0000
 
```

Чтобы найти **FriendlyName** значение, откройте редактор реестра и перейдите в раздел реестра путем объединения **HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\системы\\ CurrentControlSet\\перечисления\\**  каждая строка в предыдущем примере. Например: **Открываемый раздел HKEY\_ЛОКАЛЬНОГО\_МАШИНЫ\\системы\\CurrentControlSet\\перечисления\\ КОРНЕВОЙ\\\*IPHTTPS\\0000**.

Чтобы перевести предыдущие шаги в SPA подготовки метаданные, добавьте скрипт в следующем образце кода.

``` syntax
<advisorPack>
<dataSourceDefinition xmlns="http://microsoft.com/schemas/ServerPerformanceAdvisor/dc/2010">
 <dataCollectorSet >
<registryKeys>
 ?<registryKey>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\$(NetworkAdapter.PNPDeviceID)\FriendlyName</registryKey>
</registryKeys>
<managementpaths>
 ?<path name="NetworkAdapter">Root\Cimv2:select PNPDeviceID FROM Win32_NetworkAdapter</path>
</managementpaths>
```

В этом примере вы сначала добавить запрос WMI, в разделе managementpaths и определить имя ключа **сетевого адаптера**. Добавление раздела реестра и ссылаться на **сетевого адаптера** с помощью синтаксиса, **$(NetworkAdapter.PNPDeviceID)**.

В следующей таблице определены, если сборщик данных в SPA поддерживает динамические данные и ли он позволяет ссылаться на другие сборщики данных:

Тип данных | Поддержка динамических данных | Можно ссылаться
--- | :---: | :---:
Раздел реестра | Да | Да
WMI | Да | Да
Файл | Да | Нет
Счетчик производительности | Нет | Нет
Трассировка событий Windows | Нет | Нет

Для сборщика данных WMI каждый объект WMI имеет много вложенных атрибутов. Любой тип объекта WMI имеет три атрибута: \_\_Пространство ИМЕН, \_ \_КЛАССА, и \_ \_RELpath.

Для определения группы сборщиков данных, на который ссылается других сборщиках данных, назначить **имя** атрибут с уникальным ключом в ProvisionMetadata.xml. Этот ключ используется сборщики данных зависимых для создания динамических данных.

Здесь приведен пример для раздела реестра:

``` syntax
<registryKey  name="registry">HKEY_LOCAL_MACHINE </registryKey>
```

И пример для WMI:

``` syntax
<path name="wmi">Root\Cimv2:select PNPDeviceID FROM Win32_NetworkAdapter</path>
```

Чтобы определить данные, зависящие от сборщика, используется следующий синтаксис: $(*{name}*.*{атрибут}*).

*{name}*  и *{атрибут}* представляют собой заполнители.

Собирая данные одностраничного приложения на целевом сервере, он динамически заменяет шаблон $(\*.\*) с фактическим собранных данных с его ссылку сборщика данных (раздел реестра / WMI), например:

``` syntax
<registryKey>HKEY_LOCAL_MACHINE\$(registry.key)\ </registryKey>
<registryKey  name="registry">HKEY_LOCAL_MACHINE\$(wmi.Relativeregistrypath)\ </registryKey>
<path name="wmi"> </path>
<file>$(wmi.FileName)</file>
```

**Примечание** SPA поддерживает неограниченное глубину ссылку, однако следует учитывать нагрузку на производительность, если имеется слишком много уровней. Убедитесь, что нет циклических ссылок или рекурсивная ссылка, не поддерживается.

### <a name="versioning-limitations"></a>ограничений управления версиями

SPA поддерживает сброс и дополнительного номеров версий обновления. Эти процессы используют одинаковый алгоритм. Процесс выполняется в том, чтобы обновить все объекты базы данных и параметры порогового значения, но сохранить существующие данные. Это может быть обновление до более поздней версии или обратный переход к ранней версии. Выберите пакет advisor и нажмите кнопку **Сброс** в **настроить пакеты Advisor** диалоговое окно, в соглашение SPA, чтобы сбросить или применить или обновления.

Эта функция предназначена главным образом для незначительные изменения. Невозможно изменить значительно отображения элементов пользовательского интерфейса. Если вы хотите внести значительные изменения, необходимо создать пакет разных advisor. Основной номер версии следует включить в помощник по имени пакета.

Ограничения изменения дополнительного номера версии, которые вы **нельзя** выполните одно из следующих:

* Измените имя схемы

* Изменить тип данных, ни в одну группу одно значение или столбцы таблицы значение списка

* Добавление или удаление пороговых значений

* Добавление или удаление правила

* Добавление или удаление рекомендации

* Добавить или удалить отдельные значения

* Добавление или удаление значения списка

* Добавить или удалить столбец из списка значений

### <a href="" id="bkmk-tooltips"></a>Всплывающие подсказки

Почти все **описание** атрибуты будут отображаться как всплывающая подсказка, в консоли SPA.

для таблицы значение списка всплывающей подсказки на уровне строк можно сделать, добавив следующий атрибут:

``` syntax
<listValue descriptionColumn="Description">
<column name="Name"/>
<column name="Description"/>
</listValue>
```

**DescriptionColumn** атрибут ссылается на имя столбца. В этом примере столбец не отображается как физический столбца. Тем не менее он показывает виде всплывающей подсказки при наведении указателя мыши на цикле каждую строку первого столбца.

Мы рекомендуем отображать что подсказки источника данных для пользователя. Ниже приведены форматы для отображения источников данных:

Источник данных | Формат | Пример
--- | --- | ---
WMI | WMI: &lt;wmiclass&gt;/&lt;поля&gt; | WMI: Win32_OperatingSystem/заголовок
Счетчик производительности | PerfCounter: &lt;CategoryName&gt;/&lt;имя_экземпляра&gt; | PerfCounter: Process/% загруженности процессора
Реестра | реестр: &lt;registerKey&gt; | Реестр: HKLM\SOFTWARE\Microsoft<br>\\ASP.NET\\Rootver
Файл конфигурации | ConfigFile: &lt;FILEPATH&gt;\[; XPath: &lt;XPath&gt;\]<br>**Примечание**<br>XPath является необязательным и допустима только в том случае, если файл является XML-файл. | ConfigFile: % windir\\System32\\inetsrv\config\\applicationHost.config<br>XPath: Конфигурация&frasl;system.webServer<br>&frasl;httpProtocol&frasl;@allowKeepAlive
Трассировка событий Windows | ETW: &lt;Поставщик /&gt;(ключевые слова) | ETW: Трассировка ядра Windows (процесс, net)

### <a name="table-collation"></a>Параметры сортировки таблицы

Когда пакет ядра СУБД становится более сложным, можно создать собственные переменных и временных таблиц для хранения промежуточных результатов в скрипте отчета.

Задать параметры сортировки строковых столбцов может оказаться проблемой, так как параметры сортировки таблицы, создаваемой может отличаться от того, который создается платформой одностраничных ПРИЛОЖЕНИЙ. Если вы направляете два строковых столбца, в разных таблицах, может появиться ошибка параметров сортировки. Чтобы избежать этой проблемы, всегда следует определить строку для параметров сортировки столбца как **SQL\_Latin1\_Общие\_CP1\_CI\_AS** при определении таблицы.

Здесь s как для определения переменных таблицы:

``` syntax
DECLARE @filesIO TABLE (
 Name nvarchar(500) COLLatE SQL_Latin1_General_CP1_CI_AS,
 AverageFileAccessvolume float,
 AverageFileAccessCount float,
 Filepath nvarchar(500) COLLatE SQL_Latin1_General_CP1_CI_AS
)
```

### <a name="collect-etw"></a>Сбор трассировки событий Windows

Здесь s определение трассировки событий Windows в файле ProvisionMetadata.xml:

``` syntax
<dataSourceDefinition>
  <providers>
    <provider session="NT Kernel Logger" guid="{9E814AAD-3204-11D2-9A82-006008A86939}"/>
  </providers>
</dataSourceDefinition>
```

Следующие атрибуты поставщика можно использовать для сбора трассировки событий Windows:

Атрибут | Тип | Описание
--- | --- | ---
guid | Код GUID | GUID поставщика
сеанс | строка | Имя сеанса трассировки событий Windows (необязательно, требуется только для событий ядра)
keywordsany | Hex | Любые ключевые слова (необязательный, без префикса 0 x)
keywordsAll | Hex | Все ключевые слова (необязательно)
свойства | Hex | Свойства (необязательно)
уровень | Hex | Уровень (необязательно)
BufferSize | int | Размер буфера (необязательно)
flushtime | int | Очистить времени (необязательно)
maxBuffer | int | Максимальный размер буфера (необязательно)
minBuffer | int | Минимальный размер буфера (необязательно)

Существует две таблицы выходных данных, как показано ниже.

**\#Схема таблицы событий**

Имя столбца | Тип данных SQL | Описание
--- | --- | ---
SequenceID | int NOT NULL | Идентификатор корреляции последовательности
EventtypeId | int NOT NULL | Идентификатор типа событий (см. [dbo]. [ Eventtypes])
ProcessId | BigInt не равно NULL | Идентификатор процесса
ThreadId | BigInt не равно NULL | Идентификатор потока
Метка времени | datetime2 NOT NULL | Метка времени
Kerneltime | BigInt не равно NULL | Время ядра
Usertime | BigInt не равно NULL | В пользовательском режиме

**\#Схема таблицы EventProperties**

Имя столбца | Тип данных SQL | Описание
--- | --- | ---
SequenceID | int NOT NULL | Идентификатор корреляции последовательности
Имя | Nvarchar(100) | Имя свойства
Значение | Nvarchar(4000) | Значение

### <a name="etw-schema"></a>Схема трассировки событий Windows

Схема трассировки событий Windows можно создать, выполнив tracerpt.exe для ETL-файла. Создается отдельный файл schema.man. Так как формат ETL-файла зависимые компьютерах, приведенный ниже сценарий работает только в следующих ситуациях:

1.  Запустите сценарий на компьютере, где собираются соответствующий ETL-файла.

2.  Или запустите скрипт на компьютере с той операционной системы и установленных компонентов.

``` syntax
tracerpt *.etl -export
```

## <a name="glossary"></a>Глоссарий


В этом документе используются следующие термины:

**Пакет Advisor**

Пакет ядра СУБД является коллекцией метаданных и скрипты SQL, которые обрабатывают журналов производительности, собираемых с целевого сервера. Затем пакет advisor создает отчеты на основе данных журнала производительности. Метаданные в пакет advisor определяет данные, собираемых с целевого сервера для измерения производительности. Метаданные также определяет набор правил, пороговые значения и формат отчета. Чаще всего пакет ядра СУБД записывается специально для роли один сервер, например, Internet Information Services (IIS).

**Консоль SPA**

Консоль SPA ссылается на SpaConsole.exe, который является центральной частью Server Performance Advisor. SPA не должны выполняться на целевой сервер, который вы тестируете. Консоль SPA содержит все пользовательские интерфейсы для одностраничного приложения, от настройки проекта для выполнения анализа и просмотр отчетов. По своей структуре SPA является 2 уровневого приложения. Консоль SPA содержит слой пользовательского интерфейса и части бизнес-логики. Консоль SPA планирует и обрабатывает запросы анализа производительности.

**Платформы одностраничных ПРИЛОЖЕНИЙ**

SPA содержит двух основных частей, платформы и пакеты advisor. Платформы одностраничных ПРИЛОЖЕНИЙ предоставляет все пользовательские интерфейсы, обработка журнала производительности, конфигурации, обработка ошибок и процедур управления и интерфейсы API баз данных.

**Проект одностраничного приложения**

Проект одностраничного приложения является базой данных, содержащий все сведения о целевых серверах, пакеты advisor и отчеты об анализе производительности, которые создаются на целевых серверах для пакетов advisor. Можно сравнить и просматривать журнал и тенденции диаграммы в один и тот же проект SPA. Пользователь может создать более одного проекта. Проекты SPA независимо друг от друга и нет данных, используемых проектами.

**целевой сервер**

Целевой сервер является физическом компьютере или виртуальной машины, сервер Windows запускается с определенными ролями сервера, такими как службы IIS.

**Сеанс анализа данных**

Сеанс анализа данных — анализа производительности на указанном целевом сервере. Сеанс анализа данных может включать несколько пакетов advisor. Наборы сборщиков данных из этих пакетов advisor объединяются в набора сборщиков данных single. Все журналы производительности для сеанса анализа данных собираются в процессе тот же период времени. Анализ отчетов, создаваемых пакетов advisor, в том же сеансе анализа данных может помочь пользователям понять общую производительность ситуации и определить основные причины проблем с производительностью.

**События трассировки событий Windows**

[Трассировка событий](https://msdn.microsoft.com/library/windows/desktop/bb968803.aspx) для Windows (ETW) — это система высокой производительности, низкими издержками, масштабируемое трассировки, который предоставляется в операционных системах Windows. Он предоставляет возможности, которые можно использовать для устранения неполадок в разнообразных сценариях отладки и профилирования. SPA использует события трассировки событий Windows в качестве источника данных для создания отчетов о производительности. Общие сведения о трассировке событий Windows см. в разделе [улучшение отладки и настройки производительности с помощью ETW](https://msdn.microsoft.com/magazine/cc163437.aspx).

**Запрос WMI**

Инструментарий управления Windows (WMI) представляет собой инфраструктуру для управления данными и выполнения операций в операционных системах Windows. Можно написать скрипты WMI или приложения, автоматизировать задачи администрирования на удаленных компьютерах. WMI также предоставляет данные управления с другими частями операционной системы, а также продуктов. SPA использует сведения о классе WMI и точек данных в качестве источников для создания отчетов о производительности.

**Счетчики производительности**

Счетчики производительности используются для предоставления сведений о том, как хорошо работает операционной системы или приложения, службы или драйвера. Данные счетчика производительности помогает определить узкие места и оптимизировать производительность системы и приложения. На операционной системе, сети и устройства предоставляют данные счетчика, который приложение может использовать для предоставления пользователям графическое представление того, насколько хорошо работает система. SPA использует сведений о счетчиках производительности и точек данных в качестве источников для создания отчетов о производительности.

**Журналы и оповещения производительности**

Журналы производительности и оповещения (PLA) является встроенной службой в операционной системе Windows. Он разработанным для сбора журналов производительности и трассировки, и он также выдает предупреждения о производительности, при соблюдении определенных триггеров. PLA можно использовать для сбора данных счетчиков производительности, трассировки событий для Windows (ETW), запросы WMI, разделов реестра и конфигурации файлы. PLA также поддерживает удаленный сбор данных через удаленные вызовы процедур (RPC). Пользователь определяет набор сборщиков данных, включающее информацию о собираемых данных, частота сбора данных, длительность сбора данных, фильтров и расположение для сохранения файлов результат. SPA использует PLA для сбора всех данных производительности из целевых серверов.

**Один отчет**

Один отчет является созданный отчет SPA, основанные на один сеанс анализа данных для одного пакета advisor на одном целевом сервере. Оно может содержать уведомлений и различные разделы данных.

**Отчет Side-by-side**

Side-by-side отчет является отчетом SPA, сравнивает два одного отчета для один и тот же пакет ядра СУБД. Два отчета могут создаваться из разных целевых серверов или отдельные производительность анализа запусков на том же целевом сервере. Отчет side-by-side создает возможность сравнивать два отчета, которые помогут пользователям определить ненормальное поведение или параметры в один из отчетов. Side-by-side отчет содержит уведомления и различные разделы данных. В каждом разделе данные из обоих отчетов являются перечисленных side-by-side.

**Диаграмма тренда**

Диаграмма тренда — отчет SPA, который используется для изучения повторяющихся шаблонов проблем с производительностью. Много повторяющихся производительности проблемы вызваны изменения нагрузки запланированных сервера с сервера или из клиентских компьютеров, что может случиться, ежедневно или еженедельно. SPA предоставляет 24-часовой график и график 7 дней для выявления этих проблем.

Пользователь может выбрать один или несколько рядов данных одновременно, который является числовым значением внутри одного отчета, такие как **среднее общее использование ЦП**. в частности числовое значение получается скалярное значение из одного сервера, созданного одной точки беспроводного доступа на момент времени экземпляр. SPA группирует эти значения в 24 групп, по одной для каждого часа дня (семь для отчета, 7 дней, один для каждого дня недели). SPA вычисляет среднее, минимальное, максимальное и стандартные отклонения для каждой группы.

**Статистическая диаграмма**

Статистическая диаграмма — отчет SPA, который используется для отображения изменения в некоторые числовые значения внутри одной отчеты для данного сервера и пары пакет ядра СУБД за период времени. Пользователь может выбрать несколько рядов данных и отобразить их в Хронологическая диаграмма, чтобы понять взаимосвязь между другому ряду данных.

**Ряд данных**

Ряд данных — числовые данные, собираемые из одного источника данных за период времени. Тот же источник означает, что данные должен поступать от одного целевого сервера, такое как длина очереди запроса среднего для служб IIS на одном сервере.

**правила**

Правила являются сочетаниями логики, пороговые значения и описания. Они представляют собой потенциальные проблемы производительности. Каждый пакет advisor содержит несколько правил. Каждое правило активируется процесса создания отчета. Пороговые значения и логика применяется правило, к данным в одном отчете. Если условия выполнены, возникает предупреждение уведомление. Если нет, уведомление **ОК** состояния. Если правило не применяется, уведомление будет присвоено не применяется (**NA**) состояние.

**Уведомления**

Уведомления — это сведения, отображаемые для пользователей в правиле. Он включает в себя состояние правила (**ОК**, **NA**, или **предупреждение**), имя правила и возможных рекомендаций для решения проблем производительности.

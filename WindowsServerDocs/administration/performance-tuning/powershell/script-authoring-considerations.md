---
title: Вопросы производительности сценариев PowerShell
description: Создание сценариев для производительности в PowerShell
ms.topic: article
ms.author: jasonsh
author: lzybkr
ms.date: 10/16/2017
ms.openlocfilehash: fc6be9ef894e7d427c6abb7d8f00e77d52610af5
ms.sourcegitcommit: 5f234fb15c1d0365b60e83a50bf953e317d6239c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/05/2021
ms.locfileid: "97879533"
---
# <a name="powershell-scripting-performance-considerations"></a>Вопросы производительности сценариев PowerShell

Скрипты PowerShell, которые используют .NET напрямую и не имеют возможности конвейера, работают быстрее, чем идиоматическим PowerShell. Идиоматическим PowerShell обычно использует командлеты и функции PowerShell интенсивно, часто с использованием конвейера и переключается в .NET только при необходимости.

>[!Note]
> Многие из описанных здесь методик не идиоматическим PowerShell и могут уменьшить удобочитаемость сценария PowerShell. Авторы сценариев рекомендуется использовать идиоматическим PowerShell, если в противном случае производительность не будет зависеть.

## <a name="suppressing-output"></a>Подавление вывода

Существует множество способов избежать записи объектов в конвейер:

```PowerShell
$null = $arrayList.Add($item)
[void]$arrayList.Add($item)
```

Присваивание `$null` или приведение к `[void]` имеет примерно одинаковые эквиваленты и должны быть предпочтительными, когда производительность имеет значение.

```PowerShell
$arrayList.Add($item) > $null
```

Перенаправление файлов `$null` почти так же хорошо, как и предыдущие альтернативы, большинство сценариев никогда не заметит разницы.
В зависимости от сценария перенаправление файла приводит к незначительной нагрузке.

```PowerShell
$arrayList.Add($item) | Out-Null
```

`Out-Null`При сравнении с альтернативными вариантами по конвейеру направляется значительные издержки.
Это следует избегать в коде, чувствительном к производительности.

```PowerShell
$null = . {
    $arrayList.Add($item)
    $arrayList.Add(42)
}
```

Введение в блок скрипта и его вызов (с использованием точки или иным способом), то назначение результата `$null` является удобным методом для подавления вывода большого блока скрипта.
Этот метод выполняет примерно так же, как и конвейер, `Out-Null` и следует избегать в сценарии с учетом производительности.
Дополнительные издержки в этом примере берутся из создания и вызова блока сценария, который ранее был встроенным сценарием.


## <a name="array-addition"></a>Добавление массива

Создание списка элементов часто выполняется с помощью массива с оператором сложения:

```PowerShell
$results = @()
$results += Do-Something
$results += Do-SomethingElse
$results
```

Это может быть очень инеффицент, так как массивы являются неизменяемыми.
Каждое добавление к массиву фактически создает новый массив, достаточно большой для хранения всех элементов обоих операндов и левого и правого. затем копирует элементы обоих операндов в новый массив.
Для небольших коллекций эта дополнительная нагрузка может не иметь значения.
Для больших коллекций это может быть проблемой.

Существует несколько альтернативных вариантов.
Если массив не требуется, рекомендуется использовать ArrayList:

```PowerShell
$results = [System.Collections.ArrayList]::new()
$results.AddRange((Do-Something))
$results.AddRange((Do-SomethingElse))
$results
```

Если требуется массив, можно использовать собственный `ArrayList` метод и просто вызвать, `ArrayList.ToArray` Если требуется массив.
Кроме того, можно разрешить PowerShell создавать `ArrayList` и `Array` для вас:

```PowerShell
$results = @(
    Do-Something
    Do-SomethingElse
)
```

В этом примере PowerShell создает объект `ArrayList` для хранения результатов, записанных в конвейер внутри выражения массива.
Непосредственно перед назначением в `$results` PowerShell преобразует в `ArrayList` `object[]` .

## <a name="processing-large-files"></a>Обработка больших файлов

Идиоматическим способ обработки файла в PowerShell может выглядеть примерно так:

```PowerShell
Get-Content $path | Where-Object { $_.Length -gt 10 }
```

Это может быть практически более медленнее, чем использование API-интерфейсов .NET.

```PowerShell
try
{
    $stream = [System.IO.StreamReader]::new($path)
    while ($line = $stream.ReadLine())
    {
        if ($line.Length -gt 10)
        {
            $line
        }
    }
}
finally
{
    $stream.Dispose()
}
```

## <a name="avoid-write-host"></a>Избегайте Write-Host

Как правило, не рекомендуется записывать выходные данные непосредственно в консоль, но когда это имеет смысл, многие сценарии используют `Write-Host` .

Если на консоль необходимо записывать большое количество сообщений, `Write-Host` может быть задан порядок, меньший, чем `[Console]::WriteLine()` . Однако следует иметь в виду, что `[Console]::WriteLine()` является только подходящим альтернативом для конкретных узлов, таких как powershell.exe или powershell_ise.exe-не гарантируется работа на всех узлах.

Вместо использования `Write-Host` рекомендуется использовать [Write-Output](/powershell/module/Microsoft.PowerShell.Utility/Write-Output?view=powershell-5.1&preserve-view=true).


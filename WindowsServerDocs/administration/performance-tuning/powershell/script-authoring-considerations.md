---
title: Вопросы производительности сценариев PowerShell
description: Создание сценариев для производительности в PowerShell
ms.prod: windows-server
ms.technology: performance-tuning-guide
ms.topic: article
ms.author: jasonsh
author: lzybkr
ms.date: 10/16/2017
ms.openlocfilehash: f22a4f1ba5c0f048e2aa01c744feb3b2b83007a0
ms.sourcegitcommit: b00d7c8968c4adc8f699dbee694afe6ed36bc9de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2020
ms.locfileid: "80851927"
---
# <a name="powershell-scripting-performance-considerations"></a>Вопросы производительности сценариев PowerShell

Скрипты PowerShell, которые используют .NET напрямую и не имеют возможности конвейера, работают быстрее, чем идиоматическим PowerShell. Идиоматическим PowerShell обычно использует командлеты и функции PowerShell интенсивно, часто с использованием конвейера и переключается в .NET только при необходимости.

>[!Note] 
> Многие из описанных здесь методик не идиоматическим PowerShell и могут уменьшить удобочитаемость сценария PowerShell. Авторы сценариев рекомендуется использовать идиоматическим PowerShell, если в противном случае производительность не будет зависеть.

## <a name="suppressing-output"></a>Подавление вывода

Существует множество способов избежать записи объектов в конвейер:

```PowerShell
$null = $arrayList.Add($item)
[void]$arrayList.Add($item)
```

Присваивание `$null` или приведению к `[void]`ам приблизительно эквивалентно и должны быть предпочтительнее, когда производительность имеет значение.

```PowerShell
$arrayList.Add($item) > $null
```

Перенаправление файлов в `$null` почти так же хорошо, как и в предыдущих вариантах, большинство сценариев никогда не заметит разницы.
В зависимости от сценария перенаправление файла приводит к незначительной нагрузке.

```PowerShell
$arrayList.Add($item) | Out-Null
```

Передача по конвейеру `Out-Null` имеет значительные издержки по сравнению с альтернативными вариантами.
Это следует избегать в коде, чувствительном к производительности.

```PowerShell
$null = . {
    $arrayList.Add($item)
    $arrayList.Add(42)
}
```

Введение в блок скрипта и его вызов (с использованием точки или иным способом). назначение результата `$null` является удобным методом для подавления выходных данных большого блока скрипта.
Этот метод выполняет примерно так же, как конвейер, `Out-Null` и следует избегать в сценарии с учетом производительности.
Дополнительные издержки в этом примере берутся из создания и вызова блока сценария, который ранее был встроенным сценарием.


## <a name="array-addition"></a>Добавление массива

Создание списка элементов часто выполняется с помощью массива с оператором сложения:

```PowerShell
$results = @()
$results += Do-Something
$results += Do-SomethingElse
$results
```

Это может быть очень инеффицент, так как массивы являются неизменяемыми.
Каждое добавление к массиву фактически создает новый массив, достаточно большой для хранения всех элементов обоих операндов и левого и правого. затем копирует элементы обоих операндов в новый массив.
Для небольших коллекций эта дополнительная нагрузка может не иметь значения.
Для больших коллекций это может быть проблемой.

Существует несколько альтернативных вариантов.
Если массив не требуется, рекомендуется использовать ArrayList:

```PowerShell
$results = [System.Collections.ArrayList]::new()
$results.AddRange((Do-Something))
$results.AddRange((Do-SomethingElse))
$results
```

Если требуется массив, можно использовать собственный `ArrayList` и просто вызвать метод `ArrayList.ToArray`, если требуется массив.
Кроме того, можно разрешить PowerShell создавать `ArrayList` и `Array`:

```PowerShell
$results = @(
    Do-Something
    Do-SomethingElse
)
```

В этом примере PowerShell создает `ArrayList` для хранения результатов, записанных в конвейер внутри выражения массива.
Непосредственно перед назначением `$results`PowerShell преобразует `ArrayList` в `object[]`.

## <a name="processing-large-files"></a>Обработка больших файлов

Идиоматическим способ обработки файла в PowerShell может выглядеть примерно так:

```PowerShell
Get-Content $path | Where-Object { $_.Length -gt 10 }
```

Это может быть практически более медленнее, чем использование API-интерфейсов .NET.

```PowerShell
try
{
    $stream = [System.IO.StreamReader]::new($path)
    while ($line = $stream.ReadLine())
    {
        if ($line.Length -gt 10)
        {
            $line
        }
    }
}
finally
{
    $stream.Dispose()
}
```

## <a name="avoid-write-host"></a>Избегайте Write-Host

Как правило, не рекомендуется записывать выходные данные непосредственно в консоль, но когда это имеет смысл, многие скрипты используют `Write-Host`.

Если в консоль необходимо записывать много сообщений, `Write-Host` может быть медленнее, чем `[Console]::WriteLine()`. Однако следует иметь в виду, что `[Console]::WriteLine()` является только подходящей альтернативой для конкретных узлов, таких как PowerShell. exe или powershell_ise. exe — не гарантируется работа на всех узлах.

Вместо использования `Write-Host`рассмотрите возможность использования [Write-Output](/powershell/module/Microsoft.PowerShell.Utility/Write-Output?view=powershell-5.1).


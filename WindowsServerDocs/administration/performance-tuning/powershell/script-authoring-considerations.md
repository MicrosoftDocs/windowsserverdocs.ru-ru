---
title: Рекомендации по производительности сценариев в PowerShell
description: Создание сценариев для производительности в PowerShell
ms.prod: windows-server-threshold
ms.technology: performance-tuning-guide
ms.topic: article
ms.author: JasonSh
author: lzybkr
ms.date: 10/16/2017
ms.openlocfilehash: df406c7e382907ca32006ec4dae6537a140a91cf
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59830375"
---
# <a name="powershell-scripting-performance-considerations"></a>Рекомендации по производительности сценариев в PowerShell

Сценарии PowerShell, которые непосредственно использовать .NET и избежать конвейера, как правило, быстрее, чем идиоматичной PowerShell. Идиоматичной PowerShell обычно использует командлеты PowerShell использует функции и сильно, часто используя конвейера и удаление в .NET только в случае необходимости.

>[!Note] 
> Многие из описанных здесь не идиоматичной PowerShell и может привести к снижению удобства чтения скрипта PowerShell. Авторы сценариев рекомендуется использовать идиоматичной PowerShell в том случае, если не определяет производительность, в противном случае.

## <a name="suppressing-output"></a>Подавление выходных данных

Существует много способов избежать написания объекты в конвейер:

```PowerShell
$null = $arrayList.Add($item)
[void]$arrayList.Add($item)
```

Назначение `$null` или преобразовании `[void]` примерно эквивалентны и обычно будут иметь больший приоритет, где важна производительность.

```PowerShell
$arrayList.Add($item) > $null
```

Чтобы при перенаправлении файлов `$null` — почти так же хорошо, как предыдущий альтернативных вариантов, наиболее скриптов никогда не заметите разницу.
В зависимости от сценария перенаправление файловой хотя вводят немного дополнительной памяти.

```PowerShell
$arrayList.Add($item) | Out-Null
```

Перенаправляется прямо `Out-Null` имеет значительную нагрузку по сравнению с альтернативные решения.
Его следует избежать в производительности важного кода.

```PowerShell
$null = . {
    $arrayList.Add($item)
    $arrayList.Add(42)
}
```

Введение в блок сценария и вызов его (с использованием точки источников или иным образом), а затем присвоить результат для `$null` — это удобный способ для подавления выходных данных большой блок скрипта.
Этот метод выполняет примерно, а также передачи, чтобы `Out-Null` и в скрипт конфиденциальных производительности следует избегать.
Накладные расходы в этом примере берется из создания и вызова блок скрипта, который ранее был встроенный сценарий.


## <a name="array-addition"></a>Добавление массива

Создание списка элементов часто выполняется с помощью массива с помощью оператора сложения:

```PowerShell
$results = @()
$results += Do-Something
$results += Do-SomethingElse
$results
```

Это может быть очень inefficent, так как массивы являются неизменяемыми.
Каждый добавляемый массив фактически создает новый массив, размер недостаточен для хранения всех элементов из левого и правого операндов, а затем копирует элементы коллекции оба операнда в новый массив.
Для небольших коллекций эти издержки могут не имеет значения.
Для больших коллекций это определенно может быть проблема.

Существует несколько вариантов.
Если вам не требуется фактически массив, вместо этого рассмотрите возможность использования ArrayList:

```PowerShell
$results = [System.Collections.ArrayList]::new()
$results.AddRange((Do-Something))
$results.AddRange((Do-SomethingElse))
$results
```

Если вам требуется массив, можно использовать собственные `ArrayList` и просто вызвать `ArrayList.ToArray` при необходимости массива.
Кроме того, вы можете разрешить PowerShell создать `ArrayList` и `Array` для вас:

```PowerShell
$results = @(
    Do-Something
    Do-SomethingElse
)
```

В этом примере команда PowerShell создает `ArrayList` для хранения результатов, записанных в конвейер, в выражении массива.
Просто перед назначением `$results`, преобразует PowerShell `ArrayList` для `object[]`.

## <a name="processing-large-files"></a>Обработка больших файлов

Идиоматичной способ обработки файла в PowerShell может выглядеть следующим образом:

```PowerShell
Get-Content $path | Where-Object { $_.Length -gt 10 }
```

Это может быть почти на порядок медленнее, чем непосредственно с помощью API-интерфейсы .NET:

```PowerShell
try
{
    $stream = [System.IO.StreamReader]::new($path)
    while ($line = $stream.ReadLine())
    {
        if ($line.Length -gt 10)
        {
            $line
        }
    }
}
finally
{
    $stream.Dispose()
}
```

## <a name="avoid-write-host"></a>Избегайте Write-Host

Как правило, он считается делать для записи выходных данных напрямую на консоль, но когда именно стоит использовать во многих скриптах `Write-Host`.

Если это нужно много сообщений в консоль, `Write-Host` может быть на порядок медленнее, чем `[Console]::WriteLine()`. Имейте в виду, `[Console]::WriteLine()` является только подходящая альтернатива для конкретных узлов, например powershell.exe или powershell_ise.exe — не гарантируется для работы на всех узлах.

Вместо использования `Write-Host`, рассмотрите возможность использования [Write-Output](/powershell/module/Microsoft.PowerShell.Utility/Write-Output?view=powershell-5.1).


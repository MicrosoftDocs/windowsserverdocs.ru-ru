---
title: для
description: Справочная статья для команды for, которая запускает указанную команду для каждого файла в наборе файлов.
ms.topic: reference
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
ms.author: lizross
author: eross-msft
manager: mtillman
ms.date: 10/16/2017
ms.openlocfilehash: a7cb7d2882a0af886ead2a74de5b56c00302e589
ms.sourcegitcommit: db2d46842c68813d043738d6523f13d8454fc972
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2020
ms.locfileid: "89634838"
---
# <a name="for"></a>для

Выполняет указанную команду для каждого файла в наборе файлов.

## <a name="syntax"></a>Синтаксис

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>Параметры

| Параметр | Описание |
| --------- | ----------- |
| `{%% | %}<variable>` | Обязательный элемент. Представляет заменяемый параметр. Используйте один знак процента ( `%` ), чтобы выполнить команду **for** в командной строке. Используйте двойные знаки процента ( `%%` ) для выполнения команды **for** в пакетном файле. Переменные чувствительны к регистру и должны быть представлены в алфавитном значении, например **% a**, **% b**или **% c**. |
| (`<set>`) | Обязательный элемент. Указывает один или несколько файлов, каталогов или текстовых строк или диапазон значений, по которым должна выполняться команда. Необходимо поставить скобки. |
| `<command>` | Обязательный элемент. Указывает команду, которую нужно выполнить для каждого файла, каталога или текстовой строки, или диапазон значений, включенных в *набор*. |
| `<commandlineoptions>` | Задает параметры командной строки, которые необходимо использовать с указанной командой. |
| /? | Отображение справки в командной строке. |

#### <a name="remarks"></a>Примечания

- Эту команду можно использовать в пакетном файле или непосредственно в командной строке.

- К команде **for** применяются следующие атрибуты:

  - Эта команда заменяет `% variable` или `%% variable` с каждой текстовой строкой в указанном наборе до тех пор, пока указанная команда не обработает все файлы.

  - В именах переменных учитывается регистр, глобальная и не более 52 может быть активна за один раз.

  - Чтобы избежать путаницы с параметрами пакетной службы, `%0` `%9` можно использовать любой символ для *переменной* , кроме цифр от **0** до **9**. Для простых пакетных файлов один символ, например, `%%f` будет работать.

  - Можно использовать несколько значений для *переменной* в сложных пакетных файлах для различения разных заменяемых переменных.

- Параметр *Set* может представлять одну группу файлов или несколько групп файлов. Для указания набора файлов можно использовать подстановочные знаки (**&#42;** и **?**). Ниже приведены допустимые наборы файлов.

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- При использовании этой команды первое значение в *Set* заменяет `% variable` или `%% variable` , а затем заданная команда обрабатывает это значение. Это будет продолжаться до тех пор, пока не будут обработаны все файлы (или группы файлов), соответствующие *заданному значению* .

- **В** и **не имеют** параметров, но их необходимо использовать с этой командой. Если опустить одно из этих ключевых слов, появится сообщение об ошибке.

- Если расширения команд включены (по умолчанию), поддерживаются следующие дополнительные формы **для** :

  - **Только каталоги:** Если *параметр SET* содержит подстановочные знаки (**&#42;** или **?**), то указанная *команда* выполняется для каждого каталога (вместо набора файлов в указанном каталоге), соответствующего заданному *набору*. Синтаксис:

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **Рекурсивно:** Просматривает дерево каталогов, корневое в папке *Drive*:*path* , и выполняет инструкцию **for** в каждом каталоге дерева. Если после **/r**не указан каталог, в качестве корневого каталога используется текущий каталог. Если *параметр задан* только как одиночная точка (.), он только перечисляет дерево каталогов. Синтаксис:

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - **Итерация диапазона значений:** Используйте итерационную переменную, чтобы задать начальное значение (*Start*#), а затем пошаговое задание диапазона значений до тех пор, пока значение не превысит установленное конечное значение (*End*#). **/l** выполняет итеративный вызов, сравнивая *Start*# с *End*#. Если *Start*# меньше, чем *End*#, команда будет выполнена. Когда итерационная переменная превышает *End*#, Командная оболочка завершает цикл. Можно также использовать отрицательный *шаг*# для прохода по диапазону по убыванию значений. Например, (1, 1, 5) формирует последовательность 1 2 3 4 5, а (5,-1, 1) формирует последовательность 5 4 3 2 1. Синтаксис:

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **Итерация и синтаксический анализ файлов:** Используйте синтаксический анализ файлов для обработки выходных данных команды, строк и содержимого файлов. Используйте итерационные переменные для определения содержимого или строк, которые необходимо проверить, и используйте различные параметры *парсингкэйвордс* для дальнейшего изменения разбора.  Используйте параметр токена *парсингкэйвордс* , чтобы указать, какие токены должны передаваться как итерационные переменные. Обратите внимание, что при использовании без параметра token функция **/f** будет проверять только первый токен.

    Анализ файлов состоит из чтения выходных данных, строки или содержимого файла, а затем разбивает их на отдельные строки текста и анализирует каждую строку в ноль или более маркеров. Затем цикл **for** вызывается с итерационным значением переменной, заданным для маркера. По умолчанию **/f** передает первый пустой отделенный маркер из каждой строки каждого файла. Пустые строки пропускаются.

    Синтаксис:

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    Аргумент *Set* указывает одно или несколько имен файлов. Каждый файл открывается, считывается и обрабатывается перед переходом к следующему файлу в *наборе*. Чтобы переопределить поведение при синтаксическом анализе по умолчанию, укажите *парсингкэйвордс*. Это строка в кавычках, содержащая одно или несколько ключевых слов для указания различных параметров анализа.

    Если используется параметр **усебаккк** , используйте один из следующих синтаксисов:

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    В следующей таблице перечислены ключевые слова синтаксического анализа, которые можно использовать для *парсингкэйвордс*.

    | Ключевое слово | Описание |
    | ------- | ----------- |
    | конца строки =`<c>` | Задает символ конца строки (всего один символ). |
    | пропустить =`<n>` | Указывает число пропускаемых строк в начале файла. |
    | делимс =`<xxx>` | Задает набор разделителей. Это заменяет набор разделителей по умолчанию пробела и табуляции. |
    | токены =`<x,y,m–n>` | Указывает, какие токены из каждой строки должны передаваться в цикл **for** для каждой итерации. В результате выделяются дополнительные имена переменных. *m-n* указывает диапазон от *m*до *n*-го маркера. Если последним символом в строке **tokens =** является звездочка (**&#42;**), выделяется дополнительная переменная и получается оставшийся текст в строке после последнего проанализированного маркера. |
    | усебаккк | Задает выполнение строки в кавычках в виде команды, использование строки с одной кавычкой в качестве литеральной строки или для длинных имен файлов, содержащих пробелы, позволяет заключать имена файлов в `<set>` двойные кавычки. |

  - **Подстановка переменных:** В следующей таблице перечислены необязательные синтаксисы (для любой переменной **I**).

    | Переменная с модификатором | Описание |
    | ---------------------- | ----------- |
    |` %~I` | Развертывает `%I` , удаляя все окружающие кавычки. |
    | `%~fI `| Разворачивается `%I` до полного имени пути. |
    | `%~dI `| Разворачивается `%I` только буква диска. |
    | `%~pI` | Разворачивается `%I` только по пути. |
    | `%~nI `| Разворачивается `%I` только на имя файла. |
    | `%~xI` | Разворачивается `%I` только на расширение имени файла. |
    | `%~sI` | Разворачивает путь, чтобы содержать только короткие имена. |
    | `%~aI` | Разворачивается `%I` в файловые атрибуты файла. |
    | `%~tI` | Разворачивается `%I` до даты и времени файла. |
    | `%~zI` | Разворачивается `%I` до размера файла. |
    | `%~$PATH:I` | Выполняет поиск в каталогах, перечисленных в переменной среды PATH, и раскрывает полное `%I` имя первого найденного каталога. Если имя переменной среды не определено или файл не найден при поиске, этот модификатор разворачивается до пустой строки. |

    В следующей таблице перечислены сочетания модификаторов, которые можно использовать для получения составных результатов.

    | Переменная с объединенными модификаторами | Описание |
    | -------------------------------- | ----------- |
    | `%~dpI `| Разворачивается `%I` только буква диска и путь. |
    | `%~nxI` | Развертывает `%I` только имя файла и расширение. |
    | `%~fsI` | Разворачивается `%I` в полное имя пути с краткими именами. |
    | `%~dp$PATH:I` | Выполняет поиск в каталогах, указанных в переменной среды PATH для `%I` , и разворачивается на букву диска и путь к первой найденной папке. |
    | `%~ftzaI` | Разворачивается `%I` в выходную строку, похожую на **dir**. |

    В приведенных выше примерах можно заменить `%I` и Path другими допустимыми значениями. Допустимое **имя переменной завершает** **%~** синтаксис.

    Используя имена переменных в верхнем регистре, например `%I` , можно сделать код более читаемым и избежать путаницы с модификаторами, которые не чувствительны к регистру.

- **Синтаксический анализ строки:** `for /f` Логику синтаксического анализа можно использовать в непосредственной строке путем заключения `<literalstring>` в двойные кавычки (*без* усебаккк) или в одинарные кавычки (*with* усебаккк), например (MyString) или (' MyString '). `<literalstring>` рассматривается как одна строка входных данных из файла. При синтаксическом анализе `<literalstring>` в двойных кавычках символы команд (например, `\ & | > < ^` ) обрабатываются как обычные символы.

- **Синтаксический анализ выходных данных:** Можно использовать `for /f` команду для анализа выходных данных команды путем помещения обратной кавычки `<command>` между круглыми скобками. Он рассматривается как Командная строка, которая передается дочернему Cmd.exeу. Выходные данные фиксируются в памяти и анализируются так, как если бы это был файл.

## <a name="examples"></a>Примеры

Чтобы использовать **для** в пакетном файле, используйте следующий синтаксис:

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

Чтобы отобразить содержимое всех файлов в текущем каталоге с расширением DOC или txt, используя заменяемую переменную **% f**, введите:

```
for %f in (*.doc *.txt) do type %f
```

В предыдущем примере каждый файл, имеющий расширение DOC или txt в текущем каталоге, подставляется для переменной **% f** до тех пор, пока не будет отображено содержимое каждого файла. Чтобы использовать эту команду в пакетном файле, замените каждое вхождение **% f** на **%% f**. В противном случае переменная игнорируется и выводится сообщение об ошибке.

Чтобы выполнить синтаксический анализ файла, игнорируя строки с комментариями, введите:

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

Эта команда анализирует каждую строку в *myfile.txt*. Он игнорирует строки, начинающиеся с точки с запятой, и передает второй и третий токены из каждой строки в тело **для** тела (маркеры разделяются запятыми или пробелами). Тело инструкции **for** ссылается на **% i** , чтобы получить второй токен **% j** для получения третьего маркера, и **% k** , чтобы получить все остальные токены. Если указываемые имена файлов содержат пробелы, заключите его в кавычки (например, имя файла). Чтобы использовать кавычки, необходимо использовать **усебаккк**. В противном случае кавычки будут интерпретированы как определение литеральной строки для синтаксического анализа.

**% i** явно объявлен в операторе **for** . **% j** и **% k** неявно объявляются с помощью **токенов =**. **Токены** можно использовать для указания до 26 маркеров, при условии что не будет пытаться объявить переменную выше буквы Z или z.

Чтобы проанализировать выходные данные команды, заставив в скобки *заданную* команду, введите:

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>Дополнительные ссылки

- [Условные обозначения синтаксиса команд командной строки](command-line-syntax-key.md)

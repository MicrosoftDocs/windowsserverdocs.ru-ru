---
title: для
description: 'Раздел Windows команды для ***- '
ms.custom: na
ms.prod: windows-server-threshold
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 13a44bc3497b44d60bd4d351e389d493a50f1269
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59869465"
---
# <a name="for"></a>для



Выполняет указанную команду для каждого файла в набор файлов.

В разделе [Примеры](#BKMK_examples) показан принцип использования этой команды.

## <a name="syntax"></a>Синтаксис

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>Параметры

|Параметр|Описание|
|---------|-----------|
|{%%\|%}\<Переменной >|Обязательный. Представляет параметр, можно заменить. Используйте одинарный знак процента (**%**) для выполнения **для** команду в командной строке. Используйте двойные символы процента (**%%**) для выполнения **для** команды в пакетном файле. Переменные чувствительны к регистру, и они должны быть представлены с буквенно-цифровое значение например **%A**, **%B**, или **%C**.|
|(\<Значение >)|Обязательный. Указывает один или несколько файлов, каталоги, или текстовые строки или диапазон значений, на котором запускается команда. Скобки являются обязательными.|
|\<Команда >|Обязательный. Указывает команду, которую нужно выполнить, для каждого файла, каталога или текстовую строку или по диапазону значений, включенных в *задать*.|
|\<ПараметрыКоманднойСтроки >|Задает параметры командной строки, которые вы хотите использовать с заданной команды.|
|/?|Отображение справки в командной строке.|

## <a name="remarks"></a>Примечания

-   С помощью **для**

    Можно использовать **для** команды в пакетном файле или непосредственно из командной строки.
-   С помощью параметров пакета

    Следующие атрибуты применяются к **для** команды:  
    -   **Для** команда заменяет **% *** переменной* или **%% *** переменной* каждой строкой текста в заданном наборе, пока указанная команда не обработает все файлы.
    -   В именах переменных учитывается регистр, глобальных и больше, чем 52 могут быть активны одновременно.
    -   Чтобы избежать путаницы с параметры пакета **%0** через **%9**, можно использовать любой символ, для *переменной* цифры от 0 до 9, за исключением. Для простых пакетных файлов, один символ, такой как **фильтр:** будет работать.
    -   Можно использовать несколько значений для *переменной* в сложных пакетных файлах, чтобы различать разные подставляемые переменные.
-   Указание группы файлов

    *Задать* параметр может представлять группу файлов или несколько групп файлов. Можно использовать подстановочные знаки (**&#42;** и **?**) для указания файла задайте. Ниже перечислены наборы допустимый файл.  
    ```
    (*.doc) 
    (*.doc *.txt *.me)
    (jan*.doc jan*.rpt feb*.doc feb*.rpt)
    (ar??1991.* ap??1991.*)
    ```  
    При использовании **для** команды, первое значение в *задать* заменяет **% *** переменной* или **%% *** переменной*и затем указанного команда обрабатывает это значение. Это продолжается, пока все файлы (или группы файлов), соответствующие *задать* обрабатываются значение.
-   С помощью **в** и **сделать** ключевые слова

    **В** и **сделать** не являются параметрами, но требуется использовать их с **для**. Если опустить либо из этих ключевых слов, появится сообщение об ошибке.
-   Использование дополнительных форм **для**

    Если включены расширения команд (которые по умолчанию), следующие дополнительные формы **для** поддерживаются:  
    -   Только каталоги

        Если *задать* содержит подстановочные знаки (**&#42;** или **?**), указанный *команда* выполняется для каждого каталога (вместо набора файлы в указанном каталоге), соответствующий *задать*.

        Синтаксис выглядит следующим образом.  
        ```
        for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
        ```  
    -   Recursive

        Проходит по дереву каталогов, выходящую *диска*:*путь* и выполняет **для** инструкцию в каждом каталоге дерева. Если каталог не указан после **/r**, используется текущий каталог в качестве корневого каталога. Если *задать* просто является одной точкой (.), он только перечисляет дерево каталогов.

        Синтаксис выглядит следующим образом.  
        ```
        for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        ```  
    -   Итерация диапазона значений

        Используйте переменную итерации, чтобы задать начальное значение (*запустить*#) и затем пошагово по диапазону значений, пока значение превышает заданное конечное значение (*окончания*#). **/l** выполнит итерацию, сравнивая *запустить*# с *окончания*#. Если *запустить*# — это меньше, чем *окончания*#, команда будет выполняться. Если переменная итерации превышает *окончания*#, командная оболочка выходит из цикла. Можно также использовать отрицательное *шаг*#, чтобы шаг уменьшение значения в диапазоне. Например, (1,1,5) создает последовательность 1 2 3 4 5 и (5,-1, 1) создает последовательность 5 4 3 2 1.

        Синтаксис выглядит следующим образом.  
        ```
        for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
        ```  
    -   Итерация и разбор файлов

        Использование файла, синтаксический анализ команды ее выходные данные процесса, строки и содержимое файла.  Используйте переменные итерации для определения содержимого или строки, которые вы хотите проанализировать и использовать различные *КлючевыеСловаРазбора* параметры для дополнительного изменения синтаксический анализ.  Используйте *КлючевыеСловаРазбора* token параметр, чтобы указать, какие лексемы должны передаваться как переменные итерации. Обратите внимание, что при использовании без параметра токена **/f** будет проверять только первый токен.

        Анализ файлов состоит из чтение выходных данных, строка или содержимое файла, разбив его на отдельные строки текста и разборе каждой строки на ноль или более токенов. **Для** цикл вызывается с помощью переменной итерации значение маркера. По умолчанию **/f** передает маркер первого пустую запятыми из каждой строки каждого файла. Пустые строки пропускаются.

        Синтаксисы являются:  
        ```
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
        ```  
        *Задать* аргумент задает один или несколько имен файлов. Каждый файл открыт, чтения и обработки, прежде чем перейти к следующему файлу *задать*. Чтобы переопределить синтаксический разбор по умолчанию, укажите *КлючевыеСловаРазбора*. Это строка в кавычках, которая содержит один или несколько ключевых слов для указания различных режимов разбора.

        Если вы используете **usebackq** , используйте один из следующих вариантов синтаксиса:  
        ```
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
        ```  
        В следующей таблице перечислены синтаксического анализа ключевых слов, которые можно использовать для *КлючевыеСловаРазбора*.  
        |Ключевое слово|Описание|
        |-------|-----------|
        |eol=\<c>|Указывает символ конца строки (только один символ).|
        |skip=\<N>|Указывает число строк необходимо пропустить в начале файла.|
        |delims=\<xxx>|Задает набор разделителей. Этот параметр заменяет набор разделителей по умолчанию пространства и вкладки.|
        |маркеры =\<X, Y, M-N >|Указывает, какие лексемы в каждой строке должны быть переданы **для** цикл для каждой итерации. Таким образом выделяются дополнительные имена переменных. *M*—*N* указывает диапазон, из *M*-го по *N*ый. Если последним символом в **маркеры =** строка представляет собой звездочку (**&#42;**), выделяется дополнительную переменную и получении оставшийся текст в строке после последнего токена, который анализируется.|
        |usebackq|Указывает: выполнить строку в кавычках назад в качестве команды, используйте строку с одиночными кавычками как строковый литерал или, для длинные имена файлов, содержащие пробелы, позволяет использовать имена файлов в  *\<задать\>*, чтобы каждый заключаться в двойные кавычки.|
    -   Подстановка переменных

        В следующей таблице перечислены дополнительный синтаксис (для любой переменной **я**).  
        |Переменная с модификатором|Описание|
        |----------------------|-----------|
        |% ~ Я|Разворачивает **%I** которая удаляет любые знаков кавычек (» «).|
        |% ~ fI|Разворачивает **%I** полное имя.|
        |% ~ dI|Разворачивает **%I** только букву диска.|
        |% ~ pI|Разворачивает **%I** только путь.|
        |% ~ nI|Разворачивает **%I** только имени файла.|
        |% ~ xI|Разворачивает **%I** к только расширение имени файла.|
        |% ~ sI|Замена путем, содержащим только короткие имена.|
        |% ~ искусственного интеллекта|Разворачивает **%I** в файл атрибуты файла.|
        |% ~ tI|Разворачивает **%I** даты и времени файла.|
        |% ~ zI|Разворачивает **%I** для размера файла.|
        |% ~ $PATH: Я|Поиск в каталогах, указанных в переменной среды PATH и замена **%I** первый каталог, полное имя. Если имя переменной среды не определен или файл не найден, поиск, этот модификатор расширяется пустая строка.|

        В следующей таблице перечислены сочетания модификатор, которые можно использовать для получения более сложных результатов.  
        |Переменная с Комбинированные модификаторы|Описание|
        |--------------------------------|-----------|
        |% ~ точек на дюйм|Разворачивает **%I** букву диска и пути.|
        |% ~ nxI|Разворачивает **%I** имя файла и расширение только.|
        |% ~ fsI|Разворачивает **%I** для полного пути с помощью только короткие имена.|
        |% ~ dp путь $: я|Поиск в каталогах, которые перечислены в переменной среды PATH для **%I** и букву диска и путь к первому найденному при развертывании.|
        |% ~ ftzaI|Разворачивает **%I** для вывода строки, который похож на **dir**.|

        В приведенных выше примерах, можно заменить **%I** и путь с использованием другие допустимые значения. Является допустимым **для** завершает имя переменной **%~** синтаксис.

        С помощью верхний регистр имен переменных, таких как **%I**, можно сделать код более понятным и избежать путаницы с модификаторами, в которых не учитывают регистр.
-   Синтаксический анализ строки

    Можно использовать **для /f** синтаксического немедленно для строки с помощью упаковки *\<LiteralString\>* одним: двойные кавычки (*без* « usebackq») или в одинарные кавычки (*с* «usebackq») — например, («MyString») или («MyString»). *\<LiteralString\>*  рассматривается как одна строка входных данных из файла. При синтаксическом анализе *\<LiteralString\>* в двойные кавычки, управляющие символы (такие как **\\ \& \| \> \< \^**) рассматриваются как обычные символы.
-   Синтаксический анализ выходных данных

    Можно использовать **для /f** команду, чтобы проанализировать выходные данные команды, поместив в кавычках Назад *\<команда\>* заключено в круглые скобки. Он рассматривается как в командной строке, которая передается дочерним Cmd.exe. Выходные данные помещаются в памяти и синтаксического анализа, а если он представляет собой файл.

## <a name="BKMK_examples"></a>Примеры

Чтобы использовать **для** в пакетном файле, используйте следующий синтаксис:
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
Чтобы отобразить содержимое всех файлов в текущем каталоге с расширением DOC или txt с помощью заменяемой переменной **%f**, тип:
```
for %f in (*.doc *.txt) do type %f 
```
В приведенном выше примере каждый файл с расширением DOC или txt в текущем каталоге заменяется **%f** переменной до отображения каждого файла. Чтобы использовать эту команду в пакетном файле, заменять каждое вхождение **%f** с **фильтр:**. В противном случае переменная игнорируется, и отображается сообщение об ошибке.

Анализ файла, игнорируя комментарии, тип:
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
Эта команда выполняет синтаксический анализ каждой строки в Myfile.txt. Он игнорирует строки, начинающиеся с точки с запятой и передает второй и третий элементы из каждой строки **для** текст (токены разделяются запятыми или пробелами). Тело **для** оператор, ссылающийся на **%i** для получения маркера, второй **%j** для получения токена, третий, и **%k** для получения всех оставшихся маркеры. Если имена файлов, которые вы предоставляете содержат пробелы, используйте кавычки вокруг текста (например, «имя файла»). Чтобы использовать кавычки, необходимо использовать **usebackq**. В противном случае кавычки, интерпретируются как определяющие строковый литерал для синтаксического анализа.

**%i** был объявлен явным образом в **для** инструкции. **%j** и **%k** неявно объявляются с помощью **маркеры =**. Можно использовать **маркеры =** указание до 26 элементов при условии, что не происходит попытка объявить переменную, выше, чем буква «z» или «Z».

В следующем примере перечисляются имена переменных среды в текущем окружении. Чтобы проанализировать выходные данные команды, поместив *задать* заключено в круглые скобки, введите:
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>Дополнительная справка

[Ключ синтаксиса командной строки](command-line-syntax-key.md)

---
title: для
description: 'Раздел Windows команды для ****- '
ms.custom: na
ms.prod: windows-server
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: db0bf54e35e4226cb020b040d5fc36ddd88dc02b
ms.sourcegitcommit: 6aff3d88ff22ea141a6ea6572a5ad8dd6321f199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71377120"
---
# <a name="for"></a>для



Выполняет указанную команду для каждого файла в наборе файлов.

В разделе [Примеры](#BKMK_examples) показан принцип использования этой команды.

## <a name="syntax"></a>Синтаксис

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>Параметры

|Параметр|Описание|
|---------|-----------|
|{%% \|%} \<Variable >|Обязательный. Представляет заменяемый параметр. Используйте один знак процента ( **%** **) для выполнения команды в** командной строке. Используйте двойные знаки процентов ( **%%** ) для выполнения команды **for** в пакетном файле. Переменные чувствительны к регистру и должны быть представлены в алфавитном значении, например **% A**, **% B**или **% C**.|
|(\<Set >)|Обязательный. Указывает один или несколько файлов, каталогов или текстовых строк или диапазон значений, по которым должна выполняться команда. Круглые скобки являются обязательными.|
|@no__t 0Command >|Обязательный. Указывает команду, которую нужно выполнить для каждого файла, каталога или текстовой строки, или диапазон значений, включенных в *набор*.|
|@no__t 0CommandLineOptions >|Задает параметры командной строки, которые необходимо использовать с указанной командой.|
|/?|Отображение справки в командной строке.|

## <a name="remarks"></a>Примечания

- Использование **для**

  Команду **for** можно использовать в пакетном файле или непосредственно в командной строке.
- Использование параметров пакетной службы

  К команде **for** применяются следующие атрибуты:  
  - Команда **for** заменяет<em>переменную</em> **%** или **%%** <em>переменной</em> на каждую текстовую строку в указанном наборе до тех пор, пока заданная команда не обработает все файлы.
  - В именах переменных учитывается регистр, глобальная и не более 52 может быть активна за один раз.
  - Чтобы избежать путаницы с параметрами пакетной службы **% 0** по **% 9**, можно использовать любой символ для *переменной* , кроме цифр от 0 до 9. Для простых пакетных файлов будет работать один символ, например **%% f** .
  - Можно использовать несколько значений для *переменной* в сложных пакетных файлах для различения разных заменяемых переменных.
- Указание группы файлов

  Параметр *Set* может представлять одну группу файлов или несколько групп файлов. Для указания набора файлов можно использовать **&#42;** подстановочные знаки (и **?** ). Ниже приведены допустимые наборы файлов.  
  ```
  (*.doc) 
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```  
  При использовании команды **for** первое значение *набора* заменяет<em>переменную</em> **%** или **%%** <em>, а</em>затем заданная команда обрабатывает это значение. Это будет продолжаться до тех пор, пока не будут обработаны все файлы (или группы файлов), соответствующие *заданному значению* .
- Использование ключевых слов **in** и **Do**

  **В** и **Do** не являются параметрами, но их необходимо использовать с **для**. Если опустить одно из этих ключевых слов, появится сообщение об ошибке.
- Использование дополнительных форм **для**

  Если расширения команд включены (по умолчанию), поддерживаются следующие дополнительные формы **для** :  
  - Только каталоги

    Если *параметр SET* содержит подстановочные **&#42;** знаки (или **?** ), указанная *команда* выполняется для каждого каталога (вместо набора файлов в указанном каталоге), соответствующего заданному *набору*.

    Синтаксис выглядит следующим образом.  
    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
    ```  
  - Recursive

    Просматривает дерево каталогов, корневое в папке *Drive*:*path* , и выполняет инструкцию **for** в каждом каталоге дерева. Если после **/r**не указан каталог, в качестве корневого каталога используется текущий каталог. Если *параметр задан* только как одиночная точка (.), он только перечисляет дерево каталогов.

    Синтаксис выглядит следующим образом.  
    ```
    for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```  
  - Итерация диапазона значений

    Используйте итерационную переменную, чтобы задать начальное значение (*Start*#), а затем пошаговое задание диапазона значений до тех пор, пока значение не превысит установленное конечное значение (*End*#). **/l** выполняет итеративный вызов, сравнивая *Start*# с *End*#. Если *Start*# меньше, чем *End*#, команда будет выполнена. Когда итерационная переменная превышает *End*#, Командная оболочка завершает цикл. Можно также использовать отрицательный *шаг*# для прохода по диапазону по убыванию значений. Например, (1, 1, 5) формирует последовательность 1 2 3 4 5, а (5,-1, 1) формирует последовательность 5 4 3 2 1.

    Синтаксис выглядит следующим образом.  
    ```
    for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
    ```  
  - Итерация и синтаксический анализ файлов

    Используйте синтаксический анализ файлов для обработки выходных данных команды, строк и содержимого файлов.  Используйте итерационные переменные для определения содержимого или строк, которые необходимо проверить, и используйте различные параметры *парсингкэйвордс* для дальнейшего изменения разбора.  Используйте параметр токена *парсингкэйвордс* , чтобы указать, какие токены должны передаваться как итерационные переменные. Обратите внимание, что при использовании без параметра token функция **/f** будет проверять только первый токен.

    Анализ файлов состоит из чтения выходных данных, строки или содержимого файла, а затем разбивает их на отдельные строки текста и анализирует каждую строку в ноль или более маркеров. Затем цикл **for** вызывается с итерационным значением переменной, заданным для маркера. По умолчанию **/f** передает первый пустой отделенный маркер из каждой строки каждого файла. Пустые строки пропускаются.

    Синтаксис:  
    ```
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
    for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
    ```  
    Аргумент *Set* указывает одно или несколько имен файлов. Каждый файл открывается, считывается и обрабатывается перед переходом к следующему файлу в *наборе*. Чтобы переопределить поведение при синтаксическом анализе по умолчанию, укажите *парсингкэйвордс*. Это строка в кавычках, содержащая одно или несколько ключевых слов для указания различных параметров анализа.

    Если используется параметр **усебаккк** , используйте один из следующих синтаксисов:  
    ```
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
    for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
    ```  
    В следующей таблице перечислены ключевые слова синтаксического анализа, которые можно использовать для *парсингкэйвордс*.  

    |      Ключевое слово      |                                                                                                                                                                                                          Описание                                                                                                                                                                                                          |
    |-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    |     конца строки = @no__t — 0c >      |                                                                                                                                                                                   Задает символ конца строки (всего один символ).                                                                                                                                                                                    |
    |     Skip = \<N >     |                                                                                                                                                                              Указывает число пропускаемых строк в начале файла.                                                                                                                                                                              |
    |   делимс = @no__t — 0xxx >   |                                                                                                                                                                     Задает набор разделителей. Это заменяет набор разделителей по умолчанию пробела и табуляции.                                                                                                                                                                      |
    | tokens = \<X, Y, M – N > | Указывает, какие токены из каждой строки должны передаваться в цикл **for** для каждой итерации. В результате выделяются дополнительные имена переменных. *M*–*N* указывает диапазон от *M*до *n*-го маркера. Если последним символом в строке **tokens =** является звездочка ( **&#42;** ), выделяется дополнительная переменная и получается оставшийся текст в строке после последнего проанализированного маркера. |
    |     усебаккк      |                                                                                             Указывает: выполнение строки в кавычках в виде команды, использование строки с одной кавычкой в качестве литеральной строки или для длинных имен файлов, содержащих пробелы, позволяет заключать имена файлов в *\<Set @ no__t-2*в двойные кавычки.                                                                                              |


  - Подстановка переменных

    В следующей таблице приведен необязательный синтаксис (для любой переменной **I**).  

    |Переменная с модификатором|Описание|
    |----------------------|-----------|
    |% ~ I|Развертывает **% I** , который удаляет все окружающие кавычки ("").|
    |% ~ fI|Развертывает **% I** до полного имени пути.|
    |% ~ dI|Увеличивает **% I** на букву диска.|
    |% ~ pI|Развертывает **% I** только по пути.|
    |% ~ nI|Разворачивает **% I** только на имя файла.|
    |% ~ xI|Развертывает **% I** только на расширение имени файла.|
    |% ~ sI|Разворачивает путь, чтобы содержать только короткие имена.|
    |% ~ aI|Расширяет **% I** на атрибуты файла файла.|
    |% ~ tI|Увеличивает **% I** до даты и времени файла.|
    |% ~ zI|Расширяет **% I** до размера файла.|
    |% ~ $PATH: I|Выполняет поиск в каталогах, перечисленных в переменной среды PATH, и разворачивает **% I** до полного имени найденного первого каталога. Если имя переменной среды не определено или файл не найден при поиске, этот модификатор разворачивается до пустой строки.|

    В следующей таблице перечислены сочетания модификаторов, которые можно использовать для получения составных результатов.  

    |Переменная с объединенными модификаторами|Описание|
    |--------------------------------|-----------|
    |% ~ dpI|Увеличивает **% I** на букву диска и только путь.|
    |% ~ НКСИ|Развертывает **% I** только для имени файла и расширения.|
    |% ~ fsI|Расширение **% I** до полного пути с краткими именами.|
    |% ~ DP $ путь: I|Выполняет поиск в каталогах, перечисленных в переменной среды PATH, для **% I** и разворачивается на букву диска и путь к первой найденной папке.|
    |% ~ Фтзаи|Расширяет **% I** на выходную строку, похожую на " **dir**".|

    В приведенных выше примерах можно заменить **% I** и Path другими допустимыми значениями. Допустимое **имя переменной завершает** синтаксис **%~** .

    Используя имена переменных в верхнем регистре, такие как **% I**, можно сделать код более читаемым и избежать путаницы с модификаторами, которые не чувствительны к регистру.
- Синтаксический анализ строки

  Логику синтаксического анализа **for/f** можно использовать в непосредственной строке путем заключения *\<LiteralString @ no__t-3* в двойные кавычки (*без* "усебаккк") или в одинарных кавычках (*с* "усебаккк"), например ("MyString") или (' MyString '). *\<LiteralString @ no__t-2* рассматривается как одна строка входных данных из файла. При синтаксическом анализе *\<LiteralString @ no__t-2* в двойных кавычках символы команд (такие как **\\ \& \| \> \< \^** ) обрабатываются как обычные символы.
- Синтаксический анализ выходных данных

  Можно использовать команду **for/f** для анализа выходных данных команды, поместив в круглые скобки *\<command @ no__t-3* с обратной кавычкой. Он рассматривается как Командная строка, которая передается в дочерний файл cmd. exe. Выходные данные фиксируются в памяти и анализируются так, как если бы это был файл.

## <a name="BKMK_examples"></a>Примеров

Чтобы использовать **для** в пакетном файле, используйте следующий синтаксис:
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
Чтобы отобразить содержимое всех файлов в текущем каталоге с расширением DOC или txt, используя заменяемую переменную **% f**, введите:
```
for %f in (*.doc *.txt) do type %f 
```
В предыдущем примере каждый файл, имеющий расширение DOC или txt в текущем каталоге, подставляется для переменной **% f** до тех пор, пока не будет отображено содержимое каждого файла. Чтобы использовать эту команду в пакетном файле, замените каждое вхождение **% f** на **%% f**. В противном случае переменная игнорируется и выводится сообщение об ошибке.

Чтобы выполнить синтаксический анализ файла, игнорируя строки с комментариями, введите:
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
Эта команда анализирует каждую строку в файле MyFile. txt. Он игнорирует строки, начинающиеся с точки с запятой, и передает второй и третий токены из каждой строки в тело **для** тела (маркеры разделяются запятыми или пробелами). Тело инструкции **for** ссылается на **% i** , чтобы получить второй токен **% j** для получения третьего маркера, и **% k** , чтобы получить все остальные токены. Если указываемые имена файлов содержат пробелы, заключите его в кавычки (например, "имя файла"). Чтобы использовать кавычки, необходимо использовать **усебаккк**. В противном случае кавычки будут интерпретированы как определение литеральной строки для синтаксического анализа.

**% i** явно объявлен в операторе **for** . **% j** и **% k** неявно объявляются с помощью **токенов =** . **Токены** можно использовать для указания до 26 маркеров, при условии что не будет пытаться объявить переменную выше буквы "z" или "z".

В следующем примере перечисляются имена переменных среды в текущем окружении. Чтобы проанализировать выходные данные команды, заставив в скобки *заданную* команду, введите:
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>Дополнительная справка

[Условные обозначения синтаксиса команд командной строки](command-line-syntax-key.md)
